void player_event(player@p, string event) {
	if (buildobj_event(p, event)) return;
	messager md(event);
	string[] parsed = string_split(event, " ", true);
	if (parsed[0] == "stats" and parsed.length() > 1) {
		int index2 = get_player_index_from(parsed[1]);
		if (index2 < 0) {
			send_reliable(p, "Not found", 2);
			send_reliable(p, "play_s playerstats_error.ogg", 6);
			return;
		}
		string statslist;
		statslist = "The player " + players[index2].name + " which known as " + players[index2].nickname + " has been playing " + app.name + " for a total of " + ms_to_readable_time(players[index2].playtimer.elapsed) + ". Has sent " + players[index2].chats + " chats. Has " + players[index2].deaths + " deaths and " + players[index2].kills + " kills. Has a killing accuracy of " + round(percent(players[index2].kills, players[index2].kills + players[index2].deaths), 0) + " percent";
		if (players[index2].gender == 0) statslist += " " + players[index2].name + " is male. ";
		else if (players[index2].gender == 1) statslist += " " + players[index2].name + " is female. ";
		int t = is_in_team(players[index2].name);
		if (t > -1)
			statslist += " " + players[index2].name + " is in " + teams[t].teamname + " team. ";
		if (players[index2].age == 0 or players[index2].day == 0 or players[index2].month == 0 or players[index2].year == 0 or players[index2].country == "") {
			if (players[index2].gender == 0)players[index2].gender2 = "he's";
			else players[index2].gender2 = "her";
			statslist += "" + players[index2].name + " didn't complete " + players[index2].gender2 + " profile yet. ";
		} else {
			if (players[index2].age != 0)
				statslist += "" + players[index2].name + " is " + players[index2].age + " years old. ";
			if (players[index2].day != 0 and players[index2].month != 0 and players[index2].year != 0)
				statslist += "" + players[index2].name + " is born on " + players[index2].day + " " + players[index2].month + " " + players[index2].year + ". ";
			if (players[index2].country != "")
				statslist += "" + players[index2].name + " is from " + players[index2].country + ". ";
		}
		if (players[index2].partner != "")
			statslist += "" + players[index2].name + " is married to " + players[index2].partner + ". ";
		if (players[index2].status == "")
			statslist += "status for " + players[index2].name + ": no status message has been set. ";
		else
			statslist += "status for " + players[index2].name + ": " + players[index2].status + ". ";
		int cindex = get_compid_handler_index(players[index2].compid);
		if (cindex > -1 and directory_exists("chars/" + comphandles[cindex].playername))
			statslist += "" + players[index2].name + "'s main account is " + comphandles[cindex].playername + "";
		send_reliable(p, "play_s playerstats.ogg", 6);
		send_reliable(p, statslist, 2);
	} else if (parsed[0] == "status" and parsed.length() > 1) {
		string[] charfolders = find_directories("chars/*");
		file f;
		int found = charfolders.find(parsed[1]);
		if (found > -1) {
			f.open("chars/" + charfolders[charfolders.find(parsed[1])] + "/status.usr", "rb");
			string status = f.read();
			f.close();
			send_reliable(p, "status for " + charfolders[found] + ": " + status + "", 2);
		}
	} else if (parsed[0] == "setstatus" and parsed.length() > 1) {
		p.status = string_replace(get_event_message(), parsed[0] + " ", "", true);
		string[] charfolders = find_directories("chars/*");
		int found = charfolders.find(p.name);
		if (found > -1) {
			write_to(charfolders[found], "status.usr", p.status);
			send_reliable(p, "your status message has been set to " + p.status + "", 2);
		}
	} else if (parsed[0] == "ttschatbuffer")
		send_packet(0, "ttschat " + p.name + " has sent a tts chat on " + get_date() + " at " + get_time() + "", p.x, p.y, p.z, maps[get_map_index(p.map)]);
	else if (parsed[0] == "setvoice" and parsed.length() > 1) {
		p.voice = string_to_number(parsed[1]);
		send_reliable(p, "setgender " + p.gender, 0);
	} else if (parsed[0] == "voicechatbuffer" and parsed.length() > 1) {
		if (string_to_number(parsed[1]) > 100)send_reliable(0, "voicechat " + p.name + " has sent a " + string_to_number(parsed[1]) * 100 + " seconds voice chat on " + get_date() + " at " + get_time() + "", 0);
		else if (string_to_number(parsed[1]) == 100)send_reliable(0, "voicechat " + p.name + " has sent a " + string_to_number(parsed[1]) * 100 + " second voice chat on " + get_date() + " at " + get_time() + "", 0);
		else if (string_to_number(parsed[1]) < 100)send_reliable(0, "voicechat " + p.name + " has sent a " + string_to_number(parsed[1]) + " milliseconds voice chat on " + get_date() + " at " + get_time() + "", 0);
	} else if (parsed[0] == "look" and parsed.length() > 1) {
		if (p.looking != "") {
			send_reliable(p, "stop looking at " + p.looking + " first", 2);
			return;
		}
		if (p.prison == true) {
			send_reliable(p, "You can't do this in prison", 2);
			return;
		}
		int ind = get_player_index_from(parsed[1]);
		if (ind > -1) {
			if (p.sleeping == false) {
				if (parsed[1] == p.name)
					send_reliable(p, "you can't look at yourself", 2);
				else if (players[ind].is_trusted(p) == false and p.is_admin() == false)
					send_reliable(p, "error: " + players[ind].name + " doesn't trust you", 2);
				else if (players[ind].looking == p.name)
					send_reliable(p, "Error: You can't look who is already looking at you, tell him or her to stop looking first", 2);
				else {
					write_to(p.name, "oldx.usr", p.x);
					write_to(p.name, "oldy.usr", p.y);
					write_to(p.name, "oldz.usr", p.z);
					write_to(p.name, "oldmap.usr", p.map);
					p.looking = players[ind].name;
					players[ind].looker = p.name;
					p.looking_on = true;
					send_reliable(p, "lookstart", 0);
					send_packet(6, "play toggleon.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
					send_reliable(p, "now you are looking at " + players[ind].name + "", 2);
					send_reliable(players[ind], "" + p.name + " is now watching you", 2);
				}
			} else send_reliable(p, "you can't look at someone while sleeping", 2);
		} else send_reliable(p, "that player could not be found", 2);
	} else if (parsed[0] == "lookstop" and p.looking != "") {
		int ind = get_player_index_from(p.looking);
		if (ind > -1) {
			players[ind].looker = "";
			send_reliable(p, "lookstop", 0);
			p.looking = "";
			int newx = string_to_number(get_char_val(p.name, "oldx"));
			int newy = string_to_number(get_char_val(p.name, "oldy"));
			int newz = string_to_number(get_char_val(p.name, "oldz"));
			string newmap = get_char_val(p.name, "oldmap");
			if (map_exists(newmap) == false)
				newmap = "main";
			string charfolder = "chars/" + p.name;
			file_delete(charfolder + "/oldx.usr");
			file_delete(charfolder + "/oldy.usr");
			file_delete(charfolder + "/oldz.usr");
			file_delete(charfolder + "/oldmap.usr");
			move_player(p, newmap, newx, newy, newz);
			send_packet(6, "play toggleoff.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			send_reliable(p, "you've stopped looking at " + players[ind].name + "", 2);
			send_reliable(players[ind], "" + p.name + " stopped watching you", 2);
		}
	} else if (parsed[0] == "usetelehouse" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		for (uint i = 0; i < houses.length(); i++) {
			if (houses[i].housemap == parsed[1]) {
				if (!map_exists(houses[i].housemap)) continue;
				send_packet(6, "play teleporter1.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
				move_player(p, houses[i].housemap, 2, 0, 0);
				p.inv_add_item("telehouse", -1);
				return;
			}
		}
		for (uint i = 0; i < apartments.length(); i++) {
			if (apartments[i].housemap == parsed[1]) {
				if (!map_exists(apartments[i].housemap)) continue;
				send_packet(6, "play teleporter1.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
				move_player(p, apartments[i].housemap, 0, 0, 0);
				p.inv_add_item("telehouse", -1);
				return;
			}
		}
		for (uint i = 0; i < tents.length(); i++) {
			if (tents[i].housemap == parsed[1]) {
				if (!map_exists(tents[i].housemap)) continue;
				send_packet(6, "play teleporter1.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
				move_player(p, tents[i].housemap, 5, 0, 0);
				p.inv_add_item("telehouse", -1);
				return;
			}
		}
		p.sendpacket("You haven't any house", 0);
		return;
	} else if (parsed[0] == "usewand" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		} else if (parsed[1] == "shield_unwealder") {
			for (uint i = 0; i < players.length(); i++) {
				if (players[i].pvp == 0 || players[i].is_dead == true || players[i].afk == true) continue;
				if (players[i].name != p.name and players[i].map == p.map and players[i].looking != p.name and p.looking != players[i].name and get_3d_distance(p.x, p.y, p.z, players[i].x, players[i].y, players[i].z) <= 25) {
					send_packet(6, "play starhit.ogg " + players[i].x + " " + players[i].y + " " + players[i].z, players[i].x, players[i].y, players[i].z, maps[get_map_index(players[i].map)]);
					send_packet(6, "play shieldunwield.ogg " + players[i].x + " " + players[i].y + " " + players[i].z, players[i].x, players[i].y, players[i].z, maps[get_map_index(players[i].map)]);
					players[i].shieldshots = 0;
					players[i].shielded = 0;
					players[i].steel_shieldshots = 0;
					players[i].steel_shielded = 0;
					p.inv_add_item("mana", -35);
				}
			}
		} else if (parsed[1] == "life_drain") {
			for (uint i = 0; i < players.length(); i++) {
				if (players[i].pvp == 0 || players[i].is_dead == true || players[i].afk == true) continue;
				if (players[i].name != p.name and players[i].map == p.map and players[i].looking != p.name and p.looking != players[i].name and get_3d_distance(p.x, p.y, p.z, players[i].x, players[i].y, players[i].z) <= 25) {
					if (players[i].health > 5000) {
						send_reliable(p, "error: " + players[i].name + "'s health is less than the half", 2);
						return;
					}
					send_packet(6, "play burn_start.ogg " + players[i].x + " " + players[i].y + " " + players[i].z, players[i].x, players[i].y, players[i].z, maps[get_map_index(players[i].map)]);
					send_packet(6, "play health_healer.ogg " + players[i].x + " " + players[i].y + " " + players[i].z, players[i].x, players[i].y, players[i].z, maps[get_map_index(players[i].map)]);
					players[i].health = 5000;
					p.inv_add_item("mana", -55);
				}
			}
		} else if (parsed[1] == "fore_to_death") {
			send_packet(6, "play burn_start.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			send_packet(6, "play health_healer.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.inv_add_item("mana", -5);
			p.health = 0;
		}
	} else if (parsed[0] == "doorgive" and parsed.length() > 1) {
		string p2 = string_replace(parsed[2], "-", "", true);
		p.inv_add_item(parsed[1], string_to_number(p2));
		if (parsed[1] == "coins")
			servermoney -= string_to_number(parsed[2]);
	} else if (parsed[0] == "doortake" and parsed.length() > 1) {
		string p2 = string_replace(parsed[2], "-", "", true);
		p.inv_add_item(parsed[1], -string_to_number(p2));
		if (parsed[1] == "coins")
			servermoney += string_to_number(parsed[2]);
	} else if (parsed[0] == "travelpointgive" and parsed.length() > 1) {
		string p2 = string_replace(parsed[2], "-", "", true);
		p.inv_add_item(parsed[1], string_to_number(p2));
		if (parsed[1] == "coins")
			servermoney -= string_to_number(parsed[2]);
	} else if (parsed[0] == "travelpointtake" and parsed.length() > 1) {
		string p2 = string_replace(parsed[2], "-", "", true);
		p.inv_add_item(parsed[1], -string_to_number(p2));
		if (parsed[1] == "coins")
			servermoney += string_to_number(parsed[2]);
	} else if (parsed[0] == "int" and parsed.length() > 2)
		iitem(p, parsed[1], parsed[2]);
	else if (parsed[0] == "main_mapmenu" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		if (parsed[1] == "publicmaps") {
			if (p.prison == false) {
				server_menu2 m;
				m.intro = "public maps menu. Press up and down to move between maps and press enter to go to that map";
				m.initial_packet = "publicmapgo";
				file f;
				f.open("pbmaps.svr", "rb");
				string[] lines = string_split(f.read().replace("\r\n", "\n"), "\n");
				f.close();
				if (lines.length() < 1) {
					send_reliable(p, "error", 2);
					return;
				}
				for (uint i = 0; i < lines.length(); i++) {
					int mi = get_map_index(lines[i]);
					if ((mi > -1)) {
						string s = "";
						string s2;
						if (maps[mi].owners.length() > 1) {
							for (uint i = 0; i < maps[mi].owners.length(); i++) {
								if (i == (maps[mi].owners.length() - 1)) s += "and " + maps[mi].owners[i] + ".";
								else s += maps[mi].owners[i] + ", ";
							}
						} else
							for (uint i = 0; i < maps[mi].owners.length(); i++)
								s = maps[mi].owners[i] + ".";
						if (maps[mi].owners.length() > 1) s2 = " " + maps[mi].owners.length() + " owners: ";
						else s2 = " " + maps[mi].owners.length() + " owner: ";
						m.add(maps[mi].name + ", updated " + get_map_update_short(maps[mi].name) + ". " + s2 + " " + s + " " + (maps[mi].litem == 1 ? "You will" : "You won't") + " loos your items when you die in this map. " + (maps[mi].minlevel > 0 ? "Level range: level " + maps[mi].minlevel + " untill " + maps[mi].maxlevel + "." : " ") + " " + (maps[mi].minreinforcement > 0 ? "reinforcement range: reinforcement " + maps[mi].minreinforcement + " untill " + maps[mi].maxreinforcement + "." : " ") + " " + (maps[mi].description != "" ? "" + maps[mi].description + "" : " ") + "", lines[i]);
					}
				}
				m.send(p.peer_id);
			}
		} else if (parsed[1] == "task") {
			if (p.prison == false) {
				server_menu2 m;
				m.intro = "task menu. Press up and down to move between maps and press enter to go to that map";
				m.initial_packet = "taskgo";
				file f;
				f.open("chmaps.svr", "rb");
				string[] lines = string_split(f.read().replace("\r\n", "\n"), "\n");
				f.close();
				if (lines.length() < 1) {
					send_reliable(p, "error", 2);
					return;
				}
				for (uint i = 0; i < lines.length(); i++) {
					int mi = get_map_index(lines[i]);
					if ((mi > -1)) {
						string s = "";
						string s2;
						if (maps[mi].owners.length() > 1) {
							for (uint i = 0; i < maps[mi].owners.length(); i++) {
								if (i == (maps[mi].owners.length() - 1)) s += "and " + maps[mi].owners[i] + ".";
								else s += maps[mi].owners[i] + ", ";
							}
						} else
							for (uint i = 0; i < maps[mi].owners.length(); i++)
								s = maps[mi].owners[i] + ".";
						if (maps[mi].owners.length() > 1) s2 = " " + maps[mi].owners.length() + " owners: ";
						else s2 = " " + maps[mi].owners.length() + " owner: ";
						m.add(maps[mi].name + ", updated " + get_map_update_short(maps[mi].name) + ". Reward: " + maps[mi].finishamount + " " + maps[mi].finishitem + ". " + s2 + " " + s + " " + (maps[mi].litem == 1 ? "You will" : "You won't") + " loos your items when you die in this map. " + (maps[mi].minlevel > 0 ? "Level range: level " + maps[mi].minlevel + " untill " + maps[mi].maxlevel + "." : " ") + " " + (maps[mi].minreinforcement > 0 ? "reinforcement range: reinforcement " + maps[mi].minreinforcement + " untill " + maps[mi].maxreinforcement + "." : " ") + " " + (maps[mi].description != "" ? "" + maps[mi].description + "" : " ") + "", lines[i]);
					}
				}
				m.send(p.peer_id);
			}
		} else if (parsed[1] == "yourmaps") {
			if (p.prison == false) {
				cmenu m;
				m.intro = "your maps menu. Press up and down to move between maps and press enter to go to that map";
				m.initial_packet = "mapgo";
				string[] a = string_split(file_get_contents("chars/" + p.name + "/maps.usr"), "\n");
				if (a.length() < 1) {
					send_reliable(p, "error", 2);
					return;
				}
				for (uint i = 0; i < a.length(); i++) {
					if (string_contains(a[i], "house_of_", 1) == -1 and string_contains(a[i], "beehive_of_", 1) == -1 and string_contains(a[i], "store_of_", 1) == -1 and stringcontains(a[i], "apartment_of", 1) < 0 and stringcontains(a[i], "tent_of", 1) < 0) {
						int mi = get_map_index(a[i]);
						if ((mi > -1))
							m.add(maps[mi].name + ", updated " + get_map_update_short(maps[mi].name) + ". " + s2 + " " + s + " " + (maps[mi].litem == 1 ? "You will" : "You won't") + " loos your items when you die in this map. " + (maps[mi].description != "" ? "" + maps[mi].description + "" : "No description available for this map") + "", a[i]);
					}
				}
				if (m.menuitems.length() < 1) {
					p.sendpacket("You have no maps", 0);
					return;
				}
				m.send(p.peer_id);
			}
		} else if (parsed[1] == "newmap")
			send_reliable(p, "buildnewmap", 0);
	} else if (parsed[0] == "arenamenu" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		if (parsed[1] == "createnewarena") {
			server_menu m;
			m.intro = "select your arena type";
			m.initial_packet = "arenatype";
			m.add("combo arena", "combo");
			m.add("melee arena", "melee");
			m.add("weaponry arena", "weaponry");
			m.add("explosive arena", "explosive");
			m.add("mixed arena", "mixed");
			m.send(p.peer_id);
		} else if (parsed[1] == "joinarena") {
			server_menu m;
			m.intro = "choose an arena";
			m.initial_packet = "choosearena";
			for (uint i = 0; i < arenas.length(); i++) {
				if (arenas[i].started == 0 and arenas[i].length > 1) {
					int amath = arenas[i].length - arenas[i].joined;
					m.add("" + arenas[i].owner + "'s " + arenas[i].type + " arena with a total of " + arenas[i].length + " participators. " + amath + " participators stil left. Fee: " + arenas[i].neededfee + " " + arenas[i].item + ". This arena has a total of " + arenas[i].fee + " " + arenas[i].item + " to give to it's winner", arenas[i].id);
				}
				if (arenas[i].length == 0)
					m.add("" + arenas[i].owner + "'s continuous " + arenas[i].type + " arena", arenas[i].id);
			}
			m.send(p.peer_id);
		}
	} else if (parsed[0] == "arenatype" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		send_serverbox(p.peer_id, 2, -1, 1, -1, "arenalength/" + parsed[1], "how many people can join? enter 0 to be continuous");
	} else if (string_left(parsed[0], 12) == "arenalength/" and parsed.length() > 1) {
		if (parsed[1] == "[cncel]") return;
		double arenalength = string_to_number(parsed[1]);
		parsed = string_split(parsed[0], "/", false);
		if (arenalength < 2 and arenalength != 0) {
			send_reliable(p, "participaters must be more than one person", 2);
			return;
		}
		if (arenalength > players.length() and arenalength != 0) {
			send_reliable(p, "participaters must be less than thee connected players", 2);
			return;
		}
		send_serverbox(p.peer_id, 0, -1, -1, -1, "arenaitem/" + arenalength + "/" + parsed[1], "enter item name. Type noitem if this arena is continuous");
	} else if (string_left(parsed[0], 10) == "arenaitem/" and parsed.length() > 1) {
		if (parsed[1] == "[cncel]") return;
		string arenaitem = parsed[1];
		parsed = string_split(parsed[0], "/", false);
		if (arenaitem == "") {
			send_reliable(p, "unknown item name", 2);
			return;
		}
		send_serverbox(p.peer_id, 2, -1, 1, -1, "arenafee/" + parsed[1] + "/" + parsed[2] + "/" + arenaitem, "enter fee. Type 0 if this arena is continuous");
	} else if (string_left(parsed[0], 9) == "arenafee/" and parsed.length() > 1) {
		if (parsed[1] == "[cncel]") return;
		double arenafee = string_to_number(parsed[1]);
		parsed = string_split(parsed[0], "/", false);
		double arenalength = string_to_number(parsed[1]);
		if (arenafee<1 and arenalength>1) {
			send_reliable(p, "not less than a coin", 2);
			return;
		}
		if (p.inv_item_number(parsed[3]) < arenafee) {
			send_reliable(p, "you haven't " + arenafee + " " + parsed[3] + " to continue", 2);
			return;
		}
		string mapname;
		if (arenalength == 0) mapname = "" + p.name + "'s_continuous_" + parsed[2] + "_arena";
		else if (arenalength > 1) mapname = "" + p.name + "'s_" + parsed[2] + "_arena";
		int maxx = random(20, 200);
		int maxy = random(20, 200);
		int length = string_to_number(parsed[1]);
		directory_create("maps/" + mapname);
		file f;
		f.open("maps/" + mapname + "/!.map", "wb");
		f.write("mapname:" + mapname + "\nminx:0\nmaxx:" + maxx + "\nminy:0\nmaxy:" + maxy + "\nminz:0\nmaxz:10\ntile:0:" + maxx + ":0:" + maxy + ":0:0:grass" + random(2, 10) + "\nlitem:0\nstarting_point:0:" + maxx + ":0:" + maxy + ":0:0\ndeathpoint:0:" + maxx + ":0:" + maxy + ":0:0\nsrc:0:" + maxx + ":0:" + maxy + ":0:10:0:100:birds" + random(2, 103) + ".ogg\nzone:0:" + maxx + ":0:" + maxy + ":0:10:" + mapname + "\nowner:" + p.name + "\npvp:0:" + maxx + ":0:" + maxy + ":0:10:1");
		f.close();
		init_mapsystem();
		string newid = randomstring(6);
		if (arenalength == 0) create_arena(p.name, mapname, parsed[2], 0, 1, arenafee, "", newid);
		else create_arena(p.name, mapname, parsed[2], arenalength, 0, arenafee, parsed[3], newid);
		for (uint i = 0; i < arenas.length(); i++) {
			if (arenas[i].id == newid) {
				int mi = get_map_index(arenas[i].map);
				if ((mi > -1)) {
					if (arenalength == 0) {
						send_reliable(0, "play_s notify_news2.ogg", 6);
						send_reliable(0, "arena " + p.name + " has created a continuous " + arenas[i].type + " Arena. You can join to it by going to the safe zone map and finding the safe zone menu", 0);
						send_reliable(p, "you can type /suicide to go back", 2);
					} else if (arenalength > 0) {
						send_reliable(0, "play_s notify_news2.ogg", 6);
						send_reliable(0, "arena " + p.name + " has created a " + arenas[i].type + " Arena with a total of " + arenas[i].length + " participators. Fee: " + arenas[i].neededfee + " " + parsed[3] + ". You can join to it by going to the safe zone map and finding the safe zone menu", 0);
						send_reliable(p, "you can type /suicide to go back", 2);
					}
					p.inv_add_item(parsed[3], -arenafee);
					arenas[i].fee += arenafee;
					write_to(p.name, "oldx.usr", p.x);
					write_to(p.name, "oldy.usr", p.y);
					write_to(p.name, "oldz.usr", p.z);
					write_to(p.name, "oldmap.usr", p.map);
					write_to(p.name, "oldinv.usr", p.get_inv());
					p.inv.reset();
					send_reliable(p, "invdrop", 0);
					move_player(p, arenas[i].map, random(maps[mi].spminx, maps[mi].spmaxx), random(maps[mi].spminy, maps[mi].spmaxy), random(maps[mi].spminz, maps[mi].spmaxz), true);
					f.open("chars/" + p.name + "/inv.usr", "rb");
					string invtext = f.read();
					f.close();
					f.open("inv_backups/" + p.name + " " + DATE_WEEKDAY_NAME + ", " + DATE_MONTH_NAME + "-" + DATE_DAY + "-" + DATE_YEAR + ", " + TIME_HOUR + " " + TIME_MINUTE + " " + TIME_SECOND + ".usr", "wb");
					f.write(invtext);
					f.close();
					if (arenas[i].length == 0) {
						if (maps[mi].pvp == 1 and maps[mi].pvpminx <= p.x and maps[mi].pvpmaxx >= p.x and maps[mi].pvpminy <= p.y and maps[mi].pvpmaxy >= p.y and maps[mi].pvpminz <= p.z and maps[mi].pvpmaxz >= p.z) {
							if (p.pvp != 1) {
								p.pvp = 1;
								p.pvpd = 1;
							}
						}
					}
					if (arenas[i].length > 1 and p.pvp == 1) {
						p.pvp = 0;
						p.pvpd = 3;
					}
					arenas[i].joined++;
					if (parsed[2] == "combo")
						p.inv.reset();
					else if (parsed[2] == "melee") {
						p.inv_add_item("blake_sword", 1);
						p.inv_add_item("d23machete", 1);
						p.inv_add_item("dagger", 1);
						p.inv_add_item("hammer", 1);
						p.inv_add_item("hook", 1);
						p.inv_add_item("iron_shovel", 1);
						p.inv_add_item("axe", 1);
						p.inv_add_item("axe2", 1);
						p.inv_add_item("knife", 1);
						p.inv_add_item("long_knife", 1);
						p.inv_add_item("machete", 1);
						p.inv_add_item("small_dagger", 1);
						p.inv_add_item("spear", 1);
						p.inv_add_item("sword", 1);
						p.inv_add_item("long_sword", 1);
						p.inv_add_item("short_sword", 1);
						p.inv_add_item("wip", 1);
					} else if (parsed[2] == "weaponry") {
						p.inv_add_item("blake_sword", 1);
						p.inv_add_item("d23machete", 1);
						p.inv_add_item("dagger", 1);
						p.inv_add_item("hammer", 1);
						p.inv_add_item("hook", 1);
						p.inv_add_item("iron_shovel", 1);
						p.inv_add_item("axe", 1);
						p.inv_add_item("axe2", 1);
						p.inv_add_item("knife", 1);
						p.inv_add_item("long_knife", 1);
						p.inv_add_item("machete", 1);
						p.inv_add_item("small_dagger", 1);
						p.inv_add_item("spear", 1);
						p.inv_add_item("sword", 1);
						p.inv_add_item("long_sword", 1);
						p.inv_add_item("short_sword", 1);
						p.inv_add_item("wip", 1);
						p.inv_add_item("a90sniper_rifle", 1);
						p.inv_add_item("ak47assault_rifle", 1);
						p.inv_add_item("ak48", 1);
						p.inv_add_item("arrow_gun", 1);
						p.inv_add_item("bow", 1);
						p.inv_add_item("colt_m9", 1);
						p.inv_add_item("colt_m19", 1);
						p.inv_add_item("e9pistol", 1);
						p.inv_add_item("e20shotgun", 1);
						p.inv_add_item("e235shotgun", 1);
						p.inv_add_item("mpt_special_shotgun", 1);
						p.inv_add_item("mb3shotgun", 1);
						p.inv_add_item("mb5shotgun", 1);
						p.inv_add_item("mp5machinegun", 1);
						p.inv_add_item("famas_g2", 1);
						p.inv_add_item("k222rifle", 1);
						p.inv_add_item("long_bow", 1);
						p.inv_add_item("p3hunting_shotgun", 1);
						p.inv_add_item("taser", 1);
						p.inv_add_item("tiny_mg", 1);
						p.inv_add_item("ar15machinegun", 1);
						p.inv_add_item("barett_m1500sniper_rifle", 1);
						p.inv_add_item("blz5machinegun", 1);
						p.inv_add_item("browning_m2heavy_machinegun", 1);
						p.inv_add_item("chainsaw", 1);
						p.inv_add_item("crossbow", 1);
						p.inv_add_item("fn2000pistol", 1);
						p.inv_add_item("fnm_pistol", 1);
						p.inv_add_item("g36pistol", 1);
						p.inv_add_item("gouse_pistol", 1);
						p.inv_add_item("hk_machinegun", 1);
						p.inv_add_item("lr12pistol", 1);
						p.inv_add_item("m9pistol", 1);
						p.inv_add_item("m10machinegun", 1);
						p.inv_add_item("m16machinegun", 1);
						p.inv_add_item("m125assault_rifle", 1);
						p.inv_add_item("m152minigun", 1);
						p.inv_add_item("m155minigun", 1);
						p.inv_add_item("m560sniper_rifle", 1);
						p.inv_add_item("mg4machinegun", 1);
						p.inv_add_item("mj420machinegun", 1);
						p.inv_add_item("mk_long_machinegun", 1);
						p.inv_add_item("mk52assault_rifle", 1);
						p.inv_add_item("mk215machinegun", 1);
						p.inv_add_item("mkv43machinegun", 1);
						p.inv_add_item("ml7rifle", 1);
						p.inv_add_item("ml15rifle", 1);
						p.inv_add_item("mlk290rifle", 1);
						p.inv_add_item("mlr_assault_rifle", 1);
						p.inv_add_item("mp12machinegun", 1);
						p.inv_add_item("msb530shotgun", 1);
						p.inv_add_item("pcs_handgun", 1);
						p.inv_add_item("rpg_launcher", 1);
						p.inv_add_item("rpg7", 1);
						p.inv_add_item("rocket_launcher", 1);
						p.inv_add_item("nak_nk1000_decimater", 1);
						p.inv_add_item("ruga22revolver", 1);
						p.inv_add_item("s55assault_rifle", 1);
						p.inv_add_item("s110assault_rifle", 1);
						p.inv_add_item("sp5shotgun", 1);
						p.inv_add_item("sp150shotgun", 1);
						p.inv_add_item("stp106_long_barreled_pistol", 1);
						p.inv_add_item("str301machinegun", 1);
						p.inv_add_item("m90machinegun", 1);
						p.inv_add_item("qt_machinegun", 1);
						p.inv_add_item("pst500shotgun", 1);
						p.inv_add_item("sfx12machinegun", 1);
						p.inv_add_item("mb93machinegun", 1);
						p.inv_add_item("stp15rifle", 1);
						p.inv_add_item("sp3heavy_machinegun", 1);
						p.inv_add_item("ak9automatic_machinegun", 1);
						p.inv_add_item("m234minigun", 1);
						p.inv_add_item("missile_launcher", 1);
						p.inv_add_item("m28mini_machinegun", 1);
						p.inv_add_item("b96machinegun", 1);
						p.inv_add_item("kalashnikov_rifle", 1);
						p.inv_add_item("ump45machinegun", 1);
						p.inv_add_item("tac50rifle", 1);
						p.inv_add_item("uzi_machinegun", 1);
						p.inv_add_item("blue_assault_rifle", 1);
						p.inv_add_item("blue_bolt_action_sniper", 1);
						p.inv_add_item("blue_burst_assault_rifle", 1);
						p.inv_add_item("blue_heavy_assault_rifle", 1);
						p.inv_add_item("blue_hunting_rifle", 1);
						p.inv_add_item("blue_infintry_rifle", 1);
						p.inv_add_item("blue_tacticle_shotgun", 1);
						p.inv_add_item("drum_shotgun", 1);
						p.inv_add_item("gold_burst_assault_rifle", 1);
						p.inv_add_item("gold_drum_gun", 1);
						p.inv_add_item("gold_heavy_assault_rifle", 1);
						p.inv_add_item("gold_scar", 1);
						p.inv_add_item("gold_tacticle_shotgun", 1);
						p.inv_add_item("heavy_sniper", 1);
						p.inv_add_item("5.56mm_ammo", 1000);
						p.inv_add_item("7.62mm_ammo", 1000);
						p.inv_add_item("9mm_ammo", 1000);
						p.inv_add_item("12.7mm_ammo", 1000);
						p.inv_add_item("arrow", 1000);
						p.inv_add_item("battery", 1000);
						p.inv_add_item("missile", 1000);
						p.inv_add_item("rocket", 1000);
						p.inv_add_item("rpg", 1000);
						p.inv_add_item("shotgun_shell", 1000);
					} else if (parsed[2] == "explosive") {
						p.inv_add_item("time_bomb", 100);
						p.inv_add_item("grenade", 100);
						p.inv_add_item("turret", 100);
						p.inv_add_item("turret_cartridge", 100);
						p.inv_add_item("turret_battery", 100);
						p.inv_add_item("mine", 100);
						p.inv_add_item("gas_canister", 100);
						p.inv_add_item("censor_bomb", 100);
						p.inv_add_item("snare", 100);
						p.inv_add_item("energogenic_canister", 100);
						p.inv_add_item("energy_reducing_canister", 100);
						p.inv_add_item("thirsting_canister", 100);
						p.inv_add_item("starvogenic_canister", 100);
						p.inv_add_item("pathogenic_canister", 100);
						p.inv_add_item("experience_canister", 100);
					} else if (parsed[2] == "mixed") {
						p.inv_add_item("blake_sword", 1);
						p.inv_add_item("d23machete", 1);
						p.inv_add_item("dagger", 1);
						p.inv_add_item("hammer", 1);
						p.inv_add_item("hook", 1);
						p.inv_add_item("iron_shovel", 1);
						p.inv_add_item("axe", 1);
						p.inv_add_item("axe2", 1);
						p.inv_add_item("knife", 1);
						p.inv_add_item("long_knife", 1);
						p.inv_add_item("machete", 1);
						p.inv_add_item("small_dagger", 1);
						p.inv_add_item("spear", 1);
						p.inv_add_item("sword", 1);
						p.inv_add_item("long_sword", 1);
						p.inv_add_item("short_sword", 1);
						p.inv_add_item("wip", 1);
						p.inv_add_item("a90sniper_rifle", 1);
						p.inv_add_item("ak47assault_rifle", 1);
						p.inv_add_item("ak48", 1);
						p.inv_add_item("arrow_gun", 1);
						p.inv_add_item("bow", 1);
						p.inv_add_item("colt_m9", 1);
						p.inv_add_item("colt_m19", 1);
						p.inv_add_item("e9pistol", 1);
						p.inv_add_item("e20shotgun", 1);
						p.inv_add_item("e235shotgun", 1);
						p.inv_add_item("mpt_special_shotgun", 1);
						p.inv_add_item("mb3shotgun", 1);
						p.inv_add_item("mb5shotgun", 1);
						p.inv_add_item("mp5machinegun", 1);
						p.inv_add_item("famas_g2", 1);
						p.inv_add_item("k222rifle", 1);
						p.inv_add_item("long_bow", 1);
						p.inv_add_item("p3hunting_shotgun", 1);
						p.inv_add_item("taser", 1);
						p.inv_add_item("tiny_mg", 1);
						p.inv_add_item("ar15machinegun", 1);
						p.inv_add_item("barett_m1500sniper_rifle", 1);
						p.inv_add_item("blz5machinegun", 1);
						p.inv_add_item("browning_m2heavy_machinegun", 1);
						p.inv_add_item("chainsaw", 1);
						p.inv_add_item("crossbow", 1);
						p.inv_add_item("fn2000pistol", 1);
						p.inv_add_item("fnm_pistol", 1);
						p.inv_add_item("g36pistol", 1);
						p.inv_add_item("gouse_pistol", 1);
						p.inv_add_item("hk_machinegun", 1);
						p.inv_add_item("lr12pistol", 1);
						p.inv_add_item("m9pistol", 1);
						p.inv_add_item("m10machinegun", 1);
						p.inv_add_item("m16machinegun", 1);
						p.inv_add_item("m125assault_rifle", 1);
						p.inv_add_item("m152minigun", 1);
						p.inv_add_item("m155minigun", 1);
						p.inv_add_item("m560sniper_rifle", 1);
						p.inv_add_item("mg4machinegun", 1);
						p.inv_add_item("mj420machinegun", 1);
						p.inv_add_item("mk_long_machinegun", 1);
						p.inv_add_item("mk52assault_rifle", 1);
						p.inv_add_item("mk215machinegun", 1);
						p.inv_add_item("mkv43machinegun", 1);
						p.inv_add_item("ml7rifle", 1);
						p.inv_add_item("ml15rifle", 1);
						p.inv_add_item("mlk290rifle", 1);
						p.inv_add_item("mlr_assault_rifle", 1);
						p.inv_add_item("mp12machinegun", 1);
						p.inv_add_item("msb530shotgun", 1);
						p.inv_add_item("pcs_handgun", 1);
						p.inv_add_item("rpg_launcher", 1);
						p.inv_add_item("rpg7", 1);
						p.inv_add_item("rocket_launcher", 1);
						p.inv_add_item("nak_nk100_decimater", 1);
						p.inv_add_item("ruga22revolver", 1);
						p.inv_add_item("s55assault_rifle", 1);
						p.inv_add_item("s110assault_rifle", 1);
						p.inv_add_item("sp5shotgun", 1);
						p.inv_add_item("sp150shotgun", 1);
						p.inv_add_item("stp106_long_barreled_pistol", 1);
						p.inv_add_item("str301machinegun", 1);
						p.inv_add_item("m90machinegun", 1);
						p.inv_add_item("qt_machinegun", 1);
						p.inv_add_item("pst500shotgun", 1);
						p.inv_add_item("sfx12machinegun", 1);
						p.inv_add_item("mb93machinegun", 1);
						p.inv_add_item("stp15rifle", 1);
						p.inv_add_item("sp3heavy_machinegun", 1);
						p.inv_add_item("ak9automatic_machinegun", 1);
						p.inv_add_item("tsp_grenade_launcher", 1);
						p.inv_add_item("m234minigun", 1);
						p.inv_add_item("missile_launcher", 1);
						p.inv_add_item("m28mini_machinegun", 1);
						p.inv_add_item("b96machinegun", 1);
						p.inv_add_item("kalashnikov_rifle", 1);
						p.inv_add_item("ump45machinegun", 1);
						p.inv_add_item("tac50rifle", 1);
						p.inv_add_item("uzi_machinegun", 1);
						p.inv_add_item("blue_assault_rifle", 1);
						p.inv_add_item("blue_bolt_action_sniper", 1);
						p.inv_add_item("blue_burst_assault_rifle", 1);
						p.inv_add_item("blue_heavy_assault_rifle", 1);
						p.inv_add_item("blue_hunting_rifle", 1);
						p.inv_add_item("blue_infintry_rifle", 1);
						p.inv_add_item("blue_tacticle_shotgun", 1);
						p.inv_add_item("drum_shotgun", 1);
						p.inv_add_item("gold_burst_assault_rifle", 1);
						p.inv_add_item("gold_drum_gun", 1);
						p.inv_add_item("gold_heavy_assault_rifle", 1);
						p.inv_add_item("gold_scar", 1);
						p.inv_add_item("gold_tacticle_shotgun", 1);
						p.inv_add_item("heavy_sniper", 1);
						p.inv_add_item("5.56mm_ammo", 1000);
						p.inv_add_item("7.62mm_ammo", 1000);
						p.inv_add_item("9mm_ammo", 1000);
						p.inv_add_item("12.7mm_ammo", 1000);
						p.inv_add_item("arrow", 1000);
						p.inv_add_item("battery", 1000);
						p.inv_add_item("missile", 1000);
						p.inv_add_item("rocket", 1000);
						p.inv_add_item("rpg", 1000);
						p.inv_add_item("shotgun_shell", 1000);
						p.inv_add_item("time_bomb", 100);
						p.inv_add_item("grenade", 100);
						p.inv_add_item("turret", 100);
						p.inv_add_item("turret_cartridge", 100);
						p.inv_add_item("turret_battery", 100);
						p.inv_add_item("mine", 100);
						p.inv_add_item("gas_canister", 100);
						p.inv_add_item("censor_bomb", 100);
						p.inv_add_item("snare", 100);
						p.inv_add_item("energogenic_canister", 100);
						p.inv_add_item("energy_reducing_canister", 100);
						p.inv_add_item("thirsting_canister", 100);
						p.inv_add_item("starvogenic_canister", 100);
						p.inv_add_item("pathogenic_canister", 100);
						p.inv_add_item("experience_canister", 100);
					}
					p.bullet_proof_vested = 0;
					p.bullet_proof_vestshots = 0;
					p.armored = 0;
					p.armorshots = 0;
					p.large_armor_plated = 0;
					p.large_armor_plateshots = 0;
					p.shielded = 0;
					p.shieldshots = 0;
					p.steel_shielded = 0;
					p.steel_shieldshots = 0;
					p.hurtlevel = 0;
					p.hurttimer.restart();
					p.healtimer.restart();
					p.poisoned = false;
					p.hurt = false;
					p.cbombplacing = false;
					p.drunk = false;
					if (p.weapon_name != "fists") {
						p.weapon_name = "fists";
						if (p.weapon_ammos > 0)
							p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
						p.firetimer = 180;
						p.weapon_ammos = 0;
						p.weapon_ammo_type = "";
						p.weapon_copasity = 0;
						send_reliable(p, "notrapid", 0);
					}
					p.stunned = true;
					send_reliable(p, "stopmoving", 0);
				}
			}
		}
	} else if (parsed[0] == "choosearena" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		for (uint i = 0; i < arenas.length(); i++) {
			if (parsed[1] == arenas[i].id) {
				if (p.inv_item_number(arenas[i].item) < arenas[i].neededfee) {
					send_reliable(p, "you haven't " + arenas[i].fee + " " + arenas[i].item + " to continue", 2);
					return;
				}
				int mi = get_map_index(arenas[i].map);
				if ((mi > -1)) {
					if (arenas[i].length == 0) {
						send_reliable(0, "play_s arena_join.ogg", 6);
						send_reliable(0, "arena " + p.name + " has joined to " + arenas[i].owner + "'s continuous " + arenas[i].type + " Arena", 0);
						send_reliable(p, "you can type /suicide to go back", 2);
					} else if (arenas[i].length > 0) {
						send_reliable(0, "play_s arena_join.ogg", 6);
						send_reliable(0, "arena " + p.name + " has joined to " + arenas[i].owner + "'s " + arenas[i].type + " Arena and paid " + arenas[i].neededfee + " " + arenas[i].item + " for a total of " + arenas[i].fee + " " + arenas[i].item + "", 0);
						send_reliable(p, "you can type /suicide to go back", 2);
					}
					p.inv_add_item(arenas[i].item, -arenas[i].neededfee);
					arenas[i].fee += arenas[i].neededfee;
					write_to(p.name, "oldx.usr", p.x);
					write_to(p.name, "oldy.usr", p.y);
					write_to(p.name, "oldz.usr", p.z);
					write_to(p.name, "oldmap.usr", p.map);
					write_to(p.name, "oldinv.usr", p.get_inv());
					p.inv.reset();
					send_reliable(p, "invdrop", 0);
					move_player(p, arenas[i].map, random(maps[mi].spminx, maps[mi].spmaxx), random(maps[mi].spminy, maps[mi].spmaxy), random(maps[mi].spminz, maps[mi].spmaxz), true);
					file f;
					f.open("chars/" + p.name + "/inv.usr", "rb");
					string invtext = f.read();
					f.close();
					f.open("inv_backups/" + p.name + " " + DATE_WEEKDAY_NAME + ", " + DATE_MONTH_NAME + "-" + DATE_DAY + "-" + DATE_YEAR + ", " + TIME_HOUR + " " + TIME_MINUTE + " " + TIME_SECOND + ".usr", "wb");
					f.write(invtext);
					f.close();
					if (arenas[i].length == 0) {
						if (maps[mi].pvp == 1 and maps[mi].pvpminx <= p.x and maps[mi].pvpmaxx >= p.x and maps[mi].pvpminy <= p.y and maps[mi].pvpmaxy >= p.y and maps[mi].pvpminz <= p.z and maps[mi].pvpmaxz >= p.z) {
							if (p.pvp != 1) {
								p.pvp = 1;
								p.pvpd = 1;
							}
						}
					}
					if (arenas[i].length > 1 and p.pvp == 1) {
						p.pvp = 0;
						p.pvpd = 3;
					}
					arenas[i].joined++;
					if (arenas[i].type == "combo")
						p.inv.reset();
					else if (arenas[i].type == "melee") {
						p.inv_add_item("blake_sword", 1);
						p.inv_add_item("d23machete", 1);
						p.inv_add_item("dagger", 1);
						p.inv_add_item("hammer", 1);
						p.inv_add_item("hook", 1);
						p.inv_add_item("iron_shovel", 1);
						p.inv_add_item("axe", 1);
						p.inv_add_item("axe2", 1);
						p.inv_add_item("knife", 1);
						p.inv_add_item("long_knife", 1);
						p.inv_add_item("machete", 1);
						p.inv_add_item("small_dagger", 1);
						p.inv_add_item("spear", 1);
						p.inv_add_item("sword", 1);
						p.inv_add_item("long_sword", 1);
						p.inv_add_item("short_sword", 1);
						p.inv_add_item("wip", 1);
					} else if (arenas[i].type == "weaponry") {
						p.inv_add_item("blake_sword", 1);
						p.inv_add_item("d23machete", 1);
						p.inv_add_item("dagger", 1);
						p.inv_add_item("hammer", 1);
						p.inv_add_item("hook", 1);
						p.inv_add_item("iron_shovel", 1);
						p.inv_add_item("axe", 1);
						p.inv_add_item("axe2", 1);
						p.inv_add_item("knife", 1);
						p.inv_add_item("long_knife", 1);
						p.inv_add_item("machete", 1);
						p.inv_add_item("small_dagger", 1);
						p.inv_add_item("spear", 1);
						p.inv_add_item("sword", 1);
						p.inv_add_item("long_sword", 1);
						p.inv_add_item("short_sword", 1);
						p.inv_add_item("wip", 1);
						p.inv_add_item("a90sniper_rifle", 1);
						p.inv_add_item("ak47assault_rifle", 1);
						p.inv_add_item("ak48", 1);
						p.inv_add_item("arrow_gun", 1);
						p.inv_add_item("bow", 1);
						p.inv_add_item("colt_m9", 1);
						p.inv_add_item("colt_m19", 1);
						p.inv_add_item("e9pistol", 1);
						p.inv_add_item("e20shotgun", 1);
						p.inv_add_item("e235shotgun", 1);
						p.inv_add_item("mpt_special_shotgun", 1);
						p.inv_add_item("mb3shotgun", 1);
						p.inv_add_item("mb5shotgun", 1);
						p.inv_add_item("mp5machinegun", 1);
						p.inv_add_item("famas_g2", 1);
						p.inv_add_item("k222rifle", 1);
						p.inv_add_item("long_bow", 1);
						p.inv_add_item("p3hunting_shotgun", 1);
						p.inv_add_item("taser", 1);
						p.inv_add_item("tiny_mg", 1);
						p.inv_add_item("ar15machinegun", 1);
						p.inv_add_item("barett_m1500sniper_rifle", 1);
						p.inv_add_item("blz5machinegun", 1);
						p.inv_add_item("browning_m2heavy_machinegun", 1);
						p.inv_add_item("chainsaw", 1);
						p.inv_add_item("crossbow", 1);
						p.inv_add_item("fn2000pistol", 1);
						p.inv_add_item("fnm_pistol", 1);
						p.inv_add_item("g36pistol", 1);
						p.inv_add_item("gouse_pistol", 1);
						p.inv_add_item("hk_machinegun", 1);
						p.inv_add_item("lr12pistol", 1);
						p.inv_add_item("m9pistol", 1);
						p.inv_add_item("m10machinegun", 1);
						p.inv_add_item("m16machinegun", 1);
						p.inv_add_item("m125assault_rifle", 1);
						p.inv_add_item("m152minigun", 1);
						p.inv_add_item("m155minigun", 1);
						p.inv_add_item("m560sniper_rifle", 1);
						p.inv_add_item("mg4machinegun", 1);
						p.inv_add_item("mj420machinegun", 1);
						p.inv_add_item("mk_long_machinegun", 1);
						p.inv_add_item("mk52assault_rifle", 1);
						p.inv_add_item("mk215machinegun", 1);
						p.inv_add_item("mkv43machinegun", 1);
						p.inv_add_item("ml7rifle", 1);
						p.inv_add_item("ml15rifle", 1);
						p.inv_add_item("mlk290rifle", 1);
						p.inv_add_item("mlr_assault_rifle", 1);
						p.inv_add_item("mp12machinegun", 1);
						p.inv_add_item("msb530shotgun", 1);
						p.inv_add_item("pcs_handgun", 1);
						p.inv_add_item("rpg_launcher", 1);
						p.inv_add_item("rpg7", 1);
						p.inv_add_item("rocket_launcher", 1);
						p.inv_add_item("nak_nk100_decimater", 1);
						p.inv_add_item("ruga22revolver", 1);
						p.inv_add_item("s55assault_rifle", 1);
						p.inv_add_item("s110assault_rifle", 1);
						p.inv_add_item("sp5shotgun", 1);
						p.inv_add_item("sp150shotgun", 1);
						p.inv_add_item("stp106_long_barreled_pistol", 1);
						p.inv_add_item("str301machinegun", 1);
						p.inv_add_item("m90machinegun", 1);
						p.inv_add_item("qt_machinegun", 1);
						p.inv_add_item("pst500shotgun", 1);
						p.inv_add_item("sfx12machinegun", 1);
						p.inv_add_item("mb93machinegun", 1);
						p.inv_add_item("stp15rifle", 1);
						p.inv_add_item("sp3heavy_machinegun", 1);
						p.inv_add_item("ak9automatic_machinegun", 1);
						p.inv_add_item("m234minigun", 1);
						p.inv_add_item("missile_launcher", 1);
						p.inv_add_item("m28mini_machinegun", 1);
						p.inv_add_item("b96machinegun", 1);
						p.inv_add_item("kalashnikov_rifle", 1);
						p.inv_add_item("ump45machinegun", 1);
						p.inv_add_item("tac50rifle", 1);
						p.inv_add_item("uzi_machinegun", 1);
						p.inv_add_item("blue_assault_rifle", 1);
						p.inv_add_item("blue_bolt_action_sniper", 1);
						p.inv_add_item("blue_burst_assault_rifle", 1);
						p.inv_add_item("blue_heavy_assault_rifle", 1);
						p.inv_add_item("blue_hunting_rifle", 1);
						p.inv_add_item("blue_infintry_rifle", 1);
						p.inv_add_item("blue_tacticle_shotgun", 1);
						p.inv_add_item("drum_shotgun", 1);
						p.inv_add_item("gold_burst_assault_rifle", 1);
						p.inv_add_item("gold_drum_gun", 1);
						p.inv_add_item("gold_heavy_assault_rifle", 1);
						p.inv_add_item("gold_scar", 1);
						p.inv_add_item("gold_tacticle_shotgun", 1);
						p.inv_add_item("heavy_sniper", 1);
						p.inv_add_item("5.56mm_ammo", 1000);
						p.inv_add_item("7.62mm_ammo", 1000);
						p.inv_add_item("9mm_ammo", 1000);
						p.inv_add_item("12.7mm_ammo", 1000);
						p.inv_add_item("arrow", 1000);
						p.inv_add_item("battery", 1000);
						p.inv_add_item("missile", 1000);
						p.inv_add_item("rocket", 1000);
						p.inv_add_item("rpg", 1000);
						p.inv_add_item("shotgun_shell", 1000);
					} else if (arenas[i].type == "explosive") {
						p.inv_add_item("time_bomb", 100);
						p.inv_add_item("grenade", 100);
						p.inv_add_item("turret", 100);
						p.inv_add_item("turret_cartridge", 100);
						p.inv_add_item("turret_battery", 100);
						p.inv_add_item("mine", 100);
						p.inv_add_item("gas_canister", 100);
						p.inv_add_item("censor_bomb", 100);
						p.inv_add_item("snare", 100);
						p.inv_add_item("energogenic_canister", 100);
						p.inv_add_item("energy_reducing_canister", 100);
						p.inv_add_item("thirsting_canister", 100);
						p.inv_add_item("starvogenic_canister", 100);
						p.inv_add_item("pathogenic_canister", 100);
						p.inv_add_item("experience_canister", 100);
					} else if (arenas[i].type == "mixed") {
						p.inv_add_item("blake_sword", 1);
						p.inv_add_item("d23machete", 1);
						p.inv_add_item("dagger", 1);
						p.inv_add_item("hammer", 1);
						p.inv_add_item("hook", 1);
						p.inv_add_item("iron_shovel", 1);
						p.inv_add_item("axe", 1);
						p.inv_add_item("axe2", 1);
						p.inv_add_item("knife", 1);
						p.inv_add_item("long_knife", 1);
						p.inv_add_item("machete", 1);
						p.inv_add_item("small_dagger", 1);
						p.inv_add_item("spear", 1);
						p.inv_add_item("sword", 1);
						p.inv_add_item("long_sword", 1);
						p.inv_add_item("short_sword", 1);
						p.inv_add_item("wip", 1);
						p.inv_add_item("a90sniper_rifle", 1);
						p.inv_add_item("ak47assault_rifle", 1);
						p.inv_add_item("ak48", 1);
						p.inv_add_item("arrow_gun", 1);
						p.inv_add_item("bow", 1);
						p.inv_add_item("colt_m9", 1);
						p.inv_add_item("colt_m19", 1);
						p.inv_add_item("e9pistol", 1);
						p.inv_add_item("e20shotgun", 1);
						p.inv_add_item("e235shotgun", 1);
						p.inv_add_item("mpt_special_shotgun", 1);
						p.inv_add_item("mb3shotgun", 1);
						p.inv_add_item("mb5shotgun", 1);
						p.inv_add_item("mp5machinegun", 1);
						p.inv_add_item("famas_g2", 1);
						p.inv_add_item("k222rifle", 1);
						p.inv_add_item("long_bow", 1);
						p.inv_add_item("p3hunting_shotgun", 1);
						p.inv_add_item("taser", 1);
						p.inv_add_item("tiny_mg", 1);
						p.inv_add_item("ar15machinegun", 1);
						p.inv_add_item("barett_m1500sniper_rifle", 1);
						p.inv_add_item("blz5machinegun", 1);
						p.inv_add_item("browning_m2heavy_machinegun", 1);
						p.inv_add_item("chainsaw", 1);
						p.inv_add_item("crossbow", 1);
						p.inv_add_item("fn2000pistol", 1);
						p.inv_add_item("fnm_pistol", 1);
						p.inv_add_item("g36pistol", 1);
						p.inv_add_item("gouse_pistol", 1);
						p.inv_add_item("hk_machinegun", 1);
						p.inv_add_item("lr12pistol", 1);
						p.inv_add_item("m9pistol", 1);
						p.inv_add_item("m10machinegun", 1);
						p.inv_add_item("m16machinegun", 1);
						p.inv_add_item("m125assault_rifle", 1);
						p.inv_add_item("m152minigun", 1);
						p.inv_add_item("m155minigun", 1);
						p.inv_add_item("m560sniper_rifle", 1);
						p.inv_add_item("mg4machinegun", 1);
						p.inv_add_item("mj420machinegun", 1);
						p.inv_add_item("mk_long_machinegun", 1);
						p.inv_add_item("mk52assault_rifle", 1);
						p.inv_add_item("mk215machinegun", 1);
						p.inv_add_item("mkv43machinegun", 1);
						p.inv_add_item("ml7rifle", 1);
						p.inv_add_item("ml15rifle", 1);
						p.inv_add_item("mlk290rifle", 1);
						p.inv_add_item("mlr_assault_rifle", 1);
						p.inv_add_item("mp12machinegun", 1);
						p.inv_add_item("msb530shotgun", 1);
						p.inv_add_item("pcs_handgun", 1);
						p.inv_add_item("rpg_launcher", 1);
						p.inv_add_item("rpg7", 1);
						p.inv_add_item("rocket_launcher", 1);
						p.inv_add_item("nak_nk100_decimater", 1);
						p.inv_add_item("ruga22revolver", 1);
						p.inv_add_item("s55assault_rifle", 1);
						p.inv_add_item("s110assault_rifle", 1);
						p.inv_add_item("sp5shotgun", 1);
						p.inv_add_item("sp150shotgun", 1);
						p.inv_add_item("stp106_long_barreled_pistol", 1);
						p.inv_add_item("str301machinegun", 1);
						p.inv_add_item("m90machinegun", 1);
						p.inv_add_item("qt_machinegun", 1);
						p.inv_add_item("pst500shotgun", 1);
						p.inv_add_item("sfx12machinegun", 1);
						p.inv_add_item("mb93machinegun", 1);
						p.inv_add_item("stp15rifle", 1);
						p.inv_add_item("sp3heavy_machinegun", 1);
						p.inv_add_item("ak9automatic_machinegun", 1);
						p.inv_add_item("tsp_grenade_launcher", 1);
						p.inv_add_item("m234minigun", 1);
						p.inv_add_item("missile_launcher", 1);
						p.inv_add_item("m28mini_machinegun", 1);
						p.inv_add_item("b96machinegun", 1);
						p.inv_add_item("kalashnikov_rifle", 1);
						p.inv_add_item("ump45machinegun", 1);
						p.inv_add_item("tac50rifle", 1);
						p.inv_add_item("uzi_machinegun", 1);
						p.inv_add_item("blue_assault_rifle", 1);
						p.inv_add_item("blue_bolt_action_sniper", 1);
						p.inv_add_item("blue_burst_assault_rifle", 1);
						p.inv_add_item("blue_heavy_assault_rifle", 1);
						p.inv_add_item("blue_hunting_rifle", 1);
						p.inv_add_item("blue_infintry_rifle", 1);
						p.inv_add_item("blue_tacticle_shotgun", 1);
						p.inv_add_item("drum_shotgun", 1);
						p.inv_add_item("gold_burst_assault_rifle", 1);
						p.inv_add_item("gold_drum_gun", 1);
						p.inv_add_item("gold_heavy_assault_rifle", 1);
						p.inv_add_item("gold_scar", 1);
						p.inv_add_item("gold_tacticle_shotgun", 1);
						p.inv_add_item("heavy_sniper", 1);
						p.inv_add_item("5.56mm_ammo", 1000);
						p.inv_add_item("7.62mm_ammo", 1000);
						p.inv_add_item("9mm_ammo", 1000);
						p.inv_add_item("12.7mm_ammo", 1000);
						p.inv_add_item("arrow", 1000);
						p.inv_add_item("battery", 1000);
						p.inv_add_item("missile", 1000);
						p.inv_add_item("rocket", 1000);
						p.inv_add_item("rpg", 1000);
						p.inv_add_item("shotgun_shell", 1000);
						p.inv_add_item("time_bomb", 100);
						p.inv_add_item("grenade", 100);
						p.inv_add_item("turret", 100);
						p.inv_add_item("turret_cartridge", 100);
						p.inv_add_item("turret_battery", 100);
						p.inv_add_item("mine", 100);
						p.inv_add_item("gas_canister", 100);
						p.inv_add_item("censor_bomb", 100);
						p.inv_add_item("snare", 100);
						p.inv_add_item("energogenic_canister", 100);
						p.inv_add_item("energy_reducing_canister", 100);
						p.inv_add_item("thirsting_canister", 100);
						p.inv_add_item("starvogenic_canister", 100);
						p.inv_add_item("pathogenic_canister", 100);
						p.inv_add_item("experience_canister", 100);
					}
					p.bullet_proof_vested = 0;
					p.bullet_proof_vestshots = 0;
					p.armored = 0;
					p.armorshots = 0;
					p.large_armor_plated = 0;
					p.large_armor_plateshots = 0;
					p.shielded = 0;
					p.shieldshots = 0;
					p.steel_shielded = 0;
					p.steel_shieldshots = 0;
					p.hurtlevel = 0;
					p.hurttimer.restart();
					p.healtimer.restart();
					p.poisoned = false;
					p.hurt = false;
					p.cbombplacing = false;
					p.drunk = false;
					if (p.weapon_name != "fists") {
						p.weapon_name = "fists";
						if (p.weapon_ammos > 0)
							p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
						p.firetimer = 150;
						p.weapon_ammos = 0;
						p.weapon_ammo_type = "";
						p.weapon_copasity = 0;
						send_reliable(p, "notrapid", 0);
					}
					p.stunned = true;
					send_reliable(p, "stopmoving", 0);
				}
			}
		}
	} else if (parsed[0] == "cpdata" and parsed.length() > 1) {
		p.cp = true;
		p.cx = string_to_number(parsed[1]);
		p.cy = string_to_number(parsed[2]);
		p.cz = string_to_number(parsed[3]);
		p.cmap = parsed[4];
	} else if (parsed[0] == "espionage_cameracontroler" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		for (uint i = 0; i < espionage_cameras.length(); i++) {
			if (espionage_cameras[i].id == parsed[1] and espionage_cameras[i].owner.name == p.name)
				espionage_cameras[i].look();
		}
	} else if (parsed[0] == "rremote1" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		if (parsed[1] == "player") {
			string m;
			string[] pls = nearest_player_sorted_arrayrobot(p);
			for (uint i = 0; i < pls.length(); i++)
				m += pls[i] + ":" + pls[i] + "[]";
			robotplayerselect(p.rid, m);
		} else if (parsed[1] == "action") {
			server_menu m;
			m.intro = "what would you like me to do?";
			m.initial_packet = "rremote2";
			m.add("fire my cannon", "cannon");
			m.add("fire my laser", "laser");
			m.add("fire my machine gun", "macgun");
			m.add("fire my second machine gun", "macgun2");
			m.add("explode!", "explode");
			m.send(e.peer_id);
		} else if (parsed[1] == "stats")
			send_reliable(p, "robot " + robotstats(p.rid), 0);
	} else if (parsed[0] == "rremote2" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		robotaction(p.rid, parsed[1]);
	} else if (parsed[0] == "bid" and parsed.length() >= 2) {
		if (auction::doing == false) {
			send_reliable(p, "auctions Sorry: no auction in progress.", 0);
			return;
		}
		if (p.prison == true) {
			send_reliable(p, "You can't do this in prison", 2);
			return;
		}
		auction::make_bid(p, stn(parsed[1]));
		return;
	} else if (parsed[0] == "desc" && parsed.length() == 2)
		send_reliable(p.peer_id, get_item_descryption(parsed[1]), 0);
	else if (parsed[0] == "nickname" and parsed.length() > 1) {
		if (p.nicktimer.elapsed >= 3600000 or p.dev == true) {
			p.nicktimer.restart();
			string nick = string_replace(get_event_message(), "nickname ", "", true);
			if ((string_contains(string_to_lower_case(nick), "kannadiga", 1) > -1 or string_contains(string_to_lower_case(nick), "admin", 1) > -1 or string_contains(string_to_lower_case(nick), "administrator", 1) > -1 or string_contains(string_to_lower_case(nick), "manager", 1) > -1 or string_contains(string_to_lower_case(nick), "dev", 1) > -1 or string_contains(string_to_lower_case(nick), "developer", 1) > -1 or string_contains(string_to_lower_case(nick), "%n", 1) > -1 or directory_exists("chars/" + nick) and nick != p.name) and !p.is_admin())
				send_reliable(p, "deception and impersonation are against the rules! You can not do that!", 2);
			else {
				send_reliable(0, p.nickname + " has changed their nickname to " + nick, 2);
				p.nickname = nick;
				on_web({"player"});
				scd(p);
			}
		} else {
			send_reliable(p, "Sorry, you can't change your nickname yet", 2);
			return;
		}
	} else if (parsed[0] == "invdrop") {
		if (p.prison == true or p.afk) {
			send_reliable(p, "you can't do this write now", 2);
			return;
		}
		if (p.inv.get_size() == 0) {
			send_reliable(p, "you cant drop your empty inventory", 2);
			return;
		}
		int thas = p.inv_item_number("teleporter");
		p.inv_add_item("teleporter", -thas);
		int tdhas = p.inv_item_number("tlp_device");
		p.inv_add_item("tlp_device", -tdhas);
		//int rhas=p.inv_item_number("rocket_launcher");
		//p.inv_add_item("rocket_launcher",-rhas);
		//int nakhas=p.inv_item_number("nak_nk100_decimater");//
		//p.inv_add_item("nak_nk100_decimater",-nakhas);
		int shas = p.inv_item_number("safe_card");
		p.inv_add_item("safe_card", -shas);
		int hbhas = p.inv_item_number("health_box");
		p.inv_add_item("health_box", -hbhas);
		int ebhas = p.inv_item_number("energy_pill");
		p.inv_add_item("energy_pill", -ebhas);
		int nhas = p.inv_item_number("nuclear_bomb");
		p.inv_add_item("nuclear_bomb", -nhas);
		int smallnhas = p.inv_item_number("small_nuclear_bomb");
		p.inv_add_item("small_nuclear_bomb", -smallnhas);
		int largenhas = p.inv_item_number("large_nuclear_bomb");
		p.inv_add_item("large_nuclear_bomb", -largenhas);
		int laphas = p.inv_item_number("large_armor_plate");
		p.inv_add_item("large_armor_plate", -laphas);
		int mdhas = p.inv_item_number("meteorite_defuser");
		p.inv_add_item("meteorite_defuser", -mdhas);
		int cphas = p.inv_item_number("creature_protector");
		p.inv_add_item("creature_protector", -cphas);
		int chas = p.inv_item_number("credit");
		p.inv_add_item("credit", -chas);
		int mrhas = p.inv_item_number("marriage_ring");
		p.inv_add_item("marriage_ring", -mrhas);
		int pghas = p.inv_item_number("paid_gift");
		p.inv_add_item("paid_gift", -pghas);
		int qtfdhas = p.inv_item_number("quick_thirst_fix_drug");
		p.inv_add_item("quick_thirst_fix_drug", -qtfdhas);
		int qhfshas = p.inv_item_number("quick_hunger_fix_snack");
		p.inv_add_item("quick_hunger_fix_snack", -qhfshas);
		int xpptnhas = p.inv_item_number("xp_potion");
		p.inv_add_item("xp_potion", -xpptnhas);
		int armorhas = p.inv_item_number("armor");
		p.inv_add_item("armor", -armorhas);
		if (is_trashcan(p.x, p.y, p.z, maps[get_map_index(p.map)]) == false) {
			string cid = randomstring(5);
			new_corpse(p.get_inv2(), cid);
			spawn_timeitem(p.x, p.y, p.z, p.map, "bag_of_" + p.name + "_" + cid);
		} else
			send_packet(6, "play gethammock.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
		p.inv.reset();
		send_reliable(p, "invdrop", 0);
		p.inv_add_item("teleporter", thas);
		//p.inv_add_item("rocket_launcher",rhas);
		//p.inv_add_item("nak_nk1000_decimater",nakhas);
		p.inv_add_item("tlp_device", tdhas);
		p.inv_add_item("nuclear_bomb", nhas);
		p.inv_add_item("small_nuclear_bomb", smallnhas);
		p.inv_add_item("large_nuclear_bomb", largenhas);
		p.inv_add_item("large_armor_plate", laphas);
		p.inv_add_item("meteorite_defuser", mdhas);
		p.inv_add_item("creature_protector", cphas);
		p.inv_add_item("safe_card", shas);
		p.inv_add_item("health_box", hbhas);
		p.inv_add_item("energy_pill", ebhas);
		p.inv_add_item("credit", chas);
		p.inv_add_item("paid_gift", pghas);
		p.inv_add_item("marriage_ring", mrhas);
		p.inv_add_item("quick_thirst_fix_drug", qtfdhas);
		p.inv_add_item("quick_hunger_fix_snack", qhfshas);
		p.inv_add_item("xp_potion", xpptnhas);
		p.inv_add_item("armor", armorhas);
	} else if (parsed[0] == "ping")
		send_reliable(p, "pong", 0);
	else if (parsed[0] == "acoins")
		p.inv_add_item("coins", string_to_number(parsed[1]));
	else if (parsed[0] == "o1")
		p.readolmsg = 1;
	else if (parsed[0] == "o0")
		p.readolmsg = 0;
	else if (parsed[0] == "delmap" and parsed.length() > 1) {
		string answer = parsed[1];
		if (answer == "back" or answer == "no") {
			send_reliable(p, "Canceled", 0);
			return;
		}
		file f;
		if (map_exists(p.map) == false) {
			send_reliable(p, "Uh, can't delete a map that doesn't exist...", 0);
			return;
		}
		int mapindex = get_map_index(p.map);
		if (mapindex > -1) {
			for (uint i = 0; i < maps[mapindex].owners.length(); i++) {
				if (maps[mapindex].owners.find(p.name) > -1 or maps[mapindex].owners.find(p.partner) > -1 or p.is_admin()) {
					f.open("chars/" + maps[mapindex].owners[i] + "/maps.usr", "rb");
					string mdata = f.read().replace("\r\n", "\n");
					f.close();
					string[] mapdata = string_split(mdata, "\n");
					int something = mapdata.find(p.map);
					if (something > -1) {
						mapdata.remove_at(something);
						file_put_contents("chars/" + maps[mapindex].owners[i] + "/maps.usr", linear(mapdata), 250);
					}
					f.open("pbmaps.svr", "rb");
					string mdata2 = f.read().replace("\r\n", "\n");
					f.close();
					string[] mapdata2 = string_split(mdata2, "\n");
					int something2 = mapdata2.find(p.map);
					if (something2 > -1) {
						mapdata2.remove_at(something2);
						file_put_contents("pbmaps.svr", linear(mapdata2), 250);
					}
					string pmap = p.map;
					bool s = remove_map(p.map);
					send_packet(6, "play mapdelete.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
					send_reliable(p, "map " + pmap + " " + (s ? "successfully deleted" : "could not be deleted"), 2);
				}
				return;
			}
		}
	} else if (parsed[0] == "drop" and parsed.length() >= 3) {
		double amount = string_to_number(parsed[1]);
		if (amount > p.inv_item_number(parsed[2]) or amount < 0) {
			send_reliable(p, "You don't have that many", 2);
			return;
		}
		if (is_trashcan(p.x, p.y, p.z, maps[get_map_index(p.map)])) {
			p.inv_add_item(parsed[2], -amount);
			send_packet(6, "play wood6fall.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			send_reliable(p, "you trashed " + parsed[1] + parsed[2] + " into the trashcan!", 0);
			return;
		}
		string[] a = string_split(file_get_contents("notadg.svr").replace("\r\n", "\n"), "\n");
		int something = a.find(parsed[2]);
		if (something > -1) {
			send_reliable(p, "You can't delete " + parsed[2] + "", 2);
			return;
		}
		if (parsed[2] == "locker") {
			if (can_use_item_at(p.x, p.y, p.z, maps[get_map_index(p.map)], parsed[2]) == false) {
				send_reliable(p, "you can't put your " + parsed[2] + " here", 2);
				return;
			}
			if (in_beehive(p) > -1) {
				send_reliable(p, "you can't place this locker inside a beehive", 0);
				return;
			}
			if (in_playerstore(p) > -1) {
				send_reliable(p, "you can't place this locker inside a store", 0);
				return;
			}
			if (is_safe(p.x, p.y, p.z, maps[get_map_index(p.map)]) == true and in_house(p) < 0) {
				send_reliable(p, "you can't put your locker in safe places", 0);
				return;
			}
			if (is_travelpoint(p.x, p.y, p.z, maps[get_map_index(p.map)])) {
				send_reliable(p, "Building " + parsed[2] + "'s on travelpoints doesn't works!", 2);
				return;
			}
			if (get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "air" or get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "") {
				send_reliable(p, "can't place " + parsed[2] + "'s in the air", 0);
				return;
			}
			if (p.is_admin() == false) {
				string charfolder = "chars/" + p.name;
				string[] a = string_split(file_get_contents("pbmaps.svr").replace("\r\n", "\n"), "\n");
				string[] a2 = string_split(file_get_contents(charfolder + "/maps.usr").replace("\r\n", "\n"), "\n");
				string[] a3 = string_split(file_get_contents("chmaps.svr").replace("\r\n", "\n"), "\n");
				int something = a.find(p.map);
				int something2 = a2.find(p.map);
				int something3 = a3.find(p.map);
				if (something > -1 or something3 > -1) {
					send_reliable(p, "you can't put this in your map", 2);
					return;
				}
			}
			for (uint i = 0; i < lockers.length(); i++) {
				if (get_locker_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) > -1) {
					send_reliable(p, "there's a locker here", 0);
					return;
				}
			}
			send_packet(6, "playpavap " + get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) + "fall.ogg " + p.x + " " + p.y + " " + p.z + " 0 0 200", p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.build_locker();
			p.inv_add_item("locker", -1);
		} else if (parsed[2] == "fridge") {
			if (can_use_item_at(p.x, p.y, p.z, maps[get_map_index(p.map)], parsed[2]) == false) {
				send_reliable(p, "you can't put your " + parsed[2] + " here", 2);
				return;
			}
			if (in_beehive(p) > -1) {
				send_reliable(p, "you can't place this fridge inside a beehive", 0);
				return;
			}
			if (is_safe(p.x, p.y, p.z, maps[get_map_index(p.map)]) == true and in_house(p) < 0) {
				send_reliable(p, "you can't put your fridge in safe places", 0);
				return;
			}
			if (is_travelpoint(p.x, p.y, p.z, maps[get_map_index(p.map)])) {
				send_reliable(p, "Building " + parsed[2] + "'s on travelpoints doesn't works!", 2);
				return;
			}
			if (get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "air" or get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "") {
				send_reliable(p, "can't place " + parsed[2] + "'s in the air", 0);
				return;
			}
			if (p.is_admin() == false) {
				string charfolder = "chars/" + p.name;
				string[] a = string_split(file_get_contents("pbmaps.svr").replace("\r\n", "\n"), "\n");
				string[] a2 = string_split(file_get_contents(charfolder + "/maps.usr").replace("\r\n", "\n"), "\n");
				string[] a3 = string_split(file_get_contents("chmaps.svr").replace("\r\n", "\n"), "\n");
				int something = a.find(p.map);
				int something2 = a2.find(p.map);
				int something3 = a3.find(p.map);
				if (something > -1 or something3 > -1) {
					send_reliable(p, "you can't put this in your map", 2);
					return;
				}
			}
			for (uint i = 0; i < fridges.length(); i++) {
				if (get_fridge_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) > -1) {
					send_reliable(p, "there's a fridge here", 0);
					return;
				}
			}
			send_packet(6, "playpavap " + get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) + "fall.ogg " + p.x + " " + p.y + " " + p.z + " 0 0 200", p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.build_fridge();
			p.inv_add_item("fridge", -1);
		} else if (parsed[2] == "golden_gate_house") {
			if (can_use_item_at(p.x, p.y, p.z, maps[get_map_index(p.map)], parsed[2]) == false) {
				send_reliable(p, "you can't put your " + parsed[2] + " here", 2);
				return;
			}
			string err = house_buildable(p);
			if (err != "") {
				p.sendpacket(err, 0);
				return;
			}
			string mapname = "house_of_" + p.name + "";
			if (map_exists(mapname)) {
				send_reliable(p, "you already have a house", 0);
				return;
			}
			if (in_house(p) > -1) {
				send_reliable(p, "you can't put this house inside another one", 0);
				return;
			}
			if (in_beehive(p) > -1) {
				send_reliable(p, "you can't put this house inside a beehive", 0);
				return;
			}
			if (in_playerstore(p) > -1) {
				send_reliable(p, "you can't put your house inside a store", 0);
				return;
			}
			if (p.is_admin() == false) {
				string charfolder = "chars/" + p.name;
				string[] a = string_split(file_get_contents("pbmaps.svr").replace("\r\n", "\n"), "\n");
				string[] a2 = string_split(file_get_contents(charfolder + "/maps.usr").replace("\r\n", "\n"), "\n");
				string[] a3 = string_split(file_get_contents("chmaps.svr").replace("\r\n", "\n"), "\n");
				int something = a.find(p.map);
				int something2 = a2.find(p.map);
				int something3 = a3.find(p.map);
				if (something > -1 or something2 > -1 or something3 > -1) {
					send_reliable(p, "you can't put this in your map", 2);
					return;
				}
			}
			if (is_travelpoint(p.x, p.y, p.z, maps[get_map_index(p.map)])) {
				send_reliable(p, "Building " + parsed[2] + "'s on travelpoints doesn't works!", 2);
				return;
			}
			if (get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "air" or get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "") {
				send_reliable(p, "can't place " + parsed[2] + "'s in the air", 0);
				return;
			}
			for (uint i = 0; i < houses.length(); i++) {
				if (houses[i].x == p.x and houses[i].y == p.y and houses[i].z == p.z and houses[i].map == p.map) {
					send_reliable(p, "there's a house here", 0);
					return;
				}
			}
			directory_create("maps/" + mapname);
			file f;
			f.open("maps/" + mapname + "/!.map", "wb");
			f.write(houses::mapget(houses::hconex, mapname, p.name));
			f.close();
			init_mapsystem();
			string newid = randomstring(6);
			int housecode = random(1, 1000);
			spawn_house(p.x, p.y, p.z, p.map, p.name, housecode, 50000, mapname, parsed[2], newid);
			send_packet(6, "playpavap " + get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) + "fall.ogg " + p.x + " " + p.y + " " + p.z + " 0 0 200", p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.inv_add_item(parsed[2], -1);
			send_reliable(p, "Your " + parsed[2] + " has been placed, the code to get in to your house is " + housecode + "", 2);
		} else if (parsed[2] == "rosehaven_house") {
			if (p.partner == "") {
				send_reliable(p, "you can't put your " + parsed[2] + " here when your single", 2);
				return;
			}
			if (can_use_item_at(p.x, p.y, p.z, maps[get_map_index(p.map)], parsed[2]) == false) {
				send_reliable(p, "you can't put your " + parsed[2] + " here", 2);
				return;
			}
			string err = house_buildable(p);
			if (err != "") {
				p.sendpacket(err, 0);
				return;
			}
			string mapname = "house_of_" + p.name + "";
			if (map_exists(mapname)) {
				send_reliable(p, "you already have a house", 0);
				return;
			}
			if (in_house(p) > -1) {
				send_reliable(p, "you can't put this house inside another one", 0);
				return;
			}
			if (in_beehive(p) > -1) {
				send_reliable(p, "you can't put this house inside a beehive", 0);
				return;
			}
			if (in_playerstore(p) > -1) {
				send_reliable(p, "you can't put your house inside a store", 0);
				return;
			}
			if (p.is_admin() == false) {
				string charfolder = "chars/" + p.name;
				string[] a = string_split(file_get_contents("pbmaps.svr").replace("\r\n", "\n"), "\n");
				string[] a2 = string_split(file_get_contents(charfolder + "/maps.usr").replace("\r\n", "\n"), "\n");
				string[] a3 = string_split(file_get_contents("chmaps.svr").replace("\r\n", "\n"), "\n");
				int something = a.find(p.map);
				int something2 = a2.find(p.map);
				int something3 = a3.find(p.map);
				if (something > -1 or something2 > -1 or something3 > -1) {
					send_reliable(p, "you can't put this in your map", 2);
					return;
				}
			}
			if (is_travelpoint(p.x, p.y, p.z, maps[get_map_index(p.map)])) {
				send_reliable(p, "Building " + parsed[2] + "'s on travelpoints doesn't works!", 2);
				return;
			}
			if (get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "air" or get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "") {
				send_reliable(p, "can't place " + parsed[2] + "'s in the air", 0);
				return;
			}
			for (uint i = 0; i < houses.length(); i++) {
				if (houses[i].x == p.x and houses[i].y == p.y and houses[i].z == p.z and houses[i].map == p.map) {
					send_reliable(p, "there's a house here", 0);
					return;
				}
			}
			directory_create("maps/" + mapname);
			file f;
			f.open("maps/" + mapname + "/!.map", "wb");
			f.write(houses::mapget(houses::hpartner, mapname, p.name));
			f.close();
			load(mapname);
			string newid = randomstring(6);
			int housecode = random(1, 10000);
			spawn_house(p.x, p.y, p.z, p.map, p.name, housecode, 130000, mapname, parsed[2], newid);
			send_packet(6, "playpavap " + get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) + "fall.ogg " + p.x + " " + p.y + " " + p.z + " 0 0 200", p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.inv_add_item(parsed[2], -1);
			send_reliable(p, "Your " + parsed[2] + " has been placed, the code to get in to your house is " + housecode + "", 2);
		} else if (parsed[2] == "apartment") {
			if (can_use_item_at(p.x, p.y, p.z, maps[get_map_index(p.map)], parsed[2]) == false) {
				send_reliable(p, "you can't put your " + parsed[2] + " here", 2);
				return;
			}
			string err = apartment_buildable(p);
			if (err != "") {
				p.sendpacket(err, 0);
				return;
			}
			string mapname = "apartment_of_" + p.name + "";
			if (map_exists(mapname)) {
				send_reliable(p, "you already have an apartment", 0);
				return;
			}
			if (in_house(p) > -1 || in_apartment(p) > -1) {
				send_reliable(p, "you can't put this apartment inside another house or apartment", 0);
				return;
			}
			if (in_beehive(p) > -1) {
				send_reliable(p, "you can't put this apartment inside a beehive", 0);
				return;
			}
			if (in_playerstore(p) > -1) {
				send_reliable(p, "you can't put your apartment inside a store", 0);
				return;
			}
			if (p.is_admin() == false) {
				string charfolder = "chars/" + p.name;
				string[] a = string_split(file_get_contents("pbmaps.svr").replace("\r\n", "\n"), "\n");
				string[] a2 = string_split(file_get_contents(charfolder + "/maps.usr").replace("\r\n", "\n"), "\n");
				string[] a3 = string_split(file_get_contents("chmaps.svr").replace("\r\n", "\n"), "\n");
				int something = a.find(p.map);
				int something2 = a2.find(p.map);
				int something3 = a3.find(p.map);
				if (something > -1 or something2 > -1 or something3 > -1) {
					send_reliable(p, "you can't put this in your map", 2);
					return;
				}
			}
			if (is_travelpoint(p.x, p.y, p.z, maps[get_map_index(p.map)])) {
				send_reliable(p, "Building " + parsed[2] + "'s on travelpoints doesn't works!", 2);
				return;
			}
			if (get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "air" or get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "") {
				send_reliable(p, "can't place " + parsed[2] + "'s in the air", 0);
				return;
			}
			for (uint i = 0; i < houses.length(); i++) {
				if (houses[i].x == p.x and houses[i].y == p.y and houses[i].z == p.z and houses[i].map == p.map) {
					send_reliable(p, "there's a house here", 0);
					return;
				}
			}
			for (uint i = 0; i < apartments.length(); i++) {
				if (apartments[i].x == p.x and apartments[i].y == p.y and apartments[i].z == p.z and apartments[i].map == p.map) {
					send_reliable(p, "there's an apartment here", 0);
					return;
				}
			}
			directory_create("maps/" + mapname);
			file f;
			f.open("maps/" + mapname + "/!.map", "wb");
			f.write(apartments::mapget(apartments::aa, mapname, p.name));
			f.close();
			load(mapname);
			string newid = randomstring(6);
			int housecode = random(1, 10000);
			spawn_apartment(p.x, p.y, p.z, p.map, p.name, housecode, 130000, mapname, parsed[2], newid);
			send_packet(6, "playpavap " + get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) + "fall.ogg " + p.x + " " + p.y + " " + p.z + " 0 0 200", p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.inv_add_item(parsed[2], -1);
			send_reliable(p, "Your " + parsed[2] + " has been placed, the code to get in to your apartment is " + housecode + "", 2);
			return;
		} else if (parsed[2] == "tent") {
			if (can_use_item_at(p.x, p.y, p.z, maps[get_map_index(p.map)], parsed[2]) == false) {
				send_reliable(p, "you can't put your " + parsed[2] + " here", 2);
				return;
			}
			string mapname = "tent_of_" + p.name + "";
			if (map_exists(mapname)) {
				send_reliable(p, "you already have a tent", 0);
				return;
			}
			if (in_house(p) > -1 || in_apartment(p) > -1 || in_tent(p) > -1) {
				send_reliable(p, "you can't put this tent  inside another tent, house, or apartment", 0);
				return;
			}
			if (in_playerstore(p) > -1) {
				send_reliable(p, "you can't put your tent inside a store", 0);
				return;
			}
			if (p.is_admin() == false) {
				string charfolder = "chars/" + p.name;
				string[] a = string_split(file_get_contents("pbmaps.svr").replace("\r\n", "\n"), "\n");
				string[] a2 = string_split(file_get_contents(charfolder + "/maps.usr").replace("\r\n", "\n"), "\n");
				string[] a3 = string_split(file_get_contents("chmaps.svr").replace("\r\n", "\n"), "\n");
				int something = a.find(p.map);
				int something2 = a2.find(p.map);
				int something3 = a3.find(p.map);
				if (something > -1 or something2 > -1 or something3 > -1) {
					send_reliable(p, "you can't put this in your map", 2);
					return;
				}
			}
			if (is_travelpoint(p.x, p.y, p.z, maps[get_map_index(p.map)])) {
				send_reliable(p, "Building " + parsed[2] + "'s on travelpoints doesn't works!", 2);
				return;
			}
			if (get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "air" or get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "") {
				send_reliable(p, "can't place " + parsed[2] + "'s in the air", 0);
				return;
			}
			for (uint i = 0; i < houses.length(); i++) {
				if (houses[i].x == p.x and houses[i].y == p.y and houses[i].z == p.z and houses[i].map == p.map) {
					send_reliable(p, "there's a house here", 0);
					return;
				}
			}
			for (uint i = 0; i < apartments.length(); i++) {
				if (apartments[i].x == p.x and apartments[i].y == p.y and apartments[i].z == p.z and apartments[i].map == p.map) {
					send_reliable(p, "there's an apartment here", 0);
					return;
				}
			}
			for (uint i = 0; i < tents.length(); i++) {
				if (tents[i].x == p.x and tents[i].y == p.y and tents[i].z == p.z and tents[i].map == p.map) {
					send_reliable(p, "there's a tent here", 0);
					return;
				}
			}
			directory_create("maps/" + mapname);
			file f;
			f.open("maps/" + mapname + "/!.map", "wb");
			f.write(tents::mapget(tents::tnts, mapname, p.name));
			f.close();
			load(mapname);
			string newid = randomstring(6);
			int housecode = random(10001, 20000);
			spawn_tent(p.x, p.y, p.z, p.map, p.name, housecode, 100000, mapname, parsed[2], newid);
			send_packet(6, "playpavap " + get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) + "fall.ogg " + p.x + " " + p.y + " " + p.z + " 0 0 200", p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.inv_add_item(parsed[2], -1);
			send_reliable(p, "Your " + parsed[2] + " has been placed, the code to get in to your tent is " + housecode + "", 2);
			return;
		} else if (parsed[2] == "beehive") {
			if (can_use_item_at(p.x, p.y, p.z, maps[get_map_index(p.map)], parsed[2]) == false) {
				send_reliable(p, "you can't put your " + parsed[2] + " here", 2);
				return;
			}
			string mapname = "beehive_of_" + p.name + "";
			if (map_exists(mapname)) {
				send_reliable(p, "you already have a beehive", 0);
				return;
			}
			if (in_beehive(p) > -1) {
				send_reliable(p, "you can't put your beehive inside another one", 0);
				return;
			}
			if (in_playerstore(p) > -1) {
				send_reliable(p, "you can't put your beehive inside a store", 0);
				return;
			}
			if (p.is_admin() == false) {
				string charfolder = "chars/" + p.name;
				string[] a = string_split(file_get_contents(charfolder + "/maps.usr").replace("\r\n", "\n"), "\n");
				int something = a.find(p.map);
				if (something > -1) {
					send_reliable(p, "you can't put this beehive in your map", 0);
					return;
				}
			}
			if (is_safe(p.x, p.y, p.z, maps[get_map_index(p.map)]) == true and in_house(p) < 0) {
				send_reliable(p, "you can't put your beehive in safe places", 0);
				return;
			}
			if (is_travelpoint(p.x, p.y, p.z, maps[get_map_index(p.map)])) {
				send_reliable(p, "Building beehive's on travelpoints doesn't works!", 2);
				return;
			}
			if (get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "air" or get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "") {
				send_reliable(p, "can't place beehive' in the air", 0);
				return;
			}
			for (uint i = 0; i < beehives.length(); i++) {
				if (beehives[i].x == p.x and beehives[i].y == p.y and beehives[i].z == p.z and beehives[i].map == p.map) {
					send_reliable(p, "there's a beehive here", 0);
					return;
				}
			}
			directory_create("maps/" + mapname);
			file f;
			f.open("maps/" + mapname + "/!.map", "wb");
			f.write("mapname:" + mapname + "\nminx:0\nmaxx:10\nminy:0\nmaxy:10\nminz:0\nmaxz:10\ntile:0:10:0:10:0:0:ledge2\nowner:" + p.name + "\nlitem:0\nzone:0:10:0:10:0:10:beehive\nsrc:0:10:0:10:0:10:0:100:beehive.ogg\nai:0:10:0:10:0:0:10000:1:honey_bee\nzone:0:0:0:0:0:10:exit path:trackme\nitem:0:10:0:10:0:0:900000:3:honey\nrain:none.ogg\nwind:silence.ogg\nnight:silence.ogg\ndeathpoint:0:10:0:10:0:0\nstarting_point:0:10:0:10:0:0\nrain:raininterior.ogg\ndisable:house\ndisable:beehive\ndisable:store\ndisable:locker\ndisable:microwave\ndisable:fridge\ndisable:wind\ndisable:night\ndisable:car\ndisable:motor\nspecified_air_temperature:0:10:0:10:0:10:25");
			f.close();
			init_mapsystem();
			spawn_beehive(p.x, p.y, p.z, p.map, p.name, 1000, mapname);
			send_packet(6, "playpavap " + get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) + "fall.ogg " + p.x + " " + p.y + " " + p.z + " 0 0 200", p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.inv_add_item("beehive", -1);
			send_reliable(p, "Your beehive has been placed", 2);
		} else if (parsed[2] == "store") {
			if (can_use_item_at(p.x, p.y, p.z, maps[get_map_index(p.map)], parsed[2]) == false) {
				send_reliable(p, "you can't put your " + parsed[2] + " here", 2);
				return;
			}
			if (p.map != "down_town") {
				p.sendpacket("You can only build this in down town", 0);
				return;
			}
			if (p.gender == 0 and p.job != "salesman" or p.gender == 1 and p.job != "saleswoman") {
				if (p.gender == 0) send_reliable(p, "you are not a salesman", 2);
				else send_reliable(p, "you are not a saleswoman", 2);
				return;
			}
			if (p.contabancaria == 0) {
				send_reliable(p, "You haven't bank account to do this action", 2);
				return;
			}
			send_serverbox(p.peer_id, 2, 1, 0, -1, "pstore2", "press 1 to build a clothing store, 2 to build a weapon store, 4 to build a fastfood store, 5 to build a explosive store, 6 to build a misc store, 7 to build a medical store, 8 to build a fruit store, 9 to build a household store, 0 to build a team store, minus or - to build a jewelry");
		} else if (parsed[2] == "candle") {
			if (can_use_item_at(p.x, p.y, p.z, maps[get_map_index(p.map)], parsed[2]) == false) {
				send_reliable(p, "you can't put your " + parsed[2] + " here", 2);
				return;
			}
			send_packet(6, "playpavap " + get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) + "fall.ogg " + p.x + " " + p.y + " " + p.z + " 0 0 200", p.x, p.y, p.z, maps[get_map_index(p.map)]);
			spawn_candle(p.x, p.y, p.z, maps[get_map_index(p.map)], 0);
			p.inv_add_item("candle", -1);
		} else if (parsed[2] == "microwave") {
			if (can_use_item_at(p.x, p.y, p.z, maps[get_map_index(p.map)], parsed[2]) == false) {
				send_reliable(p, "you can't put your " + parsed[2] + " here", 2);
				return;
			}
			if (in_beehive(p) > -1) {
				send_reliable(p, "you can't put a microwave inside a beehive", 0);
				return;
			}
			if (is_safe(p.x, p.y, p.z, maps[get_map_index(p.map)]) == true and in_house(p) < 0) {
				send_reliable(p, "you can't put your microwave in safe places", 0);
				return;
			}
			if (get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "air" or get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "") {
				send_reliable(p, "can't place microwave' in the air", 0);
				return;
			}
			if (p.is_admin() == false) {
				string charfolder = "chars/" + p.name;
				string[] a = string_split(file_get_contents("pbmaps.svr").replace("\r\n", "\n"), "\n");
				string[] a2 = string_split(file_get_contents(charfolder + "/maps.usr").replace("\r\n", "\n"), "\n");
				string[] a3 = string_split(file_get_contents("chmaps.svr").replace("\r\n", "\n"), "\n");
				int something = a.find(p.map);
				int something2 = a2.find(p.map);
				int something3 = a3.find(p.map);
				if (something > -1 or something3 > -1) {
					send_reliable(p, "you can't put this in your map", 2);
					return;
				}
			}
			for (uint i = 0; i < microwaves.length(); i++) {
				if (microwaves[i].x == p.x and microwaves[i].y == p.y and microwaves[i].z == p.z and microwaves[i].map == p.map) {
					send_reliable(p, "there's already a microwave here", 0);
					return;
				}
			}
			send_packet(6, "playpavap " + get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) + "fall.ogg " + p.x + " " + p.y + " " + p.z + " 0 0 200", p.x, p.y, p.z, maps[get_map_index(p.map)]);
			string newid = randomstring(6);
			spawn_microwave(p.x, p.y, p.z, p.map, p.name, 5000, newid);
			p.inv_add_item("microwave", -1);
			send_reliable(p, "Your microwave has been placed successfully", 2);
		} else if (starter_exist_on(p.x, p.y, p.z, maps[get_map_index(p.map)]) == true and parsed[2] == "wood") {
			p.inv_add_item(parsed[2], -amount);
			send_packet(6, "playpavap " + get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) + "fall.ogg " + p.x + " " + p.y + " " + p.z + " 0 0 200", p.x, p.y, p.z, maps[get_map_index(p.map)]);
			send_packet(6, "play fireburn" + random(1, 5) + ".ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			for (uint i = 0; i < fire_starters.length(); i++)
				fire_starters[i].health += random(5, 10) * amount;
		} else if (starter_exist_on(p.x, p.y, p.z, maps[get_map_index(p.map)]) == true and parsed[2] != "wood") {
			send_packet(6, "play firehit.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			send_packet(6, "playpavap " + get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) + "fall.ogg " + p.x + " " + p.y + " " + p.z + " 0 0 200", p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.inv_add_item(parsed[2], -amount);
			for (uint i = 0; i < fire_starters.length(); i++)
				fire_starters[i].health -= random(5, 10) * amount;
		} else if (parsed[2] == "ball") {
			p.inv_add_item(parsed[2], -amount);
			send_packet(6, "playpavap " + get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) + "fall.ogg " + p.x + " " + p.y + " " + p.z + " 0 0 200", p.x, p.y, p.z, maps[get_map_index(p.map)]);
			spawn_silenceobj(p.x, p.y, p.z, maps[get_map_index(p.map)], parsed[2], amount);
			send_reliable(p, "hempty " + parsed[2], 0);
		} else {
			p.inv_add_item(parsed[2], -amount);
			send_packet(6, "playpavap " + get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) + "fall.ogg " + p.x + " " + p.y + " " + p.z + " 0 0 200", p.x, p.y, p.z, maps[get_map_index(p.map)]);
			spawn_obj(p.x, p.y, p.z, maps[get_map_index(p.map)], parsed[2], amount);
			send_reliable(p, "hempty " + parsed[2], 0);
		}
	} else if (parsed[0] == "tlpset" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		if (!map_exists(parsed[1])) {
			send_reliable(p, "this map does not exists", 2);
			return;
		}
		string charfolder = "chars/" + p.name;
		string[] a = string_split(file_get_contents("pbmaps.svr").replace("\r\n", "\n"), "\n");
		string[] a2 = string_split(file_get_contents(charfolder + "/maps.usr").replace("\r\n", "\n"), "\n");
		string[] a3 = string_split(file_get_contents("chmaps.svr").replace("\r\n", "\n"), "\n");
		int something = a.find(p.map);
		int something2 = a2.find(p.map);
		int something3 = a3.find(p.map);
		if (something > -1 or something3 > -1) {
			send_reliable(p, "you can't do this", 2);
			return;
		}
		send_packet(6, "play teleportstart.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
		send_reliable(p, "stopmoving", 0);
		if (p.waitingtimer.elapsed >= 4500) {
			p.waitingtimer.restart();
			int mi = get_map_index(parsed[1]);
			if ((mi > -1)) {
				string mdata = maps[mi].rawdata;
				string[] p1 = delinear(mdata);
				for (uint i = 0; i < p1.length(); i++) {
					string[] parsed = string_split(p1[i], ":", true);
					if (parsed[0] == "safezone" and parsed.length() > 6 and p.pvp == 1) {
						send_reliable(p, "you can't teleport to this map when you are pvp", 2);
						string[] parsed = string_split(p1[i], ":", false);
						return;
					}
				}
				if (maps[mi].pvp == 1 and maps[mi].pvpminx <= p.x and maps[mi].pvpmaxx >= p.x and maps[mi].pvpminy <= p.y and maps[mi].pvpmaxy >= p.y and maps[mi].pvpminz <= p.z and maps[mi].pvpmaxz >= p.z) {
					if (p.pvp != 1) {
						p.pvp = 1;
						send_reliable(p, "You are now pvp!", 2);
						send_reliable(0, "play_s pvpon.ogg", 6);
						send_reliable(0, "" + p.nickname + " is now pvp!", 2);
					}
				} else if (maps[mi].pvp == 2 and maps[mi].pvpminx <= p.x and maps[mi].pvpmaxx >= p.x and maps[mi].pvpminy <= p.y and maps[mi].pvpmaxy >= p.y and maps[mi].pvpminz <= p.z and maps[mi].pvpmaxz >= p.z) {
					if (p.pvp != 0) {
						p.pvp = 0;
						send_reliable(p, "You are no longer pvp!", 2);
						send_reliable(0, "play_s pvpoff.ogg", 6);
						send_reliable(0, "" + p.nickname + " is no longer pvp!", 2);
					}
				}
				move_player(p, parsed[1], random(maps[mi].spminx, maps[mi].spmaxx), random(maps[mi].spminy, maps[mi].spmaxy), random(maps[mi].spminz, maps[mi].spmaxz), true);
			}
			send_packet(6, "play teleportstop.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			send_reliable(p, "startmoving", 0);
			p.inv_add_item("teleporter", -1);
		}
	} else if (parsed[0] == "havecycleinventory") {
		if (p.have_cycle_inventory == 1)
			p.have_cycle_inventory = 0;
		else if (p.have_cycle_inventory == 0)
			p.have_cycle_inventory = 1;
		send_reliable(p, "havecycleinventory " + p.have_cycle_inventory, 0);
	} else if (parsed[0] == "pstore2") {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		string number = string_trim_left(get_event_message(), 8);
		string name;
		if (number == 1)
			name = "clothing_store";
		else if (number == 2)
			name = "weapon_store";
		else if (number == 4)
			name = "fastfood_store";
		else if (number == 5)
			name = "explosive_store";
		else if (number == 6)
			name = "misc_store";
		else if (number == 7)
			name = "medical_store";
		else if (number == 8)
			name = "fruit_store";
		else if (number == 9)
			name = "household_store";
		else if (number == 0)
			name = "team_store";
		else if (number == "-")
			name = "jewelry";
		else {
			p.sendpacket("canceled", 0);
			return;
		}
		string mapname = "" + name + "_of_" + p.name + "";
		if (map_exists(mapname)) {
			send_reliable(p, "you already have a " + name + "", 0);
			return;
		}
		if (in_playerstore(p) > -1) {
			send_reliable(p, "you can't build a store inside another one", 0);
			return;
		}
		if (in_house(p) > -1) {
			send_reliable(p, "you can't put your store inside a house", 0);
			return;
		}
		if (in_beehive(p) > -1) {
			send_reliable(p, "you can't put your store inside a beehive", 0);
			return;
		}
		if (p.is_admin() == false) {
			string charfolder = "chars/" + p.name;
			string[] a = string_split(file_get_contents("pbmaps.svr").replace("\r\n", "\n"), "\n");
			string[] a2 = string_split(file_get_contents(charfolder + "/maps.usr").replace("\r\n", "\n"), "\n");
			int something = a.find(p.map);
			int something2 = a2.find(p.map);
			if (something > -1 or something2 > -1) {
				send_reliable(p, "you can't put this in your map", 2);
				return;
			}
		}
		if (is_travelpoint(p.x, p.y, p.z, maps[get_map_index(p.map)])) {
			send_reliable(p, "Building store's on travelpoints doesn't works!", 2);
			return;
		}
		if (get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "air" or get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "") {
			send_reliable(p, "can't place playerstore' in the air", 0);
			return;
		}
		for (uint i = 0; i < playerstores.length(); i++) {
			if (playerstores[i].x == p.x and playerstores[i].y == p.y and playerstores[i].z == p.z and playerstores[i].map == p.map) {
				send_reliable(p, "there's a store here", 0);
				return;
			}
		}
		directory_create("maps/" + mapname);
		file f;
		f.open("maps/" + mapname + "/!.map", "wb");
		f.write("mapname:" + mapname + "\nminx:0\nmaxx:25\nminy:0\nmaxy:25\nminz:0\nmaxz:10\ntile:0:25:0:25:0:0:hardwood\nowner:" + p.name + "\nlitem:1\nstarting_point:0:25:0:25:0:0\ndeathpoint:0:25:0:25:0:0\nzone:0:25:0:25:0:10:" + name + "\nsrc:0:25:0:25:0:10:0:100:calm.ogg\nzone:0:0:0:0:0:10:exit door:trackme\n\rain:raininterior.ogg\nwind:silence.ogg\nnight:silence.ogg\nitem_usage_restriction:0:25:0:25:0:10:golden_gate_house:rosehaven_house:beehive:store:locker:fridge:microwave:sky_racer:ford:sorento:dogan_slx:grayhound_bus:m60_tank:tank:truck:v4_by_4_jeep:dodge_charger:doom_buggy:ford_pickup_truck:mlk_mission_cruiser:muscle_car:generic_motorcycle:frog_motorcycle:ducati_street_fighter:onda_cbr_600:yamaha_r6:aprilia_v4:aprilia_rs660:ducati_diavel:yamaha_off_road:kawasaki_hipersport:kawasaki_adventure_tourer:ducati_scrumbler:bmw_off_road:motor_boat");
		f.close();
		init_mapsystem();
		spawn_playerstore(p.x, p.y, p.z, p.map, p.name, name, 40000, mapname);
		send_packet(6, "playpavap " + get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) + "fall.ogg " + p.x + " " + p.y + " " + p.z + " 0 0 200", p.x, p.y, p.z, maps[get_map_index(p.map)]);
		p.inv_add_item("store", -1);
		send_reliable(p, "Your store has been placed", 2);
	} else if (parsed[0] == "uptime")
		send_reliable(p, "The server has been up for " + ms_to_readable_time(uptimer.elapsed) + ". Total recorded uptime: " + ms_to_readable_time(accumulated_uptimer.elapsed) + ". VPS uptime: " + ms_to_readable_time(TIME_SYSTEM_RUNNING_MILLISECONDS) + "", 2);
	else if (parsed[0] == "icstart" and parsed.length() > 1) {
		string selection = parsed[1];
		if (selection == "back" or selection == "" or selection == " ") {
			send_reliable(p, "canceled", 0);
			return;
		}
		string[] a = string_split(file_get_contents("notadg.svr").replace("\r\n", "\n"), "\n");
		int something = a.find(parsed[1]);
		if (something > -1) {
			send_reliable(p, "canceled", 0);
			return;
		}
		p.launchitem = selection;
		if (actable_items.find(selection) < 0) {
			send_packet(6, "play carrier_missileinput.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.launchmode = 0;
			send_packet(6, "play item_carying_projectileload" + random(2, 4) + ".ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			send_serverbox(p.peer_id, 2, -1, 1, -1, "icx", "Enter the X coordinate of the item carier");
			return;
		} else {
			string m = "yes:yes[]no:no";
			send_packet(6, "play item_carying_projectileload1.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			send_menu(p.peer_id, "Would you like this item to deploy when it has reached its destination?", "icmode", m);
		}
	} else if (parsed[0] == "icmode" and parsed.length() > 1) {
		string answer = parsed[1];
		if (answer == "back") {
			p.launchmode = -1;
			send_reliable(p, "Canceled", 0);
			return;
		}
		if (answer == "yes")
			p.launchmode = 1;
		else if (answer == "no")
			p.launchmode = 0;
		send_packet(6, "play item_carying_projectileload" + random(2, 4) + ".ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
		send_serverbox(p.peer_id, 2, -1, 1, -1, "icx", "Enter the X coordinate of the item carier");
	} else if (parsed[0] == "icx" and parsed.length() > 1) {
		if (parsed[1] == "[cncel]") {
			send_reliable(p, "Operation canceled!", 0);
			return;
		} else {
			p.missilex = string_to_number(parsed[1]);
			send_packet(6, "play item_carying_projectileload" + random(2, 4) + ".ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			send_serverbox(p.peer_id, 2, -1, 1, -1, "icy", "Enter the y target of the item carier");
		}
	} else if (parsed[0] == "icy" and parsed.length() > 1) {
		if (parsed[1] == "[cncel]") {
			send_reliable(p, "Operation canceled!", 0);
			return;
		} else {
			p.missiley = string_to_number(parsed[1]);
			send_packet(6, "play item_carying_projectileload" + random(2, 4) + ".ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			send_serverbox(p.peer_id, 2, -1, 1, -1, "icz", "Enter the z target of the item carier");
		}
	} else if (parsed[0] == "icz" and parsed.length() > 1) {
		if (parsed[1] == "[cncel]") {
			send_reliable(p, "Operation canceled!", 0);
			return;
		} else {
			p.inv_add_item("carrier_missile", -1);
			p.missilez = string_to_number(parsed[1]);
			if (can_spawn_item_at(p.missilex, p.missiley, p.missilez, maps[get_map_index(p.map)], p.launchitem) == false) {
				send_reliable(p, "play_s error.ogg", 6);
				send_reliable(p, p.launchitem + "s are not allowed there!", 0);
				p.inv_add_item("carrier_missile", 1);
				return;
			}
			send_packet(6, "play carrier_missile_start.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.inv_add_item(p.launchitem, -1);
			spawn_item_carier(p.x, p.y, p.z, p.missilex, p.missiley, p.missilez, maps[get_map_index(p.map)], p, p.launchitem, int_to_bool(p.launchmode));
			p.missiletimer.restart();
			p.missilex = 0; p.missiley = 0; p.missilez = 0; p.launchmode = -1;
		}
	} else if (parsed[0] == "putback") {
		send_packet(6, "play invput.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
		if (p.weapon_name != "fists") {
			p.weapon_name = "fists";
			if (p.weapon_ammos > 0)
				p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
			p.firetimer = 180;
			p.weapon_ammos = 0;
			p.weapon_ammo_type = "";
			p.weapon_copasity = 0;
			send_reliable(p, "notrapid", 0);
		}
	} else if (parsed[0] == "handdraw") {
		if (parsed.length() > 2)
			send_packet(6, "play draw" + get_draw_and_get_sound(parsed[2]) + ".ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
		if (parsed.length() < 3) {
			if (string_to_number(parsed[1]) == 1)
				send_reliable(p, "left hand", 2);
			else if (string_to_number(parsed[1]) == 2)
				send_reliable(p, "right hand", 2);
		} else if (drawwep(parsed[2], @p)) return;
		else send_reliable(p, parsed[2], 2);
	} else if (parsed[0] == "drawi")
		send_packet(6, "play draw" + get_draw_and_get_sound(parsed[1]) + ".ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
	else if (parsed[0] == "j1" and parsed.length() > 1) {
		int id = get_player_index_from(parsed[1]);
		if (id > -1) {
			if (players[id].is_trusted(p) == false and p.name != players[id].name and p.is_admin() == false) {
				send_reliable(p, "error: " + players[id].name + " doesn't trust you", 2);
				return;
			}
			if (players[id].looking != "" and p.name != players[id].name and p.is_admin() == false) {
				send_reliable(p, "error: " + players[id].name + " is looking at someone", 2);
				return;
			}
			string z = "" + get_zone_at(players[id].x, players[id].y, players[id].z, maps[get_map_index(players[id].map)]);
			z = map_vars(@players[id], z);
			if (z == "") z = "unknown area";
			send_reliable(p, "" + players[id].name + " is in " + z + "", 2);
		} else send_reliable(p, "msgnormal player not found", 0);
	} else if (parsed[0] == "j2" and parsed.length() > 1) {
		int id = get_player_index_from(parsed[1]);
		if (id > -1) {
			if (players[id].langchan == "disable_chat") send_reliable(p, "msg2 " + players[id].name + " has disabled chat", 0);
			else send_reliable(p, "msg2 " + players[id].name + " is in " + players[id].langchan + "", 0);
		}
	} else if (parsed[0] == "j3" and parsed.length() > 1) {
		int id = get_player_index_from(parsed[1]);
		if (id > -1) {
			int cindex = get_compid_handler_index(players[id].compid);
			if (cindex > -1 and directory_exists("chars/" + comphandles[cindex].playername))
				send_reliable(p, "" + players[id].name + "'s main account is " + comphandles[cindex].playername + "", 2);
		} else send_reliable(p, "msgnormal player not found", 0);
	}
	if (parsed[0] == "dep_r") {
		double n = string_to_number(parsed[1]);
		handle_deposit(p, n);
	} else if (parsed[0] == "dep2_r") {
		double n = string_to_number(parsed[1]);
		handle_transfer_preparation(p, n);
	} else if (parsed[0] == "dep3_r")
		dep3(p, parsed);
	else if (parsed[0] == "sac_r") {
		double n = string_to_number(parsed[1]);
		handle_withdrawal(p, n);
	}
	else if (parsed[0] == "dep_r2") {
		double n = string_to_number(parsed[1]);
		handle_deposit2(p, n);
	}
	else if (parsed[0] == "sac_r2") {
		double n = string_to_number(parsed[1]);
		handle_withdrawal2(p, n);
	} else if (parsed[0] == "bank_menu" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		} else if (parsed[1] == "balance_check") {
			string[] add;
			add.insert_last("thanks for choosing " + app.name + "'s bank, Choose what you want to  check?:int caixa_eletrnico");
			add.insert_last("Check your coins:cbalance");
			add.insert_last("Check your Credits:cbalance2");
			send_reliable(p, "mnormal " + linear(add), 0);
		} else if (parsed[1] == "balance_withdrawal") {
			string[] add;
			add.insert_last("thanks for choosing " + app.name + "'s bank, Choose what you want to  Withdraw?:int caixa_eletrnico");
			add.insert_last("Coins:sac");
			add.insert_last("Credits:sac2");
			send_reliable(p, "mnormal " + linear(add), 0);
		} else if (parsed[1] == "balance_deposit") {
			string[] add;
			add.insert_last("thanks for choosing " + app.name + "'s bank, Choose what you want to  deposit?:int caixa_eletrnico");
			add.insert_last("Coins:dep");
			add.insert_last("Credits:dep4");
			send_reliable(p, "mnormal " + linear(add), 0);
		} else if (parsed[1] == "balance_deposit2") {
			string[] add;
			add.insert_last("thanks for choosing " + app.name + "'s bank, what do you want to  deposit?:int caixa_eletrnico");
			add.insert_last("Deposit coins in another account:dep2");
			send_reliable(p, "mnormal " + linear(add), 0);
		}
	} else if (parsed[0] == "clothing")
		clothing(p, true);
	else if (parsed[0] == "smartphoneenter" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		if (parsed[1] == "charge")
			send_reliable(p, "this phone has " + p.smartphonecharge + "% charge", 2);
		else if (parsed[1] == "u-pay") {
			if (p.contabancaria == 0) {
				send_reliable(p, "you do not have a bank account", 0);
				return;
			}
			server_menu m;
			m.intro = "u-pay. an ultimate online transaction application.";
			m.initial_packet = "bank_menu";
			m.add("Check your funds", "balance_check");
			m.add("Deposit in another account", "balance_deposit2");
			m.send(e.peer_id);
		} else if (parsed[1] == "properties") {
			server_menu m;
			m.intro = "Select an option";
			m.initial_packet = "propertyset";
			m.add("property info", "propertyinfo");
			m.add("change the house code", "changehousecode");
			m.add("Change the apartment code", "changeacode");
			m.add("Change the tent code", "changetcode");
			m.send(e.peer_id);
		} else if (parsed[1] == "phone")
			send_reliable(p, "phone", 0);
		else if (parsed[1] == "msg")
			send_reliable(p, "msg", 0);
		else if (parsed[1] == "apps")
			send_reliable(p, "apps", 0);
		else if (parsed[1] == "yourprofile") {
			server_menu menu;
			menu.intro = "Select an option";
			menu.initial_packet = "spyourprofile";
			if (p.langchan == "") menu.add("select your language channel", "langchan");
			//if (p.age == 0) menu.add("select your age", "age");
			if (p.country == "") menu.add("select your country", "country");
			if (p.day == 0 || p.month == 0 || p.year == 0) menu.add("set your birth date", "birthday");
			menu.send(e.peer_id);
		}
	} else if (parsed[0] == "spyourprofile" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			if (p.smartphoneon == 0) {
				send_reliable(p, "your phone is off", 0);
				return;
			}
			server_menu m;
			m.intro = "one UI home";
			m.initial_packet = "smartphoneenter";
			if (p.langchan == "" or p.age == 0 or p.country == "" or p.day == 0 or p.month == 0 or p.year == 0) m.add("complete your profile", "yourprofile");
			else {
				m.add("check battery level", "charge");
				m.add("phone", "phone");
				m.add("messages", "msg");
				m.add("apps", "apps");
				m.add("properties menu", "properties");
			}
			m.send(p.peer_id);
		} else if (parsed[1] == "langchan") {
			server_menu menu;
			menu.intro = "Select a new language channel";
			menu.initial_packet = "lchannelset2";
			for (uint i = 0; i < language_channels.length(); i += 1)
				menu.add(language_channels[i], language_channels[i]);
			menu.add("password protected channels", "ppc");
			menu.send(e.peer_id);
		} else if (parsed[1] == "age") {
			server_menu menu;
			menu.intro = "how old are you?";
			menu.initial_packet = "ageset";
			for (uint i = 0; i < ages.length(); i += 1)
				menu.add(ages[i], ages[i]);
			menu.send(e.peer_id);
		} else if (parsed[1] == "country") {
			cmenu menu;
			menu.intro = "Where are you from?";
			menu.initial_packet = "countryset";
			json jj;
			jj.loadf("countries.json");
			json_object j = jj.get("data", json_object());
			string[] k = j.get_keys();
			if (k.length() < 1) return;
			for (uint i = 0; i < k.length(); i++) {
				if (!j.is_object(k[i])) continue;
				json_object@ l = j.get(k[i]);
				if (@l == null) continue;
				menu.add(l("country") + " (" + l("region") + ")", l("country"));
			}
			if (menu.menuitems.length() < 1) return;
			menu.send(e.peer_id);
		} else if (parsed[1] == "birthday") {
			server_menu menu;
			menu.intro = "set your birth date";
			menu.initial_packet = "birthdayset";
			if (p.day == 0) menu.add("day", "day");
			if (p.month == 0) menu.add("month", "month");
			if (p.year == 0) menu.add("year", "year");
			menu.send(e.peer_id);
		}
	} else if (parsed[0] == "birthdayset" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			if (p.smartphoneon == 0) {
				send_reliable(p, "your phone is off", 0);
				return;
			}
			server_menu m;
			m.intro = "one UI home";
			m.initial_packet = "smartphoneenter";
			if (p.langchan == "" or p.age == 0 or p.country == "" or p.day == 0 or p.month == 0 or p.year == 0) m.add("complete your profile", "yourprofile");
			else {
				m.add("check battery level", "charge");
				m.add("phone", "phone");
				m.add("messages", "msg");
				m.add("apps", "apps");
				m.add("properties menu", "properties");
			}
			m.send(p.peer_id);
		} else if (parsed[1] == "day") {
			server_menu menu;
			menu.intro = "select your day of birth";
			menu.initial_packet = "dayset";
			for (uint i = 1; i <= 31; i += 1)
				menu.add(i, i);
			menu.send(e.peer_id);
		} else if (parsed[1] == "month") {
			server_menu menu;
			menu.intro = "select your month of birth";
			menu.initial_packet = "monthset";
			for (uint i = 0; i < monthnames.length(); i += 1)
				menu.add(monthnames[i], (i + 1));
			menu.send(e.peer_id);
		} else if (parsed[1] == "year") {
			server_menu menu;
			menu.intro = "select your year of birth";
			menu.initial_packet = "yearset";
			for (uint i = 1900; i <= DATE_YEAR; i ++)
				menu.add(i, i);
			menu.send(e.peer_id);
		}
	} else if (parsed[0] == "lockcommand" and parsed.length() > 1) {
		int l = get_locker_at(p.x, p.y, p.z, maps[get_map_index(p.map)]);
		if (l > -1) {
			string cmd = string_replace(get_event_message(), "lockcommand ", "", false);
			lockers[l].command(cmd, p.peer_id);
		}
	} else if (parsed[0] == "changelockcode" and parsed.length() > 1) {
		int l = get_locker_at(p.x, p.y, p.z, maps[get_map_index(p.map)]);
		if (string_is_digits(parsed[1])) {
			lockers[l].code = string_to_number(parsed[1]);
			send_reliable(p, "the code was changed successfully. New code is " + lockers[l].code, 2);
		} else
			send_reliable(p, "error", 2);
	} else if (parsed[0] == "lock_auth" and parsed.length() > 1) {
		int code = string_to_number(parsed[1]);
		int l = get_locker_at(p.x, p.y, p.z, maps[get_map_index(p.map)]);
		if (l == -1) {
			p.packet("Sorry, no locker here", 0);
			return;
		} else {
			if (lockers[l].code == code) {
				send_packet(6, "play locker_dooropen.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
				lockers[l].main_ui(p);
			} else
				send_packet(6, "play locker_code_error.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
		}
	} else if (parsed[0] == "lockergive" and parsed.length() > 1) {
		if (get_locker_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) < 0) {
			send_reliable(p, "An internal error happened. Sorry", 0);
			return;
		}
		if (parsed[1] == "back") {
			send_reliable(p, "Canceled", 0);
			return;
		}
		if (parsed[1] == "invall") {
			int s = get_locker_at(p.x, p.y, p.z, maps[get_map_index(p.map)]);
			string invstring = p.get_inv();
			string[] invarray = delinear(invstring);
			for (uint i = 0; i < invarray.length(); i++) {
				string[] ite = string_split(invarray[i], "=", false);
				if (file_exists("foods_and_drinks/" + ite[0] + ".fad") || fridgestuff.find(ite[0]) > -1 || can_store_fridge_item(ite[0])) continue;
				p.inv_add_item(ite[0], -string_to_number(ite[1]));
				lockers[s].give(ite[0], string_to_number(ite[1]));
			}
			send_packet(6, "play base_storage_store.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			return;
		}
		p.shitem = parsed[1];
		send_serverbox(p.peer_id, 2, -1, 0, -1, "lockergivenow", "How many " + p.shitem + " would you like to store");
	} else if (parsed[0] == "lockertake" and parsed.length() > 1) {
		if (get_locker_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) < 0) {
			send_reliable(p, "An internal error happened. Sorry", 0);
			return;
		}
		if (parsed[1] == "back") {
			send_reliable(p, "Canceled", 0);
			return;
		}
		if (parsed[1] == "invall") {
			int s = get_locker_at(p.x, p.y, p.z, maps[get_map_index(p.map)]);
			string invstring = lockers[s].invdic_to_string();
			if (invstring == "") {
				send_reliable(p, "nothing to take", 0);
				return;
			}
			string[] invarray = delinear(invstring);
			for (uint i = 0; i < invarray.length(); i++) {
				string[] ite = string_split(invarray[i], "=", false);
				p.inv_add_item(ite[0], string_to_number(ite[1]));
				lockers[s].give(ite[0], -string_to_number(ite[1]));
			}
			send_packet(6, "play base_storage_remove.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			return;
		}
		p.shitem = parsed[1];
		send_serverbox(p.peer_id, 2, -1, 0, -1, "lockertakenow", "How many " + p.shitem + "s would you like to take from the locker");
	} else if (parsed[0] == "lockergivenow" and parsed.length() > 1) {
		if (get_locker_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) < 0) {
			send_reliable(p, "An internal error happened. Sorry", 0);
			return;
		}
		if (string_contains(parsed[1], "[cncel]", 1) > -1) {
			send_reliable(p, "Canceled", 0);
			return;
		}
		int index2 = get_locker_at(p.x, p.y, p.z, maps[get_map_index(p.map)]);
		double amount = string_to_number(parsed[1]);
		if (amount <= 0) {
			send_reliable(p, "At least 1 item must be deposited!", 0);
			return;
		}
		double has = p.inv_item_number(p.shitem);
		if (has < amount) {
			send_reliable(p, "Error: You do not have enough " + p.shitem + "s!", 0);
			return;
		} else {
			if (file_exists("foods_and_drinks/" + p.shitem + ".fad") || fridgestuff.find(p.shitem) > -1 || can_store_fridge_item(p.shitem)) return;
			p.inv_add_item(p.shitem, -amount);
			lockers[index2].give(p.shitem, amount);
			send_packet(6, "play base_storage_store.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			send_reliable(p, "You put " + amount + " " + p.shitem + "s inside the locker", 0);
		}
	} else if (parsed[0] == "lockertakenow" and parsed.length() > 1) {
		if (get_locker_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) < 0) {
			send_reliable(p, "An internal error happened. Sorry", 0);
			return;
		}
		if (string_contains(parsed[1], "[cncel]", 1) > -1) {
			send_reliable(p, "Canceled", 0);
			return;
		}
		int index2 = get_locker_at(p.x, p.y, p.z, maps[get_map_index(p.map)]);
		double amount = string_to_number(parsed[1]);
		if (amount <= 0) {
			send_reliable(p, "At least 1 item must be taken out!", 0);
			return;
		}
		double has = lockers[index2].get_item_count(p.shitem);
		if (has < amount) {
			send_reliable(p, "Error: This locker does not have enough " + p.shitem + "s!", 0);
			return;
		} else {
			p.inv_add_item(p.shitem, amount);
			lockers[index2].give(p.shitem, -amount);
			send_packet(6, "play base_storage_remove.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			send_reliable(p, "You take " + amount + " " + p.shitem + "s out of the locker's ", 0);
		}
	} else if (parsed[0] == "fridgecommand" and parsed.length() > 1) {
		int l = get_fridge_at(p.x, p.y, p.z, maps[get_map_index(p.map)]);
		if (l > -1) {
			string cmd = string_replace(get_event_message(), "fridgecommand ", "", false);
			fridges[l].command(cmd, p.peer_id);
		}
	} else if (parsed[0] == "fridgegive" and parsed.length() > 1) {
		if (get_fridge_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) < 0) {
			send_reliable(p, "An internal error happened. Sorry", 0);
			return;
		}
		if (parsed[1] == "back") {
			send_reliable(p, "Canceled", 0);
			return;
		}
		if (parsed[1] == "invall") {
			int s = get_fridge_at(p.x, p.y, p.z, maps[get_map_index(p.map)]);
			string invstring = p.get_inv();
			string[] invarray = delinear(invstring);
			for (uint i = 0; i < invarray.length(); i++) {
				string[] ite = string_split(invarray[i], "=", false);
				if ((!file_exists("foods_and_drinks/" + ite[0] + ".fad") && fridgestuff.find(ite[0]) < 0 && !can_store_fridge_item(ite[0]))) continue;
				p.inv_add_item(ite[0], -string_to_number(ite[1]));
				fridges[s].give(ite[0], string_to_number(ite[1]));
			}
			send_packet(6, "play base_fridge_store.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			return;
		}
		p.shitem = parsed[1];
		send_serverbox(p.peer_id, 2, -1, 0, -1, "fridgegivenow", "How many " + p.shitem + "s would you like to store");
	} else if (parsed[0] == "fridgetake" and parsed.length() > 1) {
		if (get_fridge_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) < 0) {
			send_reliable(p, "An internal error happened. Sorry", 0);
			return;
		}
		if (parsed[1] == "back") {
			send_reliable(p, "Canceled", 0);
			return;
		}
		if (parsed[1] == "invall") {
			int s = get_fridge_at(p.x, p.y, p.z, maps[get_map_index(p.map)]);
			string invstring = fridges[s].invdic_to_string();
			if (invstring == "") {
				send_reliable(p, "nothing to take", 0);
				return;
			}
			string[] invarray = delinear(invstring);
			for (uint i = 0; i < invarray.length(); i++) {
				string[] ite = string_split(invarray[i], "=", false);
				p.inv_add_item(ite[0], string_to_number(ite[1]));
				fridges[s].give(ite[0], -string_to_number(ite[1]));
			}
			send_packet(6, "play base_fridge_remove.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			return;
		}
		p.shitem = parsed[1];
		send_serverbox(p.peer_id, 2, -1, 0, -1, "fridgetakenow", "How many " + p.shitem + "s would you like to take from the fridge");
	} else if (parsed[0] == "fridgegivenow" and parsed.length() > 1) {
		if (get_fridge_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) < 0) {
			send_reliable(p, "An internal error happened. Sorry", 0);
			return;
		}
		if (string_contains(parsed[1], "[cncel]", 1) > -1) {
			send_reliable(p, "Canceled", 0);
			return;
		}
		int index2 = get_fridge_at(p.x, p.y, p.z, maps[get_map_index(p.map)]);
		double amount = string_to_number(parsed[1]);
		if (amount <= 0) {
			send_reliable(p, "At least 1 item must be deposited!", 0);
			return;
		}
		double has = p.inv_item_number(p.shitem);
		if (has < amount) {
			send_reliable(p, "Error: You do not have enough " + p.shitem + "s!", 0);
			return;
		} else {
			if (p.shitem != "") {
				p.inv_add_item(p.shitem, -amount);
				fridges[index2].give(p.shitem, amount);
			}
			send_packet(6, "play base_fridge_store.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			send_reliable(p, "You put " + amount + " " + p.shitem + "s inside the fridge", 0);
		}
	} else if (parsed[0] == "fridgetakenow" and parsed.length() > 1) {
		if (get_fridge_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) < 0) {
			send_reliable(p, "An internal error happened. Sorry", 0);
			return;
		}
		if (string_contains(parsed[1], "[cncel]", 1) > -1) {
			send_reliable(p, "Canceled", 0);
			return;
		}
		int index2 = get_fridge_at(p.x, p.y, p.z, maps[get_map_index(p.map)]);
		double amount = string_to_number(parsed[1]);
		if (amount <= 0) {
			send_reliable(p, "At least 1 item must be taken out!", 0);
			return;
		}
		double has = fridges[index2].get_item_count(p.shitem);
		if (has < amount) {
			send_reliable(p, "Error: This fridge does not have enough " + p.shitem + "s!", 0);
			return;
		} else {
			p.inv_add_item(p.shitem, amount);
			fridges[index2].give(p.shitem, -amount);
			send_packet(6, "play base_fridge_remove.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			send_reliable(p, "You take " + amount + " " + p.shitem + "s out of the fridge's ", 0);
		}
	} else if (parsed[0] == "propertyset" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		} else if (parsed[1] == "propertyinfo") {
			server_menu m;
			m.intro = "properties menu";
			m.initial_packet = "propertieslist";
			m.add("Apartment", "apartment");
			m.add("fridges", "fridges");
			m.add("house", "house");
			m.add("lockers", "lockers");
			m.add("microwaves", "microwaves");
			m.add("motors", "motors");
			m.add("stores", "stores");
			m.send(p.peer_id);
		} else if (parsed[1] == "changehousecode") {
			for (uint i = 0; i < houses.length(); i++) {
				if (houses[i].owner == p.name)
					send_serverbox(p.peer_id, 2, -1, -1, -1, "housepasschange", "Enter a new code for your house");
			}
		} else if (parsed[1] == "changeacode") {
			for (uint i = 0; i < apartments.length(); i++) {
				if (apartments[i].owner == p.name)
					send_serverbox(p.peer_id, 2, -1, -1, -1, "apartmentpasschange", "Enter a new code for your apartment");
			}
		} else if (parsed[1] == "changetcode") {
			for (uint i = 0; i < tents.length(); i++) {
				if (tents[i].owner == p.name)
					send_serverbox(p.peer_id, 2, -1, -1, -1, "tentpasschange", "Enter a new code for your tent");
			}
		}
	} else if (parsed[0] == "propertieslist" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		} else if (parsed[1] == "fridges") {
			string fs = "";
			for (uint i = 0; i < fridges.length(); i++) {
				if (fridges[i].owner == p.name)
					fs += "In coordinates " + fridges[i].x + ", " + fridges[i].y + ", " + fridges[i].z + ", in " + get_zone_at(fridges[i].x, fridges[i].y, fridges[i].z, maps[get_map_index(fridges[i].map)]) + ", with " + fridges[i].health + " health. ";
			}
			send_reliable(p, "" + (fs == "" ? "nothing found" : "fridges: " + fs + "") + "", 2);
			return;
		} else if (parsed[1] == "house") {
			string hs = "";
			for (uint i = 0; i < houses.length(); i++) {
				if (houses[i].owner == p.name)
					hs += "" + houses[i].itemdeleted + " In coordinates " + houses[i].x + ", " + houses[i].y + ", " + houses[i].z + ", in " + get_zone_at(houses[i].x, houses[i].y, houses[i].z, maps[get_map_index(houses[i].map)]) + ", with " + houses[i].health + " health, code: " + houses[i].code + ". ";
			}
			send_reliable(p, "" + (hs == "" ? "nothing found" : "" + hs + "") + "", 2);
			return;
		} else if (parsed[1] == "apartment") {
			string hs = "";
			for (uint i = 0; i < apartments.length(); i++) {
				if (apartments[i].owner == p.name)
					hs += "" + apartments[i].itemdeleted + " In coordinates " + apartments[i].x + ", " + apartments[i].y + ", " + apartments[i].z + ", in " + get_zone_at(apartments[i].x, apartments[i].y, apartments[i].z, maps[get_map_index(apartments[i].map)]) + ", with " + apartments[i].health + " health, code: " + apartments[i].code + ". ";
			}
			send_reliable(p, "" + (hs == "" ? "nothing found" : "" + hs + "") + "", 2);
			return;
		} else if (parsed[1] == "tent") {
			string hs = "";
			for (uint i = 0; i < tents.length(); i++) {
				if (tents[i].owner == p.name)
					hs += "" + tents[i].itemdeleted + " In coordinates " + tents[i].x + ", " + tents[i].y + ", " + tents[i].z + ", in " + get_zone_at(tents[i].x, tents[i].y, tents[i].z, maps[get_map_index(tents[i].map)]) + ", with " + tents[i].health + " health, code: " + tents[i].code + ". ";
			}
			send_reliable(p, "" + (hs == "" ? "nothing found" : "" + hs + "") + "", 2);
			return;
		} else if (parsed[1] == "lockers") {
			string ls = "";
			for (uint i = 0; i < lockers.length(); i++) {
				if (lockers[i].owner == p.name)
					ls += "In coordinates " + lockers[i].x + ", " + lockers[i].y + ", " + lockers[i].z + ", in " + get_zone_at(lockers[i].x, lockers[i].y, lockers[i].z, maps[get_map_index(lockers[i].map)]) + ", with " + lockers[i].health + " health, code: " + lockers[i].code + ". ";
			}
			send_reliable(p, "" + (ls == "" ? "nothing found" : "lockers: " + ls + "") + "", 2);
			return;
		} else if (parsed[1] == "microwaves") {
			string ms = "";
			for (uint i = 0; i < microwaves.length(); i++) {
				if (microwaves[i].owner == p.name)
					ms += "In coordinates " + microwaves[i].x + ", " + microwaves[i].y + ", " + microwaves[i].z + ", in " + get_zone_at(microwaves[i].x, microwaves[i].y, microwaves[i].z, maps[get_map_index(microwaves[i].map)]) + ", with " + microwaves[i].health + " health. ";
			}
			send_reliable(p, "" + (ms == "" ? "nothing found" : "microwaves: " + ms + "") + "", 2);
			return;
		} else if (parsed[1] == "stores") {
			string ss = "";
			for (uint i = 0; i < playerstores.length(); i++) {
				if (playerstores[i].owner == p.name)
					ss += "In coordinates " + playerstores[i].x + ", " + playerstores[i].y + ", " + playerstores[i].z + ", in " + get_zone_at(playerstores[i].x, playerstores[i].y, playerstores[i].z, maps[get_map_index(playerstores[i].map)]) + ", with " + playerstores[i].health + " health. ";
			}
			send_reliable(p, "" + (ss == "" ? "nothing found" : "stores: " + ss + "") + "", 2);
			return;
		}
	} else if (parsed[0] == "housepasschange" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		for (uint i = 0; i < houses.length(); i++) {
			if (houses[i].owner == p.name) {
				if (string_is_digits(parsed[1])) {
					houses[i].code = string_to_number(parsed[1]);
					send_reliable(p, "your house code has been changed to " + parsed[1] + "", 2);
				}
			}
		}
	} else if (parsed[0] == "apartmentpasschange" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		for (uint i = 0; i < apartments.length(); i++) {
			if (apartments[i].owner == p.name) {
				if (string_is_digits(parsed[1])) {
					apartments[i].code = string_to_number(parsed[1]);
					send_reliable(p, "your apartment code has been changed to " + parsed[1] + "", 2);
				}
			}
		}
	} else if (parsed[0] == "tentpasschange" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		for (uint i = 0; i < tents.length(); i++) {
			if (tents[i].owner == p.name) {
				if (string_is_digits(parsed[1])) {
					tents[i].code = string_to_number(parsed[1]);
					send_reliable(p, "your tent code has been changed to " + parsed[1] + "", 2);
				}
			}
		}
	} else if (parsed[0] == "employ" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		} else if (parsed[1] == "quitjob") {
			if (p.inv_item_number("coins") <= 2000) {
				send_reliable(p, "not enough money", 0);
				return;
			}
			p.job = "";
			p.inv_add_item("coins", -20000);
			servermoney += 20000;
			send_reliable(p, "done", 2);
			p.jobtitle = "";
		} else if (parsed[1] == "salesman") {
			if (p.inv_item_number("coins") <= 15000) {
				send_reliable(p, "not enough money", 0);
				return;
			}
			p.job = "salesman";
			p.inv_add_item("coins", -15000);
			servermoney += 15000;
			send_reliable(p, "you are now a salesman", 2);
			p.jobtitle = "salesman";
		} else if (parsed[1] == "saleswoman") {
			if (p.inv_item_number("coins") <= 15000) {
				send_reliable(p, "not enough money", 0);
				return;
			}
			p.job = "saleswoman";
			p.inv_add_item("coins", -15000);
			servermoney += 15000;
			send_reliable(p, "you are now a saleswoman", 2);
			p.jobtitle = "saleswoman";
		}
	} else if (parsed[0] == "marriage" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		server_menu m;
		m.intro = "" + p.name + ", are you sure you want to marry to " + parsed[1] + " and pay " + p.inv_item_number("coins") / 10 + " coins?";
		m.initial_packet = "marriage2";
		m.add("yes", parsed[1]);
		m.add("no", "no");
		m.send(p.peer_id);
	} else if (parsed[0] == "marriage2" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		} else if (parsed[1] == "no") {
			send_reliable(p, "ok", 2);
			return;
		} else {
			int index2 = get_player_index_from(parsed[1]);
			if (index2 < 0) {
				send_reliable(p, "" + parsed[1] + " is offline", 2);
				return;
			}
			server_menu m;
			m.intro = "" + players[index2].name + ", " + p.name + " wants to marry to you, do you accept and pay " + players[index2].inv_item_number("coins") / 10 + " coins?";
			m.initial_packet = "marriage3";
			m.add("yes", p.name);
			m.add("no", "no");
			m.send(players[index2].peer_id);
		}
	} else if (parsed[0] == "marriage3" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		} else if (parsed[1] == "no") {
			send_reliable(p, "ok", 2);
			return;
		} else {
			int index2 = get_player_index_from(parsed[1]);
			if (index2 < 0) {
				send_reliable(p, "" + parsed[1] + " is offline", 2);
				return;
			}
			double d = round(p.inv_item_number("coins") / 10, 0);
			double d2 = round(players[index2].inv_item_number("coins") / 10, 0);
			double d3 = round(d + d2, 0);
			send_reliable(p, "you've paid " + d + " coins to get married with " + players[index2].name + "", 2);
			servermoney += d;
			p.inv_add_item("coins", -d);
			send_reliable(players[index2], "you've paid " + d2 + " coins to get married with " + p.name + "", 2);
			servermoney += d2;
			players[index2].inv_add_item("coins", -d2);
			p.partner = players[index2].name;
			players[index2].partner = p.name;
			p.trust(players[index2]);
			players[index2].trust(p);
			send_reliable(p, "" + p.name + " and " + players[index2].name + ": Me as the mayor and with the authority given to me, declare you as a couple!", 2);
			send_reliable(players[index2], "" + p.name + " and " + players[index2].name + ": Me as the mayor and with the authority given to me, declare you as a couple!", 2);
			send_reliable(0, "attention folks! " + p.name + " and " + players[index2].name + " got married! " + p.name + " paid " + d + " coins and " + players[index2].name + " paid " + d2 + " coins, adding up to a total of " + d3 + " coins", 2);
			send_reliable(0, "play_s crowdclap1.ogg", 6);
		}
	} else if (parsed[0] == "divorce" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		server_menu m;
		m.intro = "" + p.name + ", are you sure you want to divorce from " + parsed[1] + " and pay " + p.inv_item_number("coins") / 2 + " coins?";
		m.initial_packet = "divorce2";
		m.add("yes", parsed[1]);
		m.add("no", "no");
		m.send(p.peer_id);
	} else if (parsed[0] == "divorce2" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		} else if (parsed[1] == "no") {
			send_reliable(p, "ok", 2);
			return;
		} else {
			int index2 = get_player_index_from(p.partner);
			if (index2 < 0) {
				send_reliable(p, "" + parsed[1] + " is offline", 2);
				return;
			}
			server_menu m;
			m.intro = "" + players[index2].name + ", " + p.name + " wants to divorce from you, do you accept and pay " + players[index2].inv_item_number("coins") / 2 + " coins?";
			m.initial_packet = "divorce3";
			m.add("yes", p.name);
			m.add("no", "no");
			m.send(players[index2].peer_id);
		}
	} else if (parsed[0] == "divorce3" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		} else if (parsed[1] == "no") {
			send_reliable(p, "ok", 2);
			return;
		} else {
			int index2 = get_player_index_from(p.partner);
			if (index2 < 0) {
				send_reliable(p, "" + parsed[1] + " is offline", 2);
				return;
			}
			double d = round(p.inv_item_number("coins") / 2, 0);
			double d2 = round(players[index2].inv_item_number("coins") / 2, 0);
			double d3 = round(d + d2, 0);
			send_reliable(p, "you've paid " + d + " coins to divorce from " + players[index2].name + "", 2);
			servermoney += d;
			p.inv_add_item("coins", -d);
			send_reliable(players[index2], "you've paid " + d2 + " coins to divorce from " + p.name + "", 2);
			servermoney += d2;
			players[index2].inv_add_item("coins", -d2);
			p.partner = "";
			players[index2].partner = "";
			p.untrust(players[index2].name);
			players[index2].untrust(p.name);
			send_reliable(p, "court judgment: " + p.name + " and " + players[index2].name + ": Me as the judge, I declare you as two single individuals. You are now divorced.", 2);
			send_reliable(players[index2], "court judgment: " + p.name + " and " + players[index2].name + ": Me as the judge, I declare you as two single individuals. You are now divorced.", 2);
			send_reliable(0, "attention! " + p.name + " and " + players[index2].name + " divorced. " + p.name + " paid " + d + " coins and " + players[index2].name + " paid " + d2 + " coins, adding up to a total of " + round(d + d2, 0) + " coins", 2);
			send_reliable(0, "play_s notify" + random(1, 10) + ".ogg", 6);
		}
	} else if (parsed[0] == "editline" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		send_reliable(p, "buildeditline " + string_replace(get_event_message(), parsed[0] + " ", "", true), 0);
		p.editline = string_replace(get_event_message(), parsed[0] + " ", "", true);
	} else if (parsed[0] == "removeline" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		p.removeline = string_replace(get_event_message(), parsed[0] + " ", "", true);
		send_reliable(p, "buildremoveline " + string_replace(get_event_message(), parsed[0] + " ", "", true), 0);
	} else if (parsed[0] == "aieditlinetext" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		send_reliable(p, "buildaieditlinetext " + string_replace(get_event_message(), parsed[0] + " ", "", true), 0);
		p.aieditline = string_replace(get_event_message(), parsed[0] + " ", "", true);
	} else if (parsed[0] == "airemovelinetext" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		send_reliable(p, "buildairemovelinetext " + string_replace(get_event_message(), parsed[0] + " ", "", true), 0);
		p.airemoveline = string_replace(get_event_message(), parsed[0] + " ", "", true);
	} else if (parsed[0] == "drawsoundseditlinetext" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		send_reliable(p, "builddrawsoundseditlinetext " + string_replace(get_event_message(), parsed[0] + " ", "", true), 0);
		p.drawsoundseditline = string_replace(get_event_message(), parsed[0] + " ", "", true);
	} else if (parsed[0] == "drawsoundsremovelinetext" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		send_reliable(p, "builddrawsoundsremovelinetext " + string_replace(get_event_message(), parsed[0] + " ", "", true), 0);
		p.drawsoundsremoveline = string_replace(get_event_message(), parsed[0] + " ", "", true);
	} else if (parsed[0] == "itemusagelimiteditlinetext" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		send_reliable(p, "builditemusagelimiteditlinetext " + string_replace(get_event_message(), parsed[0] + " ", "", true), 0);
		p.itemusagelimiteditline = string_replace(get_event_message(), parsed[0] + " ", "", true);
	} else if (parsed[0] == "itemusagelimitremovelinetext" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		send_reliable(p, "builditemusagelimitremovelinetext " + string_replace(get_event_message(), parsed[0] + " ", "", true), 0);
		p.itemusagelimitremoveline = string_replace(get_event_message(), parsed[0] + " ", "", true);
	} else if (parsed[0] == "fadeditlinetext" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		p.fadtoedit = parsed[1];
		file f;
		f.open("foods_and_drinks/" + parsed[1], "rb");
		send_reliable(p, "buildfadeditlinetext " + f.read(), 0);
		f.close();
	} else if (parsed[0] == "removeowner" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		send_reliable(p, "buildremoveowner " + string_replace(get_event_message(), parsed[0] + " ", "", true), 0);
		p.removeowner = string_replace(get_event_message(), parsed[0] + " ", "", true);
	} else if (parsed[0] == "reviveset" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		string name = string_trim_left(parsed[1], 10);
		mapdata@ m = get_map_obj(p.map);
		if (@m == null) return;
		spawn_ai(p.x, p.y, p.z, m, name, 1, m.min, m.max);
		p.inv_add_item("animal_revitalizer", -1);
		p.inv_add_item("corpse_of_" + name + "", -1);
		if (p.pvp != 1) {
			p.pvp = 1;
			send_reliable(p, "You are now pvp!", 2);
			send_reliable(0, "play_s pvpon.ogg", 6);
			send_reliable(0, "" + p.nickname + " is now pvp!", 2);
		}
	} else if (parsed[0] == "friendshipset" and parsed.length() > 1 and p.looking == "" and p.prison == false) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		if (parsed[1] == p.name) {
			p.sendpacket("you can't do this to yourself", 0);
			return;
		}
		for (uint i = 0; i < arenas.length(); i++) {
			if (p.map == arenas[i].map) {
				send_reliable(p, "You can't do this in here", 2);
				return;
			}
		}
		string charfolder = "chars/" + p.name;
		string[] a = string_split(file_get_contents("pbmaps.svr").replace("\r\n", "\n"), "\n");
		string[] a2 = string_split(file_get_contents(charfolder + "/maps.usr").replace("\r\n", "\n"), "\n");
		string[] a3 = string_split(file_get_contents("chmaps.svr").replace("\r\n", "\n"), "\n");
		int something = a.find(p.map);
		int something2 = a2.find(p.map);
		int something3 = a3.find(p.map);
		if (something > -1 or something3 > -1) {
			send_reliable(p, "you can't do this on this map", 2);
			return;
		}
		int i2 = get_player_index_from(parsed[1]);
		if (i2 > -1) {
			string ncharfolder = "chars/" + players[i2].name;
			string[] a = string_split(file_get_contents("pbmaps.svr").replace("\r\n", "\n"), "\n");
			string[] a2 = string_split(file_get_contents(ncharfolder + "/maps.usr").replace("\r\n", "\n"), "\n");
			string[] a3 = string_split(file_get_contents("chmaps.svr").replace("\r\n", "\n"), "\n");
			int nsomething = a.find(players[i2].map);
			int nsomething2 = a2.find(players[i2].map);
			int nsomething3 = a3.find(players[i2].map);
			if (nsomething > -1 or nsomething2 > -1 or nsomething3 > -1) {
				send_reliable(p, "you can't do this on their map", 2);
				return;
			}
			for (uint i = 0; i < arenas.length(); i++) {
				if (arenas[i].map == players[i2].map) {
					send_reliable(p, "" + players[i2].name + " is in an arena and you can't go to him", 2);
					return;
				}
			}
			if (players[i2].map == "jail") {
				p.sendpacket("" + players[i2].name + " is in jail", 2);
				return;
			}
			int mi = get_map_index(players[i2].map);
			if ((mi > -1)) {
				if (can_use_item_at(players[i2].x, players[i2].y, players[i2].z, maps[get_map_index(players[i2].map)], "friendship_sphere") == false) {
					p.sendpacket("You cannot go to this player due to friendship sphere restriction", 0);
					return;
				}
				if ((maps[mi].minlevel > 0 && p.level<maps[mi].minlevel) || (maps[mi].maxlevel > 0 && p.level>maps[mi].maxlevel)) {
					send_reliable(p, "" + maps[mi].name + " is only for players with level range of " + maps[mi].minlevel + " until " + maps[mi].maxlevel + "", 2);
					return;
				}
				if ((maps[mi].minreinforcement > 0 && p.reinforcement<maps[mi].minreinforcement) || (maps[mi].maxreinforcement > 0 && p.reinforcement>maps[mi].maxreinforcement)) {
					send_reliable(p, "" + maps[mi].name + " is only for players with reinforcement range of " + maps[mi].minreinforcement + " until " + maps[mi].maxreinforcement + "", 2);
					return;
				}
				string mdata = maps[mi].rawdata;
				string[] p1 = delinear(mdata);
				for (uint i = 0; i < p1.length(); i++) {
					string[] parsed = string_split(p1[i], ":", true);
					if (parsed[0] == "safezone" and parsed.length() > 6 and p.pvp == 1) {
						send_reliable(p, "you can't go to " + players[i2].map + "'s map when you are pvp", 2);
						return;
					}
				}
				if (maps[mi].pvp == 1 and maps[mi].pvpminx <= p.x and maps[mi].pvpmaxx >= p.x and maps[mi].pvpminy <= p.y and maps[mi].pvpmaxy >= p.y and maps[mi].pvpminz <= p.z and maps[mi].pvpmaxz >= p.z) {
					if (p.pvp != 1) {
						p.pvp = 1;
						send_reliable(p, "You are now pvp!", 2);
						send_reliable(0, "play_s pvpon.ogg", 6);
						send_reliable(0, "" + p.nickname + " is now pvp!", 2);
					}
				} else if (maps[mi].pvp == 2 and maps[mi].pvpminx <= p.x and maps[mi].pvpmaxx >= p.x and maps[mi].pvpminy <= p.y and maps[mi].pvpmaxy >= p.y and maps[mi].pvpminz <= p.z and maps[mi].pvpmaxz >= p.z) {
					if (p.pvp != 0) {
						p.pvp = 0;
						send_reliable(p, "You are no longer pvp!", 2);
						send_reliable(0, "play_s pvpoff.ogg", 6);
						send_reliable(0, "" + p.nickname + " is no longer pvp!", 2);
					}
				}
				move_player(p, players[i2].map, players[i2].x, players[i2].y, players[i2].z);
				send_packet(6, "play notify_swoosh.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
				p.inv_add_item("friendship_sphere", -1);
			}
		}
	} else if (parsed[0] == "objs") {
		string data;
		for (int i = 0; i < objs.length(); i++) {
			double distance = get_3d_distance(p.x, p.y, p.z, objs[i].x, objs[i].y, objs[i].z);
			distance = round(distance, 0);
			if (p.map == objs[i].map.name and distance < 31)
				data += objs[i].amount + ":" + objs[i].name + ":" + objs[i].x + ":" + objs[i].y + ":" + objs[i].z + ":" + distance + "@";
		}
		for (int i = 0; i < silenceobjs.length(); i++) {
			double distance = get_3d_distance(p.x, p.y, p.z, silenceobjs[i].x, silenceobjs[i].y, silenceobjs[i].z);
			distance = round(distance, 0);
			if (p.map == silenceobjs[i].map.name and distance < 31)
				data += silenceobjs[i].amount + ":" + silenceobjs[i].name + ":" + silenceobjs[i].x + ":" + silenceobjs[i].y + ":" + silenceobjs[i].z + ":" + distance + "@";
		}
		if (data == "")
			send_reliable(p, "No items around you", 2);
		else
			send_reliable(p, "objs " + data, 0);
	} else if (parsed[0] == "hfish") {
		if (p.tenter.elapsed >= 600) {
			p.tenter.restart();
			string tile = get_tile_at(p.x, p.y, p.z, maps[get_map_index(p.map)]);
			if (tile == "water" or tile == "water2" or tile == "water3" or tile == "water4" or tile == "water5" or tile == "water6" or tile == "water7" or tile == "water8" or tile == "water9" or tile == "water10" or tile == "puddle" or tile == "deepwater" or tile == "swim" or tile == "swimming" or tile == "swimming2" or tile == "spring" or tile == "spring2" or tile == "wallboat" and p.jpescar) {
				if (p.npescar > 0) {
					p.npescar--;
					p.tppeixe.restart();
					if (p.npescar < 0)p.npescar = 0;
					if (p.ppeixe == 1) send_packet(6, "play fishlure.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
					else {
						send_packet(6, "play fishreal.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
						p.plinha = 1;
					}
					if (p.npescar == 0) {
						p.tppeixe.force(0); p.tppeixe.pause();
						if (p.ppeixe == 1) send_packet(6, "play getfish.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]); p.inv_add_item("fish", 1);
						send_reliable(p, "hempty " + parsed[2], 0);
						p.ppeixe = 0;
						p.plinha = 0;
					}
				} else if (p.npescar <= 0) {
					p.npescar = 1;
					p.npescando = 0;
					p.tppeixe.restart();
					p.npescar = random(15, 35);
					p.npescando = 1;
				}
				send_packet(6, "play fishcast.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			}
			return;
		}
	} else if (parsed[0] == "transfer" and parsed.length() > 2) {
		file f;
		if (file_exists("chars/" + p.name + "/" + parsed[1] + ".usr") == true) {
			f.open("chars/" + p.name + "/" + parsed[1] + ".usr", "rb");
			double ar = string_to_number(f.read());
			f.close();
			send_reliable(p, "you've already transfered " + ar + " " + parsed[1] + "", 2);
			return;
		}
		double amount = string_to_number(parsed[2]);
		if (amount <= p.inv_item_number(parsed[1]) and amount > 0) {
			if (string_contains(parsed[1], "credit", 1) > -1 or string_contains(parsed[1], "paid_gift", 1) > -1 or string_contains(parsed[1], "quick_thirst_fix_drug", 1) > -1 or string_contains(parsed[1], "quick_hunger_fix_snack", 1) > -1 or string_contains(parsed[1], "xp_potion", 1) > -1 or string_contains(parsed[1], "armor", 1) > -1 or string_contains(parsed[1], "safe_card", 1) > -1 or string_contains(parsed[1], "health_box", 1) > -1 or string_contains(parsed[1], "energy_pill", 1) > -1 or string_contains(parsed[1], "teleporter", 1) > -1 or string_contains(parsed[1], "nuclear_bomb", 1) > -1 or string_contains(parsed[1], "small_nuclear_bomb", 1) > -1 or string_contains(parsed[1], "large_nuclear_bomb", 1) > -1) {
				p.inv_add_item(parsed[1], -amount);
				file_put_contents("chars/" + p.name + "/" + parsed[1] + ".usr", amount, 250);
				p.add_log_entry("player_actions", "transfered " + amount + " " + parsed[1] + "");
				send_reliable(p, "you've transfered " + amount + " " + parsed[1] + "", 2);
			}
		}
	} else if (parsed[0] == "admintell" and parsed.length() > 1) {
		if (p.ds.find("admintell") > -1) {
			send_reliable(p, "your admintells have been disabled", 0);
			return;
		}
		string final;
		final = string_trim_left(get_event_message(), 10);
		asttell("admintell message from " + p.name + ": " + final, "admintell.ogg");
		if (!p.assistant)
			send_reliable(p, "Your message has been sent to the admins.", 2);
		file f;
		f.open("admintells.svr", "ab");
		f.write(p.name + " said: " + final + "\n");
		f.close();
	} else if (parsed[0] == "weaponpings") {
		if (p.weaponpings == 0) {
			p.weaponpings = 1;
			send_reliable(p, "play_s toggleon.ogg", 6);
			send_reliable(p, "weapon pings enabled", 2);
		} else {
			p.weaponpings = 0;
			send_reliable(p, "play_s toggleoff.ogg", 6);
			send_reliable(p, "weapon pings disabled", 2);
		}
	} else if (parsed[0] == "pmreceive") {
		p.pmreceiving = toggle(p.pmreceiving);
		if (p.pmreceiving == 0) {
			send_reliable(p, "play_s toggleoff.ogg", 6);
			send_reliable(p, "You will no longer receive private messages", 0);
		} else {
			send_reliable(p, "play_s toggleon.ogg", 6);
			send_reliable(p, "You will receive private messages from now on", 0);
			return;
		}
	} else if (parsed[0] == "beacon") {
		p.beacon = toggle(p.beacon);
		if (p.beacon == 0) {
			send_reliable(p, "play_s toggleoff.ogg", 6);
			send_reliable(p, "beacons disabled", 0);
		} else {
			send_reliable(p, "play_s toggleon.ogg", 6);
			send_reliable(p, "beacons enabled", 0);
			return;
		}
	} else if (parsed[0] == "localchat" and parsed.length() >= 1) {
		if (p.ds.find("chat") > -1) {
			send_reliable(p, "your chats have been disabled", 0);
			return;
		}
		if (p.away == true and string_replace(get_event_message(), parsed[0] + " ", "", true) != "/afk" and !p.is_admin() == false) {
			send_reliable(p, "You can't chat while you are away", 2);
			return;
		}
		if (chatting == 0) {
			string message;
			message = "Sorry, server chats are currently disabled.";
			if (p.is_admin()) message += " If you want to turn them back on, type /varset chatting 1";
			send_reliable(p, message, 2);
			return;
		}
		if (p.looking == "") {
			p.chats += 1;
			log(p.name + "_chats", "local chat from " + p.name + ": " + string_replace(get_event_message(), parsed[0] + " ", "", true), true);
			send_dpacket(0, "localchat local chat from " + p.nickname + " (" + p.name + "): " + string_replace(get_event_message(), parsed[0] + " ", "", true), maps[get_map_index(p.map)]);
		}
	} else if (parsed[0] == "levelsound") {
		if (p.levelsound == 0) {
			p.levelsound = 1;
			send_reliable(p, "play_s toggleon.ogg", 6);
			send_reliable(p, "level sounds enabled", 2);
		} else if (p.levelsound == 1) {
			p.levelsound = 0;
			send_reliable(p, "play_s toggleoff.ogg", 6);
			send_reliable(p, "level sounds disabled", 2);
		}
	} else if (parsed[0] == "2dnewmap" and parsed.length() > 8 and p.prison == false) {
		string mapname = parsed[1];
		if (parsed.length() > 9) {
			send_reliable(p, "spaces arent allowed in the name of the map", 0);
			return;
		}
		if (!mapname_is_valid(mapname)) {
			send_reliable(p, "Invalid map name", 0);
			return;
		}
		if (map_exists(mapname)) {
			send_reliable(p, "this map already exists", 0);
			return;
		}
		if (string_contains(mapname, "house_of_", 1) > -1 or string_contains(mapname, "beehive_of_", 1) > -1 or string_contains(mapname, "store_of_", 1) > -1 or stringcontains(mapname, "apartment_of", 1) > -1 or stringcontains(mapname, "tent_of", 1) > -1) {
			send_reliable(p, "error: please change the map name", 0);
			return;
		}
		int minx = string_to_number(parsed[2]);
		int maxx = string_to_number(parsed[3]);
		int miny = string_to_number(parsed[4]);
		int maxy = string_to_number(parsed[5]);
		int minz = string_to_number(parsed[6]);
		int maxz = string_to_number(parsed[7]);
		string platform = parsed[8];
		string owner = p.name;
		int litem = 0;
		directory_create("maps/" + mapname);
		file f;
		f.open("maps/" + mapname + "/!.map", "wb");
		f.write("mapname:" + mapname + "\nminx:" + minx + "\nmaxx:" + maxx + "\nminy:" + miny + "\nmaxy:" + maxy + "\nminz:" + minz + "\nmaxz:" + maxz + "\ntile:" + minx + ":" + maxx + ":" + miny + ":" + maxy + ":0:0:" + platform + "\nowner:" + owner + "\nlitem:" + litem + "\nstarting_point:" + minx + ":" + maxx + ":" + miny + ":" + maxy + ":0:0\ndeathpoint:" + minx + ":" + maxx + ":" + miny + ":" + maxy + ":0:0\nenable:2dsupport");
		f.close();
		load(mapname);
		move_player(p, mapname, minx, miny, minz, true);
		if (string_contains(mapname, "house_of_", 1) < 0 and string_contains(mapname, "beehive_of_", 1) < 0 and string_contains(mapname, "store_of_", 1) < 0) file_put_contents("chars/" + p.name + "/maps.usr", "" + mapname + "\n", 255);
		send_reliable(p, "Done", 0);
	} else if (parsed[0] == "newmap" and parsed.length() > 8 and p.prison == false) {
		string mapname = parsed[1];
		if (parsed.length() > 9) {
			send_reliable(p, "spaces arent allowed in the name of the map", 0);
			return;
		}
		if (!mapname_is_valid(mapname)) {
			send_reliable(p, "Invalid map name", 0);
			return;
		}
		if (map_exists(mapname)) {
			send_reliable(p, "this map already exists", 0);
			return;
		}
		if (string_contains(mapname, "house_of_", 1) > -1 or string_contains(mapname, "beehive_of_", 1) > -1 or string_contains(mapname, "store_of_", 1) > -1 or stringcontains(mapname, "apartment_of", 1) > -1 or stringcontains(mapname, "tent_of", 1) > -1) {
			send_reliable(p, "error: please change the map name", 0);
			return;
		}
		int minx = string_to_number(parsed[2]);
		int maxx = string_to_number(parsed[3]);
		int miny = string_to_number(parsed[4]);
		int maxy = string_to_number(parsed[5]);
		int minz = string_to_number(parsed[6]);
		int maxz = string_to_number(parsed[7]);
		string platform = parsed[8];
		string owner = p.name;
		int litem = 0;
		directory_create("maps/" + mapname);
		file f;
		f.open("maps/" + mapname + "/!.map", "w");
		f.write("mapname:" + mapname + "\nminx:" + minx + "\nmaxx:" + maxx + "\nminy:" + miny + "\nmaxy:" + maxy + "\nminz:" + minz + "\nmaxz:" + maxz + "\ntile:" + minx + ":" + maxx + ":" + miny + ":" + maxy + ":0:0:" + platform + "\nowner:" + owner + "\nlitem:" + litem + "\nstarting_point:" + minx + ":" + maxx + ":" + miny + ":" + maxy + ":0:0\ndeathpoint:" + minx + ":" + maxx + ":" + miny + ":" + maxy + ":0:0");
		f.close();
		load(mapname);
		move_player(p, mapname, minx, miny, minz, true);
		if (string_contains(mapname, "house_of_", 1) < 0 and string_contains(mapname, "beehive_of_", 1) < 0 and string_contains(mapname, "store_of_", 1) < 0) file_put_contents("chars/" + p.name + "/maps.usr", "" + mapname + "\n", 255);
		send_reliable(p, "Done", 0);
	} else if (parsed[0] == "uploadsound") {
		if (can_upload_files == 0 && p.dev == false) send_reliable(p, "Sorry! File uploading is not permitted!", 2);
		else send_reliable(p, "upload", 0);
	} else if (parsed[0] == "vpartnercheck") {
		if (p.partner != "")
			send_reliable(p, "vpartnercheck", 0);
	} else if (parsed[0] == "delmap" and parsed.length() > 1) {
	} else if (parsed[0] == "auction" and parsed.length() >= 5) {
		if (p.prison == true) {
			send_reliable(p, "You can't do this in prison", 2);
			return;
		}
		for (uint i = 0; i < arenas.length(); i++) {
			if (p.map == arenas[i].map) {
				send_reliable(p, "You can't do this in here", 2);
				return;
			}
		}
		string[] adg = string_split(file_get_contents("notadg.svr").replace("\r\n", "\n"), "\n");
		int something = adg.find(parsed[2]);
		if (something > -1) {
			send_reliable(p, "You can't auction " + parsed[2] + "", 2);
			return;
		}
		string what = parsed[2];
		string currency = parsed[3];
		double am = stn(parsed[1]);
		double minbid = stn(parsed[4]);
		auction::start(what, am, currency, minbid, @p);
	} else if (string_left(parsed[0], 12) == "transferinv/" and parsed.length() > 1) {
		if (parsed[1] == "[cncel]") return;
		double amount = string_to_number(parsed[1]);
		parsed = string_split(parsed[0], "/", false);
		if (parsed[1] == p.name) {
			send_reliable(p, "What would be the point in transfering something to yourself? You already have it!", 0);
			return;
		}
		int index2 = get_player_index_from(parsed[1]);
		if (index2 < 0) {
			send_reliable(p, "player " + parsed[1] + " not found", 0);
			return;
		}
		if (p.inv_item_number(parsed[2]) >= amount) {
			if (p.distancecheck(players[index2].x, players[index2].y, players[index2].z) <= 5 and p.map == players[index2].map) {
				string[] adg = string_split(file_get_contents("notadg.svr").replace("\r\n", "\n"), "\n");
				int something = adg.find(parsed[2]);
				if (something > -1) {
					send_reliable(p, "You can't give " + parsed[2] + "", 2);
					return;
				}
				if (amount <= 0) {
					send_reliable(p, "An error has occured. Error region: item transfer. Error description: attempted to give non-positive number of item to a player", 2);
					return;
				}
				p.inv_add_item(parsed[2], -amount);
				players[index2].inv_add_item(parsed[2], amount);
				send_packet(6, "play invgive2.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
				send_reliable(p, "You have given " + amount + " " + parsed[2] + " to " + players[index2].nickname, 2);
				send_reliable(players[index2], p.nickname + " has given you " + amount + " " + parsed[2] + "!", 2);
				send_packet(6, "play get" + get_draw_and_get_sound(parsed[2]) + ".ogg " + players[index2].x + " " + players[index2].y + " " + players[index2].z, players[index2].x, players[index2].y, players[index2].z, maps[get_map_index(players[index2].map)]);
				log("give", p.nickname + " (" + p.name + ") gave " + amount + " " + parsed[2] + " to " + players[index2].nickname + " (" + players[index2].name + ")", true);
			} else {
				send_reliable(p, "Error: " + players[index2].name + " is too far away from you. You must be at least 5 tiles in range to give items", 0);
				return;
			}
		}
	} else if (parsed[0] == "inv" and parsed.length() >= 3)
		p.inv_add_item(parsed[1], string_to_number(parsed[2]));
	else if (parsed[0] == "invrequest") {
		send(p.peer_id, "inv " + p.inv.export(), 0);
		return;
	} else if (parsed[0] == "setinv" and parsed.length() > 1) {
		string items = event.replace(parsed[0] + " ", "", true);
		p.inv.import_inv(items);
		file f;
		f.open("chars/" + p.name + "/inv.usr", "w");
		f.write(items);
		f.close();
		send(p.peer_id, "inv " + items, 0);
		return;
	} else if (parsed[0] == "setinvname" && parsed.length() > 1) {
		string t = string_trimleft(event, (parsed[0] + " ").length());
		string[] lines = t.split(";");
		inventory a = p.inv;
		inventory b;
		for (uint i = 0; i < lines.length(); i++) {
			double v = a.get_item_amount(lines[i]);
			if (v < 1) continue;
			b.give(lines[i], v);
		}
		foreach (inventory_item@ l: a.items) {
			if (@l == null || l.amount < 1 || lines.find(l.name) > -1) continue;
			b.give(l.name, l.amount);
		}
		p.inv = b;
		writeto(p.name, "inv", b.export());
		send(p.peer_id, "inv " + b.export(), 0);
		return;
	} else if (parsed[0] == "giveitem" and parsed.length() > 1) {
		if (p.looker == "" and p.looking == "") {
			string item = parsed[1];
			double itemamount = p.inv_item_number(item);
			if (itemamount <= 0) {
				p.sendpacket("You dont' have any " + item + "", 0);
				return;
			}
			if (string_contains(parsed[1], "rocket_launcher", 1) != -1 or string_contains(parsed[1], "nak_nk100_decimater", 1) != -1) {
				send_reliable(p, "you can't give " + parsed[1] + "", 12);
				return;
			}
			string[] names;
			for (uint px = 0; px < players.length(); px += 1) {
				if (p.name == players[px].name) continue;
				if (players[px].distancecheck(p.x, p.y, p.z) <= 5 and players[px].map == p.map) names.insert_last(players[px].name);
			}
			if (names.length() <= 0) {
				p.sendpacket("There are no players near you", 0);
				return;
			}
			server_menu m;
			m.initial_packet = "playergive/" + item;
			m.intro = "players menu";
			for (uint i = 0; i < names.length(); i++)
				m.add(names[i], names[i]);
			m.send(p.peer_id);
		}
	} else if (string_left(parsed[0], 11) == "playergive/" and parsed.length() > 1) {
		parsed.insert_last(parsed[1]);
		parsed[1] = string_trim_left(parsed[0], 11);
		string n = parsed[2];
		if (n == "back") return;
		int index2 = get_player_index_from(parsed[2]);
		if (index2 < 0) {
			p.sendpacket("Player not found", 0);
			return;
		}
		int dist = players[index2].distancecheck(p.x, p.y, p.z);
		if (dist > 5 or players[index2].map != p.map) {
			p.sendpacket("This player is too far away", 0);
			return;
		}
		send_serverbox(p.peer_id, 2, -1, 1, -1, "transferinv/" + n + "/" + parsed[1], "How many " + parsed[1] + "s would you like to give to " + n + "?");
	} else if (parsed[0] == "mtester" and parsed.length() > 1) {
		string mapname = parsed[1];
		if (directory_exists("maps/" + mapname)) {
			p.finishtasktimer.restart();
			p.finishtasktimer.pause();
			move_player(p, mapname, 0, 0, 0, true);
		}
	} else if (parsed[0] == "mtester3" and parsed.length() > 1) {
		string mapname = parsed[1];
		if (directory_exists("maps/" + mapname)) {
			p.finishtasktimer.restart();
			p.finishtasktimer.pause();
			move_player(p, mapname, 0, 0, 0, true);
		}
	} else if (parsed[0] == "publicmapgo" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		if (!map_exists(parsed[1])) {
			send_reliable(p, "this map does not exists", 2);
			return;
		}
		int mi = get_map_index(parsed[1]);
		if ((mi > -1)) {
			if (TIME_HOUR<maps[mi].minhour or TIME_HOUR>maps[mi].maxhour) {
				send_reliable(p, "" + maps[mi].name + " is currently closed. Opening hours: " + maps[mi].minhour + " until " + maps[mi].maxhour + "", 2);
				return;
			}
			if ((maps[mi].minlevel > 0 && p.level<maps[mi].minlevel) || (maps[mi].maxlevel > 0 && p.level>maps[mi].maxlevel)) {
				send_reliable(p, "" + maps[mi].name + " is only for players with level range of " + maps[mi].minlevel + " until " + maps[mi].maxlevel + "", 2);
				return;
			}
			if ((maps[mi].minreinforcement > 0 && p.reinforcement<maps[mi].minreinforcement) || (maps[mi].maxreinforcement > 0 && p.reinforcement>maps[mi].maxreinforcement)) {
				send_reliable(p, "" + maps[mi].name + " is only for players with reinforcement range of " + maps[mi].minreinforcement + " until " + maps[mi].maxreinforcement + "", 2);
				return;
			}
			if (maps[mi].pvp == 1 and maps[mi].pvpminx <= p.x and maps[mi].pvpmaxx >= p.x and maps[mi].pvpminy <= p.y and maps[mi].pvpmaxy >= p.y and maps[mi].pvpminz <= p.z and maps[mi].pvpmaxz >= p.z) {
				if (p.pvp != 1) {
					p.pvp = 1;
					send_reliable(p, "You are now pvp!", 2);
					send_reliable(0, "play_s pvpon.ogg", 6);
					send_reliable(0, "" + p.nickname + " is now pvp!", 2);
				}
			} else if (maps[mi].pvp == 2 and maps[mi].pvpminx <= p.x and maps[mi].pvpmaxx >= p.x and maps[mi].pvpminy <= p.y and maps[mi].pvpmaxy >= p.y and maps[mi].pvpminz <= p.z and maps[mi].pvpmaxz >= p.z) {
				if (p.pvp != 0) {
					p.pvp = 0;
					send_reliable(p, "You are no longer pvp!", 2);
					send_reliable(0, "play_s pvpoff.ogg", 6);
					send_reliable(0, "" + p.nickname + " is no longer pvp!", 2);
				}
			}
			string s = "";
			string s2;
			if (maps[mi].owners.length() > 1) {
				for (uint i = 0; i < maps[mi].owners.length(); i++) {
					if (i == (maps[mi].owners.length() - 1)) s += "and " + maps[mi].owners[i] + ".";
					else s += maps[mi].owners[i] + ", ";
				}
			} else
				for (uint i = 0; i < maps[mi].owners.length(); i++)
					s = maps[mi].owners[i] + ".";
			if (maps[mi].owners.length() > 1) s2 = " " + maps[mi].owners.length() + " owners: ";
			else s2 = " " + maps[mi].owners.length() + " owner: ";
			move_player(p, parsed[1], random(maps[mi].spminx, maps[mi].spmaxx), random(maps[mi].spminy, maps[mi].spmaxy), random(maps[mi].spminz, maps[mi].spmaxz), true);
			bsend(0, "maps", "", p.nickname + " is now visiting the public map " + maps[mi].name + ", created by " + s2 + " " + s);
			p.finishtasktimer.restart();
		}
	} else if (parsed[0] == "taskgo" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		if (!map_exists(parsed[1])) {
			send_reliable(p, "this map does not exists", 2);
			return;
		}
		int mi = get_map_index(parsed[1]);
		if ((mi > -1)) {
			if (TIME_HOUR<maps[mi].minhour or TIME_HOUR>maps[mi].maxhour) {
				send_reliable(p, "" + maps[mi].name + " is currently closed. Opening hours: " + maps[mi].minhour + " until " + maps[mi].maxhour + "", 2);
				return;
			}
			if ((maps[mi].minlevel > 0 && p.level<maps[mi].minlevel) || (maps[mi].maxlevel > 0 && p.level>maps[mi].maxlevel)) {
				send_reliable(p, "" + maps[mi].name + " is only for players with level range of " + maps[mi].minlevel + " until " + maps[mi].maxlevel + "", 2);
				return;
			}
			if ((maps[mi].minreinforcement > 0 && p.reinforcement<maps[mi].minreinforcement) || (maps[mi].maxreinforcement > 0 && p.reinforcement>maps[mi].maxreinforcement)) {
				send_reliable(p, "" + maps[mi].name + " is only for players with reinforcement range of " + maps[mi].minreinforcement + " until " + maps[mi].maxreinforcement + "", 2);
				return;
			}
			int ind = get_player_index_from(p.looker);
			if (ind > -1) {
				p.looker = "";
				send_reliable(players[ind], "lookstop", 0);
				players[ind].looking = "";
				int newx = string_to_number(get_char_val(players[ind].name, "oldx"));
				int newy = string_to_number(get_char_val(players[ind].name, "oldy"));
				int newz = string_to_number(get_char_val(players[ind].name, "oldz"));
				string newmap = get_char_val(players[ind].name, "oldmap");
				if (map_exists(newmap) == false)
					newmap = "main";
				string charfolder = "chars/" + players[ind].name;
				file_delete(charfolder + "/oldx.usr");
				file_delete(charfolder + "/oldy.usr");
				file_delete(charfolder + "/oldz.usr");
				file_delete(charfolder + "/oldmap.usr");
				move_player(players[ind], newmap, newx, newy, newz);
				send_packet(6, "play toggleoff.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
				send_reliable(players[ind], "you've stopped looking at " + p.name + "", 2);
				send_reliable(p, "" + players[ind].name + " stopped watching you", 2);
			}
			if (maps[mi].pvp == 1 and maps[mi].pvpminx <= p.x and maps[mi].pvpmaxx >= p.x and maps[mi].pvpminy <= p.y and maps[mi].pvpmaxy >= p.y and maps[mi].pvpminz <= p.z and maps[mi].pvpmaxz >= p.z) {
				if (p.pvp != 1) {
					p.pvp = 1;
					send_reliable(p, "You are now pvp!", 2);
					send_reliable(0, "play_s pvpon.ogg", 6);
					send_reliable(0, "" + p.nickname + " is now pvp!", 2);
				}
			} else if (maps[mi].pvp == 2 and maps[mi].pvpminx <= p.x and maps[mi].pvpmaxx >= p.x and maps[mi].pvpminy <= p.y and maps[mi].pvpmaxy >= p.y and maps[mi].pvpminz <= p.z and maps[mi].pvpmaxz >= p.z) {
				if (p.pvp != 0) {
					p.pvp = 0;
					send_reliable(p, "You are no longer pvp!", 2);
					send_reliable(0, "play_s pvpoff.ogg", 6);
					send_reliable(0, "" + p.nickname + " is no longer pvp!", 2);
				}
			}
			string s = "";
			string s2;
			if (maps[mi].owners.length() > 1) {
				for (uint i = 0; i < maps[mi].owners.length(); i++) {
					if (i == (maps[mi].owners.length() - 1)) s += "and " + maps[mi].owners[i] + ".";
					else s += maps[mi].owners[i] + ", ";
				}
			} else
				for (uint i = 0; i < maps[mi].owners.length(); i++)
					s = maps[mi].owners[i] + ".";
			if (maps[mi].owners.length() > 1) s2 = " " + maps[mi].owners.length() + " owners: ";
			else s2 = " " + maps[mi].owners.length() + " owner: ";
			move_player(p, parsed[1], random(maps[mi].spminx, maps[mi].spmaxx), random(maps[mi].spminy, maps[mi].spmaxy), random(maps[mi].spminz, maps[mi].spmaxz), true);
			bsend(0, "maps", "", p.nickname + " is now trying to complete task " + maps[mi].name + ". Reward: " + maps[mi].finishamount + " " + maps[mi].finishitem + ". Created by " + s2 + " " + s);
			p.finishtasktimer.restart();
		}
	} else if (parsed[0] == "mapgo" and parsed.length() > 1) {
		if (parsed[1] == "[back]") {
			p.sendpacket("canceled", 0);
			return;
		}
		if (!map_exists(parsed[1])) {
			send_reliable(p, "this map does not exists", 2);
			return;
		}
		string[] a = string_split(file_get_contents("pbmaps.svr").replace("\r\n", "\n"), "\n");
		int something = a.find(parsed[1]);
		if (something > -1) {
			send_reliable(p, "you can only go to this map from the public maps menu!", 2);
			return;
		}
		string[] a2 = string_split(file_get_contents("chmaps.svr").replace("\r\n", "\n"), "\n");
		int something2 = a2.find(parsed[1]);
		if (something2 > -1) {
			send_reliable(p, "you can only go to this map from the task maps menu!", 2);
			return;
		}
		int mi = get_map_index(parsed[1]);
		if ((mi > -1)) {
			int ind = get_player_index_from(p.looker);
			if (ind > -1) {
				p.looker = "";
				send_reliable(players[ind], "lookstop", 0);
				players[ind].looking = "";
				int newx = string_to_number(get_char_val(players[ind].name, "oldx"));
				int newy = string_to_number(get_char_val(players[ind].name, "oldy"));
				int newz = string_to_number(get_char_val(players[ind].name, "oldz"));
				string newmap = get_char_val(players[ind].name, "oldmap");
				if (map_exists(newmap) == false)
					newmap = "main";
				string charfolder = "chars/" + players[ind].name;
				file_delete(charfolder + "/oldx.usr");
				file_delete(charfolder + "/oldy.usr");
				file_delete(charfolder + "/oldz.usr");
				file_delete(charfolder + "/oldmap.usr");
				move_player(players[ind], newmap, newx, newy, newz);
				send_packet(6, "play toggleoff.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
				send_reliable(players[ind], "you've stopped looking at " + p.name + "", 2);
				send_reliable(p, "" + players[ind].name + " stopped watching you", 2);
			}
			if (maps[mi].pvp == 1 and maps[mi].pvpminx <= p.x and maps[mi].pvpmaxx >= p.x and maps[mi].pvpminy <= p.y and maps[mi].pvpmaxy >= p.y and maps[mi].pvpminz <= p.z and maps[mi].pvpmaxz >= p.z) {
				if (p.pvp != 1) {
					p.pvp = 1;
					send_reliable(p, "You are now pvp!", 2);
					send_reliable(0, "play_s pvpon.ogg", 6);
					send_reliable(0, "" + p.nickname + " is now pvp!", 2);
				}
			} else if (maps[mi].pvp == 2 and maps[mi].pvpminx <= p.x and maps[mi].pvpmaxx >= p.x and maps[mi].pvpminy <= p.y and maps[mi].pvpmaxy >= p.y and maps[mi].pvpminz <= p.z and maps[mi].pvpmaxz >= p.z) {
				if (p.pvp != 0) {
					p.pvp = 0;
					send_reliable(p, "You are no longer pvp!", 2);
					send_reliable(0, "play_s pvpoff.ogg", 6);
					send_reliable(0, "" + p.nickname + " is no longer pvp!", 2);
				}
			}
			move_player(p, parsed[1], random(maps[mi].spminx, maps[mi].spmaxx), random(maps[mi].spminy, maps[mi].spmaxy), random(maps[mi].spminz, maps[mi].spmaxz), true);
			p.finishtasktimer.restart();
		}
	} else if (parsed[0] == "fists") {
		if (parsed[0] != p.weapon_name) {
			p.weapon_name = parsed[0];
			if (p.weapon_ammos > 0)
				p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
			p.firetimer = 180;
			p.weapon_ammos = 0;
			p.weapon_ammo_type = "";
			p.weapon_copasity = 0;
			send_reliable(p, "notrapid", 0);
		}
	} else if (parsed[0] == "feet") {
		if (parsed[0] != p.weapon_name) {
			p.weapon_name = parsed[0];
			if (p.weapon_ammos > 0)
				p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
			p.firetimer = 220;
			p.weapon_ammos = 0;
			p.weapon_ammo_type = "";
			p.weapon_copasity = 0;
			send_reliable(p, "notrapid", 0);
		}
	} else if (parsed[0] == "splay")
		send_packet(6, "play draw" + get_draw_and_get_sound(parsed[2]) + ".ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
	else if (parsed[0] == "lcm" and parsed.length() > 1) {
		if (p.ds.find("chat") > -1) {
			send_reliable(p, "your chats have been disabled", 0);
			return;
		}
		if (p.away == true and string_replace(get_event_message(), parsed[0] + " ", "", true) != "/afk" and !p.is_admin() == false) {
			send_reliable(p, "You can't chat while you are away", 2);
			return;
		}
		if (chatting == 0) {
			string message;
			message = "Sorry, server chats are currently disabled.";
			if (p.is_admin()) message += " If you want to turn them back on, type /varset chatting 1";
			send_reliable(p, message, 2);
			return;
		}
		p.chats += 1;
		log(p.name + "_chats", "LCM chat on " + p.langchan + " from " + p.name + ": " + string_replace(get_event_message(), parsed[0] + " ", "", true), true);
		string mensagem;
		if (p.teamname != "") mensagem += team_name(p.teamname) + " ";
		if (p.prisontitle != "") mensagem += p.prisontitle + " ";
		if (p.newbtitle != "") mensagem += p.newbtitle + " ";
		if (p.pvptitle != "") mensagem += p.pvptitle + " ";
		mensagem += p.nickname + " said in the lcm chat: " + string_replace(get_event_message(), parsed[0] + " ", "", false);
		for (uint i = 0; i < players.length(); i++) {
			if (players[i].in_lcm) {
				send_reliable(players[i], "play_s notify_google3.ogg", 6);
				send_reliable(players[i], "lcmchat " + mensagem, 0);
			}
		}
	} else if (parsed[0] == "adm" and parsed.length() > 1) {
		if (p.ds.find("chat") > -1) {
			send_reliable(p, "your chats have been disabled", 0);
			return;
		}
		if (p.away == true and string_replace(get_event_message(), parsed[0] + " ", "", true) != "/afk" and !p.is_admin() == false) {
			send_reliable(p, "You can't chat while you are away", 2);
			return;
		}
		if (chatting == 0) {
			string message;
			message = "Sorry, server chats are currently disabled.";
			if (p.is_admin()) message += " If you want to turn them back on, type /varset chatting 1";
			send_reliable(p, message, 2);
			return;
		}
		p.chats += 1;
		log(p.name + "_chats", "Admin chat from " + p.name + ": " + string_replace(get_event_message(), parsed[0] + " ", "", true), true);
		string mensagem;
		if (p.teamname != "") mensagem += team_name(p.teamname) + " ";
		if (p.prisontitle != "") mensagem += p.prisontitle + " ";
		if (p.newbtitle != "") mensagem += p.newbtitle + " ";
		if (p.pvptitle != "") mensagem += p.pvptitle + " ";
		if (p.jobtitle != "") mensagem += p.jobtitle + " ";
		mensagem += p.nickname + " said in the admin chat: " + string_replace(get_event_message(), parsed[0] + " ", "", false);
		for (uint i = 0; i < players.length(); i++) {
			if (players[i].is_admin()) {
				send_reliable(players[i], "play_s notifybleep.ogg", 6);
				send_reliable(players[i], "adminchat " + mensagem, 0);
			}
		}
	} else if (parsed[0] == "devc" and parsed.length() > 1) {
		if (p.ds.find("chat") > -1) {
			send_reliable(p, "your chats have been disabled", 0);
			return;
		}
		if (p.away == true and string_replace(get_event_message(), parsed[0] + " ", "", true) != "/afk" and !p.is_admin() == false) {
			send_reliable(p, "You can't chat while you are away", 2);
			return;
		}
		if (chatting == 0) {
			string message;
			message = "Sorry, server chats are currently disabled.";
			if (p.is_admin()) message += " If you want to turn them back on, type /varset chatting 1";
			send_reliable(p, message, 2);
			return;
		}
		p.chats += 1;
		log(p.name + "_chats", "Developer chat from " + p.name + ": " + string_replace(get_event_message(), parsed[0] + " ", "", true), true);
		string mensagem;
		if (p.teamname != "") mensagem += team_name(p.teamname) + " ";
		if (p.prisontitle != "") mensagem += p.prisontitle + " ";
		if (p.newbtitle != "") mensagem += p.newbtitle + " ";
		if (p.pvptitle != "") mensagem += p.pvptitle + " ";
		if (p.jobtitle != "") mensagem += p.jobtitle + " ";
		mensagem += p.nickname + " said in the developers chat: " + string_replace(get_event_message(), parsed[0] + " ", "", false);
		for (uint i = 0; i < players.length(); i++) {
			if (players[i].is_dev()) {
				send_reliable(players[i], "play_s notify_google1.ogg", 6);
				send_reliable(players[i], "devchat " + mensagem, 0);
			}
		}
	} else if (parsed[0] == "manager" and parsed.length() > 1) {
		if (p.ds.find("chat") > -1) {
			send_reliable(p, "your chats have been disabled", 0);
			return;
		}
		if (p.away == true and string_replace(get_event_message(), parsed[0] + " ", "", true) != "/afk" and !p.is_admin() == false) {
			send_reliable(p, "You can't chat while you are away", 2);
			return;
		}
		if (chatting == 0) {
			string message;
			message = "Sorry, server chats are currently disabled.";
			if (p.is_admin()) message += " If you want to turn them back on, type /varset chatting 1";
			send_reliable(p, message, 2);
			return;
		}
		p.chats += 1;
		log(p.name + "_chats", "Manager chat from " + p.name + ": " + string_replace(get_event_message(), parsed[0] + " ", "", true), true);
		string mensagem;
		if (p.teamname != "") mensagem += team_name(p.teamname) + " ";
		if (p.prisontitle != "") mensagem += p.prisontitle + " ";
		if (p.newbtitle != "") mensagem += p.newbtitle + " ";
		if (p.pvptitle != "") mensagem += p.pvptitle + " ";
		if (p.jobtitle != "") mensagem += p.jobtitle + " ";
		mensagem += p.nickname + " said in the manager chat: " + string_replace(get_event_message(), parsed[0] + " ", "", false);
		for (uint i = 0; i < players.length(); i++) {
			if (players[i].is_manager()) {
				send_reliable(players[i], "play_s notify7.ogg", 6);
				send_reliable(players[i], "managerchat " + mensagem, 0);
			}
		}
	} else if (parsed[0] == "partnerchat") {
		if (p.partner != "")
			send_reliable(p, "ispartnerchat", 0);
	} else if (parsed[0] == "partnerchat2" and parsed.length() > 1) {
		if (p.ds.find("chat") > -1) {
			send_reliable(p, "your chats have been disabled", 0);
			return;
		}
		if (p.away == true and string_replace(get_event_message(), parsed[0] + " ", "", true) != "/afk" and !p.is_admin() == false) {
			send_reliable(p, "You can't chat while you are away", 2);
			return;
		}
		if (chatting == 0) {
			string message;
			message = "Sorry, server chats are currently disabled.";
			if (p.is_admin()) message += " If you want to turn them back on, type /varset chatting 1";
			send_reliable(p, message, 2);
			return;
		}
		p.chats += 1;
		log(p.name + "_chats", "Partner chat from " + p.name + ": " + string_replace(get_event_message(), parsed[0] + " ", "", true), true);
		string mensagem = "Partner chat from ";
		if (p.prisontitle != "") mensagem += p.prisontitle + " ";
		if (p.newbtitle != "") mensagem += p.newbtitle + " ";
		if (p.pvptitle != "") mensagem += p.pvptitle + " ";
		if (p.jobtitle != "") mensagem += p.jobtitle + " ";
		mensagem = p.nickname + ": " + string_replace(get_event_message(), parsed[0] + " ", "", false);
		int ind = get_player_index_from(p.partner);
		if (ind > -1) {
			send_reliable(p, "play_s notify_google2.ogg", 6);
			send_reliable(p, "partnerchat " + mensagem, 0);
			send_reliable(players[ind], "play_s notify_google2.ogg", 6);
			send_reliable(players[ind], "partnerchat " + mensagem, 0);
		}
	} else if (parsed[0] == "voice" and parsed.length() > 2)
		send_packet(0, get_event_message(), p.x, p.y, p.z, maps[get_map_index(p.map)]);
	else if (parsed[0] == "getmapnames") {
		string[] mapnames = find_directories("maps/*");
		string output;
		for (uint i = 0; i < mapnames.length(); i++)
			output += mapnames[i] + " ";
		send_reliable(p, "mapnamesare " + output, 0);
	} else if (parsed[0] == "getmap") {
		file f;
		f.open("maps/" + parsed[1].replace(".map", "") + "/!.map", "rb");
		send_reliable(p, "mapcontents " + f.read(), 0);
		f.close();
	} else if (parsed[0] == "lchannel") {
		server_menu menu;
		menu.intro = "Select a new language channel";
		menu.initial_packet = "lchannelset";
		menu.add("Disable Chat", "disable_chat");
		menu.add("Free Channel", "free_channel");
		json j;
		j.loadf("languages.json");
		string[] k = j.get_keys();
		if (k.length() > 0) {
			for (uint i = 0; i < k.length(); i++) {
				if (!j.is_object(k[i])) continue;
				json_object@ l = j.get(k[i]);
				if (@l == null) continue;
				menu.add(l("name") + " (" + l("native") + ")", l("name"));
			}
		}
		menu.add("password protected channels", "ppc");
		menu.send(e.peer_id);
	} else if (parsed[0] == "lchannelset" and parsed.length() > 1) {
		string t = string_trimleft(event, (parsed[0] + " ").length());
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		if (parsed[1] == "ppc") {
			server_menu2 menu;
			menu.intro = "Select a new password protected language channel";
			menu.initial_packet = "ppchannels";
			for (uint i = 0; i < ps_language_channels.length(); i++) {
				string[] ld = string_split(ps_language_channels[i], ":", false);
				menu.add(ld[0], ld[0]);
			}
			menu.send(e.peer_id);
		} else if (parsed[1] == "disable_chat") {
			p.langchan = parsed[1];
			p.sendpacket("done", 0);
		} else {
			for (uint i = 0; i < players.length(); i += 1) {
				if (players[i].langchan == p.langchan and players[i].name != p.name)
					bsend(players[i].peer_id, "channel messages", "notify_google4" + sndtype, p.name + " went out of this channel");
			}
			p.langchan = t;
			p.sendpacket("Using " + p.langchan + " as the new language channel", 0);
			if (p.lcm) send(p.peer_id, "islcm", 0);
			for (uint i = 0; i < players.length(); i += 1) {
				if (players[i].langchan == p.langchan and players[i].name != p.name)
					bsend(players[i].peer_id, "channel messages", "notify_blips" + sndtype, p.name + " entered this channel");
			}
		}
	} else if (parsed[0] == "ppchannels" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		send_serverbox(p.peer_id, 0, -1, -1, -1, "channelpass/" + parsed[1], "Enter password");
	} else if (string_left(parsed[0], 12) == "channelpass/" and parsed.length() > 1) {
		if (parsed[1] == "[cncel]") return;
		string pass = parsed[1];
		parsed = string_split(parsed[0], "/", false);
		for (uint i = 0; i < ps_language_channels.length(); i++) {
			if (parsed[1] + ":" + pass == ps_language_channels[i]) {
				for (uint i = 0; i < players.length(); i += 1) {
					if (players[i].langchan == p.langchan and players[i].name != p.name)
						bsend(players[i].peer_id, "channel messages", "notify_google4" + sndtype, p.name + " went out of this channel");
				}
				string[] ld = string_split(ps_language_channels[i], ":", false);
				p.langchan = ld[0];
				p.sendpacket("done", 0);
				for (uint i = 0; i < players.length(); i += 1) {
					if (players[i].langchan == p.langchan and players[i].name != p.name)
						bsend(players[i].peer_id, "channel messages", "notify_blips" + sndtype, p.name + " entered this channel");
				}
			}
		}
	} else if (parsed[0] == "lchannelset2" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			if (p.smartphoneon == 0) {
				send_reliable(p, "your phone is off", 0);
				return;
			}
			server_menu m;
			m.intro = "one UI home";
			m.initial_packet = "smartphoneenter";
			if (p.langchan == "" or p.age == 0 or p.country == "" or p.day == 0 or p.month == 0 or p.year == 0) m.add("complete your profile", "yourprofile");
			else {
				m.add("check battery level", "charge");
				m.add("phone", "phone");
				m.add("messages", "msg");
				m.add("apps", "apps");
				m.add("properties menu", "properties");
			}
			m.send(p.peer_id);
		} else if (parsed[1] == "ppc") {
			server_menu menu;
			menu.intro = "Select a new password protected language channel";
			menu.initial_packet = "ppchannels2";
			for (uint i = 0; i < ps_language_channels.length(); i++) {
				string[] ld = string_split(ps_language_channels[i], "=", false);
				menu.add(ld[0], ld[0]);
			}
			menu.send(e.peer_id);
		} else {
			p.langchan = parsed[1];
			p.sendpacket("Using " + p.langchan + " as the new language channel", 0);
			if (p.smartphoneon == 0) {
				send_reliable(p, "your phone is off", 0);
				return;
			}
			server_menu m;
			m.intro = "one UI home";
			m.initial_packet = "smartphoneenter";
			if (p.langchan == "" or p.age == 0 or p.country == "" or p.day == 0 or p.month == 0 or p.year == 0) m.add("complete your profile", "yourprofile");
			else {
				m.add("check battery level", "charge");
				m.add("phone", "phone");
				m.add("messages", "msg");
				m.add("apps", "apps");
				m.add("properties menu", "properties");
			}
			m.send(p.peer_id);
		}
	} else if (parsed[0] == "ppchannels" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		send_serverbox(p.peer_id, 2, -1, -1, -1, "channelpass", "Enter password");
	} else if (parsed[0] == "channelpass" and parsed.length() > 1) {
		if (parsed[1] == "[cncel]") {
			send_reliable(p, "canceled", 2);
			if (p.smartphoneon == 0) {
				send_reliable(p, "your phone is off", 0);
				return;
			}
			server_menu m;
			m.intro = "one UI home";
			m.initial_packet = "smartphoneenter";
			if (p.langchan == "" or p.age == 0 or p.country == "" or p.day == 0 or p.month == 0 or p.year == 0) m.add("complete your profile", "yourprofile");
			else {
				m.add("check battery level", "charge");
				m.add("phone", "phone");
				m.add("messages", "msg");
				m.add("apps", "apps");
				m.add("properties menu", "properties");
			}
			m.send(p.peer_id);
		} else {
			string pass = parsed[1];
			for (uint i = 0; i < ps_language_channels.length(); i++) {
				string[] ld = string_split(ps_language_channels[i], "=", false);
				int something = ld.find(pass);
				if (something > -1) {
					p.langchan = ld[0];
					p.sendpacket("done", 0);
					if (p.smartphoneon == 0) {
						send_reliable(p, "your phone is off", 0);
						return;
					}
					server_menu m;
					m.intro = "one UI home";
					m.initial_packet = "smartphoneenter";
					if (p.langchan == "" or p.age == 0 or p.country == "" or p.day == 0 or p.month == 0 or p.year == 0) m.add("complete your profile", "yourprofile");
					else {
						m.add("check battery level", "charge");
						m.add("phone", "phone");
						m.add("messages", "msg");
						m.add("apps", "apps");
						m.add("properties menu", "properties");
					}
					m.send(p.peer_id);
				}
			}
		}
	} else if (parsed[0] == "ageset" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			if (p.smartphoneon == 0) {
				send_reliable(p, "your phone is off", 0);
				return;
			}
			server_menu m;
			m.intro = "one UI home";
			m.initial_packet = "smartphoneenter";
			if (p.langchan == "" or p.age == 0 or p.country == "" or p.day == 0 or p.month == 0 or p.year == 0) m.add("complete your profile", "yourprofile");
			else {
				m.add("check battery level", "charge");
				m.add("phone", "phone");
				m.add("messages", "msg");
				m.add("apps", "apps");
				m.add("properties menu", "properties");
			}
			m.send(p.peer_id);
		} else {
			//p.age = string_to_number(parsed[1]);
			p.sendpacket("You are " + p.age + " years old!", 0);
			if (p.smartphoneon == 0) {
				send_reliable(p, "your phone is off", 0);
				return;
			}
			server_menu m;
			m.intro = "one UI home";
			m.initial_packet = "smartphoneenter";
			if (p.langchan == "" or p.age == 0 or p.country == "" or p.day == 0 or p.month == 0 or p.year == 0) m.add("complete your profile", "yourprofile");
			else {
				m.add("check battery level", "charge");
				m.add("phone", "phone");
				m.add("messages", "msg");
				m.add("apps", "apps");
				m.add("properties menu", "properties");
			}
			m.send(p.peer_id);
		}
	} else if (parsed[0] == "dayset" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			if (p.smartphoneon == 0) {
				send_reliable(p, "your phone is off", 0);
				return;
			}
			server_menu m;
			m.intro = "one UI home";
			m.initial_packet = "smartphoneenter";
			if (p.langchan == "" or p.age == 0 or p.country == "" or p.day == 0 or p.month == 0 or p.year == 0) m.add("complete your profile", "yourprofile");
			else {
				m.add("check battery level", "charge");
				m.add("phone", "phone");
				m.add("messages", "msg");
				m.add("apps", "apps");
				m.add("properties menu", "properties");
			}
			m.send(p.peer_id);
		} else {
			p.day = string_to_number(parsed[1]);
			p.sendpacket("done, go and set your month of birth now", 0);
			if (p.smartphoneon == 0) {
				send_reliable(p, "your phone is off", 0);
				return;
			}
			server_menu m;
			m.intro = "one UI home";
			m.initial_packet = "smartphoneenter";
			if (p.langchan == "" or p.age == 0 or p.country == "" or p.day == 0 or p.month == 0 or p.year == 0) m.add("complete your profile", "yourprofile");
			else {
				m.add("check battery level", "charge");
				m.add("phone", "phone");
				m.add("messages", "msg");
				m.add("apps", "apps");
				m.add("properties menu", "properties");
			}
			m.send(p.peer_id);
		}
	} else if (parsed[0] == "monthset" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			if (p.smartphoneon == 0) {
				send_reliable(p, "your phone is off", 0);
				return;
			}
			server_menu m;
			m.intro = "one UI home";
			m.initial_packet = "smartphoneenter";
			if (p.langchan == "" or p.age == 0 or p.country == "" or p.day == 0 or p.month == 0 or p.year == 0) m.add("complete your profile", "yourprofile");
			else {
				m.add("check battery level", "charge");
				m.add("phone", "phone");
				m.add("messages", "msg");
				m.add("apps", "apps");
				m.add("properties menu", "properties");
			}
			m.send(p.peer_id);
		} else {
			p.month = string_to_number(parsed[1]);
			p.sendpacket("done, go and set your year of birth now", 0);
			if (p.smartphoneon == 0) {
				send_reliable(p, "your phone is off", 0);
				return;
			}
			server_menu m;
			m.intro = "one UI home";
			m.initial_packet = "smartphoneenter";
			if (p.langchan == "" or p.age == 0 or p.country == "" or p.day == 0 or p.month == 0 or p.year == 0) m.add("complete your profile", "yourprofile");
			else {
				m.add("check battery level", "charge");
				m.add("phone", "phone");
				m.add("messages", "msg");
				m.add("apps", "apps");
				m.add("properties menu", "properties");
			}
			m.send(p.peer_id);
		}
	} else if (parsed[0] == "yearset" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			if (p.smartphoneon == 0) {
				send_reliable(p, "your phone is off", 0);
				return;
			}
			server_menu m;
			m.intro = "one UI home";
			m.initial_packet = "smartphoneenter";
			if (p.langchan == "" or p.age == 0 or p.country == "" or p.day == 0 or p.month == 0 or p.year == 0) m.add("complete your profile", "yourprofile");
			else {
				m.add("check battery level", "charge");
				m.add("phone", "phone");
				m.add("messages", "msg");
				m.add("apps", "apps");
				m.add("properties menu", "properties");
			}
			m.send(p.peer_id);
		} else {
			p.year = string_to_number(parsed[1]);
			p.sendpacket("You are borned on " + p.year + "!", 0);
			if (p.smartphoneon == 0) {
				send_reliable(p, "your phone is off", 0);
				return;
			}
			server_menu m;
			m.intro = "one UI home";
			m.initial_packet = "smartphoneenter";
			if (p.langchan == "" or p.age == 0 or p.country == "" or p.day == 0 or p.month == 0 or p.year == 0) m.add("complete your profile", "yourprofile");
			else {
				m.add("check battery level", "charge");
				m.add("phone", "phone");
				m.add("messages", "msg");
				m.add("apps", "apps");
				m.add("properties menu", "properties");
			}
			m.send(p.peer_id);
		}
	} else if (parsed[0] == "countryset" and parsed.length() > 1) {
		string t = string_trimleft(event, (parsed[0] + " ").length());
		if (parsed[1] == "[back]") {
			p.sendpacket("canceled", 0);
			if (p.smartphoneon == 0) {
				send_reliable(p, "your phone is off", 0);
				return;
			}
			server_menu m;
			m.intro = "one UI home";
			m.initial_packet = "smartphoneenter";
			if (p.langchan == "" or p.age == 0 or p.country == "" or p.day == 0 or p.month == 0 or p.year == 0) m.add("complete your profile", "yourprofile");
			else {
				m.add("check battery level", "charge");
				m.add("phone", "phone");
				m.add("messages", "msg");
				m.add("apps", "apps");
				m.add("properties menu", "properties");
			}
			m.send(p.peer_id);
		} else {
			p.country = t;
			p.sendpacket("You are from " + p.country + "!", 0);
			if (p.smartphoneon == 0) {
				send_reliable(p, "your phone is off", 0);
				return;
			}
			server_menu m;
			m.intro = "one UI home";
			m.initial_packet = "smartphoneenter";
			if (p.langchan == "" or p.age == 0 or p.country == "" or p.day == 0 or p.month == 0 or p.year == 0) m.add("complete your profile", "yourprofile");
			else {
				m.add("check battery level", "charge");
				m.add("phone", "phone");
				m.add("messages", "msg");
				m.add("apps", "apps");
				m.add("properties menu", "properties");
			}
			m.send(p.peer_id);
		}
	} else if (parsed[0] == "playermapmenu") {
		int x;
		int y;
		int z;
		string finaltext = "playermapmenu ";
		int ind = get_player_index(e.peer_id);
		string n = "";
		if (ind > -1) {
			n = players[ind].name;
			x = players[ind].x;
			y = players[ind].y;
			z = players[ind].z;
			string[] playernames = nearest_player_sorted_array(players[ind]);
			finaltext += linear(playernames);
			if (finaltext == "playermapmenu ")
				finaltext = "Just you are in this map";
			send_reliable(p, finaltext, 0);
		}
	} else if (parsed[0] == "playermenu") {
		int x;
		int y;
		int z;
		string finaltext = "playermenu ";
		int ind = get_player_index(e.peer_id);
		string n = "";
		if (ind > -1) {
			n = players[ind].name;
			x = players[ind].x;
			y = players[ind].y;
			z = players[ind].z;
			string[] playernames = nearest_player_sorted_arrayto(players[ind]);
			finaltext += linear(playernames);
			send_reliable(p, finaltext, 0);
		}
	} else if (parsed[0] == "copy") {
		string text = string_replace(get_event_message(), "copy ", "", false);
		if (text == "" or text == "back") {
			send_reliable(p, "canceled", 0);
			return;
		}
		p.sendpacket("copyed to clipboard", 0);
		send_reliable(p, "clip " + text, 0);
	} else if (parsed[0] == "createAI" and parsed.length() > 1) {
		string[] colon = string_split(parsed[1], ":", false);
		if (file_exists("ais/" + colon[0] + ".ai") == true) {
			send_reliable(p, "this name already exists", 2);
			return;
		}
		file f;
		f.open("ais/" + colon[0] + ".ai", "wb");
		f.write("name=" + colon[0] + "\nhealth=" + colon[1] + "\nrange=" + colon[2] + "\ndamage=" + colon[3] + "\nshoottime=" + colon[4] + "\nspeed=" + colon[5] + "\nxp=" + colon[6] + "\nstepsound=" + colon[7] + "\nstepsoundpitch=" + colon[8] + "\nstepsoundvolume=" + colon[9] + "\npainsound=" + colon[10] + "\npainsoundpitch=" + colon[11] + "\npainsoundvolume=" + colon[12] + "\nkillsound=" + colon[13] + "\nkillsoundpitch=" + colon[14] + "\nkillsoundvolume=" + colon[15] + "\nshootsound=" + colon[16] + "\nshootsoundpitch=" + colon[17] + "\nshootsoundvolume=" + colon[18] + "\nhitsound=" + colon[19] + "\nhitsoundpitch=" + colon[20] + "\nhitsoundvolume=" + colon[21] + "\nvoice=" + colon[22] + "\nvoicepitch=" + colon[23] + "\nvoicevolume=" + colon[24] + "\nvoicetime=" + colon[25] + "\nitem=" + colon[26] + "\namount=" + colon[27] + "\nrapidvoice=" + colon[28] + "\ntreeclimb=" + colon[29] + "\nmaddable=" + colon[30] + "\nneedwater=" + colon[31] + "\nfall=" + colon[32] + "\nfallsoundpitch=" + colon[33] + "\nfallsoundvolume=" + colon[34] + "\nnuclearbomb=" + colon[35] + "\nmine=" + colon[36] + "\ngender=" + colon[37]);
		f.close();
		for (uint i2 = 0; i2 < ais.length(); i2++) {
			if (ais[i2].voice != "" and ais[i2].rapidvoice == true) destroy_moving_sound(ais[i2].voice);
			ais.remove_at(i2);
			continue;
		}
		load_ais();
		send_reliable(p, "done", 2);
	} else if (parsed[0] == "createfad" and parsed.length() > 1) {
		string[] colon = string_split(parsed[1], ":", false);
		if (file_exists("foods_and_drinks/" + colon[0] + ".fad") == true) {
			send_reliable(p, "this name already exists", 2);
			return;
		}
		file f;
		f.open("foods_and_drinks/" + colon[0] + ".fad", "wb");
		f.write("" + colon[1] + ":" + colon[2] + ":" + colon[3] + ":" + colon[4] + ":" + colon[5] + "");
		f.close();
		send_reliable(p, "done", 2);
	} else if (parsed[0] == "createdrawsounds" and parsed.length() > 1) {
		string[] colon = string_split(parsed[1], "=", false);
		file_put_contents("drawsounds.svr", "" + colon[0] + "=" + colon[1] + "\n", 255);
		send_reliable(p, "done", 2);
	} else if (parsed[0] == "createitemusagelimit" and parsed.length() > 1) {
		file_put_contents("notadg.svr", "" + parsed[1] + "\n", 255);
		send_reliable(p, "done", 2);
	} else if (parsed[0] == "buildobj" and parsed.length() > 1) {
		string what = parsed[1];
		if (what == "back" || what == "[back]") return;
		else if (what == "desc_menu") {
			if (p.assistant)
				send_menu(p.peer_id, "item descriptions menu", "item_desc_menu", "add a description:add_desc[]edit a description:edit_desc[]remove a description:remove_desc[]view a description:view_desc");
			return;
		}
		file f;
		int mapindex = get_map_index(p.map);
		if (mapindex > -1) {
			{
				if (maps[mapindex].owners.find(p.name) > -1 or maps[mapindex].owners.find(p.partner) > -1 or p.is_admin()) {
					if (what == "tile")
						send_reliable(p, "buildtile", 0);
					else if (what == "zone")
						send_reliable(p, "buildzone", 0);
					else if (what == "safezone")
						send_reliable(p, "buildsafezone", 0);
					else if (what == "bed")
						send_reliable(p, "buildbed", 0);
					else if (what == "clock")
						send_reliable(p, "buildclock", 0);
					else if (what == "calendar")
						send_reliable(p, "buildcalendar", 0);
					else if (what == "oven")
						send_reliable(p, "buildoven", 0);
					else if (what == "src")
						send_reliable(p, "buildsrc", 0);
					else if (what == "reverb")
						send_reliable(p, "buildreverb", 0);
					else if (what == "dmg")
						send_reliable(p, "builddmg", 0);
					else if (what == "music")
						send_reliable(p, "buildmusic", 0);
					else if (what == "txt")
						send_reliable(p, "buildtxt", 0);
					else if (what == "dialog")
						send_reliable(p, "builddialog", 0);
					else if (what == "automatic_dialog")
						send_reliable(p, "buildautomatic_dialog", 0);
					else if (what == "timedtext")
						send_reliable(p, "buildtimedtext", 0);
					else if (what == "timedsound")
						send_reliable(p, "buildtimedsound", 0);
					else if (what == "timedmusic")
						send_reliable(p, "buildtimedmusic", 0);
					else if (what == "timedamb")
						send_reliable(p, "buildtimedamb", 0);
					else if (what == "item")
						send_reliable(p, "builditem", 0);
					else if (what == "item_usage_restriction")
						send_reliable(p, "builditem_usage_restriction", 0);
					else if (what == "AI") {
						if (p.is_admin())
							send_menu(p.peer_id, "ai menu", "bAI", "create AI:createAI[]edit AI:editAI[]remove AI:removeAI[]remove AI line:removeAIline[]spawn AI:spawnAI");
					} else if (what == "drawsounds") {
						if (p.is_admin())
							send_menu(p.peer_id, "draw sounds menu", "bdrawsounds", "new draw sound:createdrawsound[]edit draw sound:editdrawsound[]remove draw sound:removedrawsoundline");
					} else if (what == "itemusagelimit") {
						if (p.is_admin())
							send_menu(p.peer_id, "item usage limits menu", "bitemusagelimit", "new item usage limit:createitemusagelimit[]edit item usage limit:edititemusagelimit[]remove item usage limit:removeitemusagelimitline");
					} else if (what == "fad") {
						if (p.is_admin())
							send_menu(p.peer_id, "foods and drinks menu", "bfad", "create food or drink:fad[]edit food or drink:editfad[]remove food or drink:removefad");
					} else if (what == "amb")
						send_reliable(p, "buildamb", 0);
					else if (what == "newmap")
						send_reliable(p, "buildnewmap", 0);
					else if (what == "deletemap") {
						string m = "yes:yes[]no:no";
						send_menu(p.peer_id, "are you sure you'd like to delete this map?", "delmap", m);
					} else if (what == "sign")
						send_reliable(p, "buildsign", 0);
					else if (what == "url")
						send_reliable(p, "buildurl", 0);
					else if (what == "vanishing_platform")
						send_reliable(p, "buildvanishing_platform", 0);
					else if (what == "hazard")
						send_reliable(p, "buildhazard", 0);
					else if (what == "teleporter")
						send_reliable(p, "buildteleporter", 0);
					else if (what == "forcefield")
						send_reliable(p, "buildforcefield", 0);
					else if (what == "opening_hours")
						send_reliable(p, "buildopening_hours", 0);
					else if (what == "level")
						send_reliable(p, "buildlevel", 0);
					else if (what == "reinforcement")
						send_reliable(p, "buildreinforcement", 0);
					else if (what == "door") {
						if (p.is_admin())
							send_menu(p.peer_id, "Door menu", "bdoor", "door:door[]password protected door:pdoor[]item checker door:icdoor[]item taker door:itdoor[]item giver door:igdoor");
						else
							send_menu(p.peer_id, "Door menu", "bdoor", "door:door[]password protected door:pdoor[]item checker door:icdoor[]item taker door:itdoor");
					} else if (what == "automover") {
						if (p.is_admin())
							send_menu(p.peer_id, "automover menu", "bautomover", "automover:automover[]password protected automover:pautomover[]item checker automover:icautomover[]item taker automover:itautomover[]item giver automover:igautomover");
						else
							send_menu(p.peer_id, "automover menu", "bautomover", "automover:automover[]password protected automover:pautomover[]item checker automover:icautomover[]item taker automover:itautomover");
					} else if (what == "travelpoint") {
						if (p.is_admin())
							send_menu(p.peer_id, "travelpoint menu", "btravelpoint", "automatic_travelpoint:automatic_travelpoint[]password protected automatic_travelpoint:pautomatic_travelpoint[]item checker automatic_travelpoint:icautomatic_travelpoint[]item taker automatic_travelpoint:itautomatic_travelpoint[]item giver automatic_travelpoint:igautomatic_travelpoint[]travelpoint:travelpoint[]password protected travelpoint:ptravelpoint[]item checker travelpoint:ictravelpoint[]item taker travelpoint:ittravelpoint[]item giver travelpoint:igtravelpoint");
						else
							send_menu(p.peer_id, "automatic_travelpoint menu", "btravelpoint", "automatic_travelpoint:automatic_travelpoint[]password protected automatic_travelpoint:pautomatic_travelpoint[]item checker automatic_travelpoint:icautomatic_travelpoint[]item taker automatic_travelpoint:itautomatic_travelpoint[]travelpoint:travelpoint[]password protected travelpoint:ptravelpoint[]item checker travelpoint:ictravelpoint[]item taker travelpoint:ittravelpoint");
					} else if (what == "tf") {
						if (p.is_admin())
							send_menu(p.peer_id, "togglable features menu", "btf", "enable 2dsupport:e2dsupport[]disable 2dsupport:d2dsupport[]enable coordinates:ecoordinates[]disable coordinates:dcoordinates[]camera options:cameraoptions[]enable jumping:ejump[]disable jumping:djump[]spyglass options:spyglassoptions[]enable local chat:elocalchat[]disable local chat:dlocalchat[]enable voice chat:evoicechat[]disable voice chat:dvoicechat[]enable tts chat:ettschat[]disable tts chat:dttschat[]enable tracking players:etracking[]disable tracking players:dtracking[]enable disaster spawning:edisasters[]disable disaster spawning:ddisasters[]disable rain:drain[]disable wind:dwind[]disable night sounds:dnight");
						else
							send_menu(p.peer_id, "togglable features menu", "btf", "enable 2dsupport:e2dsupport[]disable 2dsupport:d2dsupport[]enable coordinates:ecoordinates[]disable coordinates:dcoordinates[]camera options:cameraoptions[]enable jumping:ejump[]disable jumping:djump[]spyglass options:spyglassoptions[]enable local chat:elocalchat[]disable local chat:dlocalchat[]enable voice chat:evoicechat[]disable voice chat:dvoicechat[]enable tts chat:ettschat[]disable tts chat:dttschat[]enable tracking players:etracking[]disable tracking players:dtracking[]disable rain:drain[]disable wind:dwind[]disable night sounds:dnight");
					} else if (what == "fishingcoordinate" and p.is_admin())
						send_reliable(p, "buildfishing_coordinate", 0);
					else if (what == "vending_machine" and p.is_admin())
						send_reliable(p, "buildvending_machine", 0);
					else if (what == "checkpoint")
						send_reliable(p, "buildcheckpoint", 0);
					else if (what == "washbasin")
						send_reliable(p, "buildwashbasin", 0);
					else if (what == "firemap")
						send_reliable(p, "buildfiremap", 0);
					else if (what == "task_status" and p.is_admin())
						send_reliable(p, "buildtask_status", 0);
					else if (what == "shower")
						send_reliable(p, "buildshower", 0);
					else if (what == "toilet")
						send_reliable(p, "buildtoilet", 0);
					else if (what == "trashcan")
						send_reliable(p, "buildtrashcan", 0);
					else if (what == "starting_point")
						send_reliable(p, "buildstarting_point", 0);
					else if (what == "deathpoint")
						send_reliable(p, "builddeathpoint", 0);
					else if (what == "gmd")
						send_reliable(p, "buildgmd", 0);
					else if (what == "public" and p.is_admin()) {
						f.open("pbmaps.svr", "rb");
						string mdata = f.read().replace("\r\n", "\n");
						f.close();
						string[] mapdata = string_split(mdata, "\n");
						int something = mapdata.find(p.map);
						if (something > -1) {
							send_reliable(p, "error: you can't public you're already published map", 2);
							return;
						} else {
							file_put_contents("pbmaps.svr", "" + p.map + "\n", 255);
							send_reliable(p, "Your map has been published!", 2);
							int mi = get_map_index(p.map);
							if ((mi > -1)) {
								string s = "";
								string s2;
								if (maps[mi].owners.length() > 1) {
									for (uint i = 0; i < maps[mi].owners.length(); i++) {
										if (i == (maps[mi].owners.length() - 1)) s += "and " + maps[mi].owners[i] + ".";
										else s += maps[mi].owners[i] + ", ";
									}
								} else
									for (uint i = 0; i < maps[mi].owners.length(); i++)
										s = maps[mi].owners[i] + ".";
								if (maps[mi].owners.length() > 1) s2 = " " + maps[mi].owners.length() + " owners: ";
								else s2 = " " + maps[mi].owners.length() + " owner: ";
								send_reliable(0, "" + p.name + "'s " + maps[mi].name + " map has been added to the public maps! " + s2 + " " + s + ". You can visit it from the main_map menu", 2);
							}
							return;
						}
					} else if (what == "private") {
						f.open("pbmaps.svr", "rb");
						string mdata = f.read().replace("\r\n", "\n");
						f.close();
						string[] mapdata = string_split(mdata, "\n");
						int something = mapdata.find(p.map);
						if (something > -1) {
							f.open("maps/" + p.map + "/!.map", "rb");
							string[] lines = string_split(f.read().replace("\r\n", "\n"), "\n");
							f.close();
							for (uint i = 0; i < lines.length(); i++) {
								string[] ld = string_split(lines[i], ":", false);
								if (ld[0] == "ai" and p.is_admin() == false) {
									send_reliable(p, "you can't make this map private", 2);
									return;
								} else if (ld[0] == "item" and p.is_admin() == false) {
									send_reliable(p, "you can't make this map private", 2);
									return;
								} else if (ld[0] == "task_status" and p.is_admin() == false) {
									send_reliable(p, "you can't make this map private", 2);
									return;
								} else if (ld[0] == "vending_machine" and p.is_admin() == false) {
									send_reliable(p, "you can't make this map private", 2);
									return;
								} else if (ld[0] == "fishing_coordinate" and p.is_admin() == false) {
									send_reliable(p, "you can't make this map private", 2);
									return;
								}
							}
							mapdata.remove_at(something);
							file_put_contents("pbmaps.svr", linear(mapdata), 250);
							send_reliable(p, "your map is now private", 2);
							send_reliable(0, "" + p.name + "'s " + p.map + " map is now private", 2);
							return;
						} else {
							send_reliable(p, "This map is already private", 2);
							return;
						}
					} else if (what == "task") {
						f.open("chmaps.svr", "rb");
						string mdata = f.read().replace("\r\n", "\n");
						f.close();
						string[] mapdata = string_split(mdata, "\n");
						int something = mapdata.find(p.map);
						if (something > -1) {
							send_reliable(p, "error: you can't put you're already added map to the task", 2);
							return;
						} else {
							file_put_contents("chmaps.svr", "" + p.map + "\n", 255);
							send_reliable(p, "" + p.map + " has been added to the tasks list!", 2);
							int mi = get_map_index(p.map);
							if ((mi > -1)) {
								string s = "";
								string s2;
								if (maps[mi].owners.length() > 1) {
									for (uint i = 0; i < maps[mi].owners.length(); i++) {
										if (i == (maps[mi].owners.length() - 1)) s += "and " + maps[mi].owners[i] + ".";
										else s += maps[mi].owners[i] + ", ";
									}
								} else
									for (uint i = 0; i < maps[mi].owners.length(); i++)
										s = maps[mi].owners[i] + ".";
								if (maps[mi].owners.length() > 1) s2 = " " + maps[mi].owners.length() + " owners: ";
								else s2 = " " + maps[mi].owners.length() + " owner: ";
								send_reliable(0, "" + maps[mi].name + " map has been added to the task maps! Reward: " + maps[mi].finishamount + " " + maps[mi].finishitem + ": " + s2 + " " + s + ". You can visit it from the main_map menu", 2);
							}
							return;
						}
					} else if (what == "nottask") {
						f.open("chmaps.svr", "rb");
						string mdata = f.read().replace("\r\n", "\n");
						f.close();
						string[] mapdata = string_split(mdata, "\n");
						int something = mapdata.find(p.map);
						if (something > -1) {
							mapdata.remove_at(something);
							file_put_contents("chmaps.svr", linear(mapdata), 250);
							send_reliable(p, "your map has been removed from tasks list", 2);
							send_reliable(0, "" + p.name + "'s " + p.map + " map is not in tasks list from now on", 2);
							return;
						} else {
							send_reliable(p, "This map is already nottask", 2);
							return;
						}
					} else if (what == "litem")
						send_reliable(p, "buildlitem", 0);
					else if (what == "description")
						send_reliable(p, "builddescription", 0);
					else if (what == "pvp")
						send_reliable(p, "buildpvp", 0);
					else if (what == "owner")
						send_reliable(p, "buildowner", 0);
					else if (what == "backupmap") {
						string maptext = get_map_text(maps[get_map_index(p.map)]);
						send_reliable(p, "buildwritemap " + p.map + " " + maptext, 0);
					} else if (what == "restorebackup") {
						f.open("maps/" + p.map + "/!.map", "rb");
						string[] lines = string_split(f.read().replace("\r\n", "\n"), "\n");
						f.close();
						for (uint i = 0; i < lines.length(); i++) {
							string[] ld = string_split(lines[i], ":", false);
							if (ld[0] == "ai" and p.is_admin() == false) {
								send_reliable(p, "can't get data of this map", 2);
								return;
							} else if (ld[0] == "item" and p.is_admin() == false) {
								send_reliable(p, "can't get data of this map", 2);
								return;
							} else if (ld[0] == "task_status" and p.is_admin() == false) {
								send_reliable(p, "can't get data of this map", 2);
								return;
							} else if (ld[0] == "vending_machine" and p.is_admin() == false) {
								send_reliable(p, "can't get data of this map", 2);
								return;
							} else if (ld[0] == "fishing_coordinate" and p.is_admin() == false) {
								send_reliable(p, "can't get data of this map", 2);
								return;
							}
						}
						send_reliable(p, "buildrestorebackup " + p.map + "", 0);
						return;
					} else if (what == "mapstats") {
						f.open("maps/" + p.map + "/!.map", "rb");
						string[] things = string_split(f.read().replace("\r\n", "\n"), "\n");
						f.close();
						send_reliable(p, "this map has " + things.length() + " lines and is " + get_file_size("maps/" + p.map + "/!.map") + "", 2);
					} else if (what == "addline")
						send_reliable(p, "buildaddline", 0);
					else if (what == "editline") {
						server_menu2 m;
						m.intro = "Select the line that you'd like to edit";
						m.initial_packet = "editline";
						int ind = get_map_index(p.map);
						if (ind > -1) {
							string[] lines = string_split(maps[ind].rawdata.replace("\r\n", "\n"), "\n", true);
							for (uint i = 0; i < lines.length(); i++) {
								string[] ld = string_split(lines[i], ":", false);
								if (ld[0] == "mapname" and p.is_admin() == false) continue;
								if (ld[0] == "ai" and p.is_admin() == false)
									m.add("unlabled", lines[i]);
								else if (ld[0] == "item" and p.is_admin() == false)
									m.add("unlabled", lines[i]);
								else if (ld[0] == "task_status" and p.is_admin() == false)
									m.add("unlabled", lines[i]);
								else if (ld[0] == "vending_machine" and p.is_admin() == false)
									m.add("unlabled", lines[i]);
								else if (ld[0] == "fishing_coordinate" and p.is_admin() == false)
									m.add("unlabled", lines[i]);
								else
									m.add(lines[i], lines[i]);
							}
						}
						m.send(p.peer_id);
					} else if (what == "removeline") {
						server_menu2 m;
						m.intro = "Select the line that you'd like to remove";
						m.initial_packet = "removeline";
						int ind = get_map_index(p.map);
						if (ind > -1) {
							string[] lines = string_split(maps[ind].rawdata.replace("\r\n", "\n"), "\n", true);
							for (uint i = 0; i < lines.length(); i++) {
								string[] ld = string_split(lines[i], ":", false);
								if (ld[0] == "mapname" and p.is_admin() == false) continue;
								if (ld[0] == "ai" and p.is_admin() == false)
									m.add("unlabled", lines[i]);
								else if (ld[0] == "item" and p.is_admin() == false)
									m.add("unlabled", lines[i]);
								else if (ld[0] == "task_status" and p.is_admin() == false)
									m.add("unlabled", lines[i]);
								else if (ld[0] == "vending_machine" and p.is_admin() == false)
									m.add("unlabled", lines[i]);
								else if (ld[0] == "fishing_coordinate" and p.is_admin() == false)
									m.add("unlabled", lines[i]);
								else
									m.add(lines[i], lines[i]);
							}
						}
						m.send(p.peer_id);
					} else if (what == "removeowner") {
						server_menu2 m;
						m.intro = "who would you like to remove";
						m.initial_packet = "removeowner";
						int ind = get_map_index(p.map);
						if (ind > -1) {
							string[] lines = string_split(maps[ind].rawdata.replace("\r\n", "\n"), "\n", true);
							for (uint i = 0; i < lines.length(); i++) {
								if (string_contains(lines[i], "owner:", 1) > -1) {
									string[] ar = string_split(lines[i], ":", false);
									m.add(ar[1], lines[i]);
								}
							}
						}
						m.send(p.peer_id);
					} else if (what == "pmd") {
						send_reliable(p, "buildpmd", 0);
						//send_reliable(p, "Not working. Use /rawdata <data> command", 0);
					} else if (what == "specified_air_temperature")
						send_reliable(p, "buildspecified_air_temperature", 0);
						else buildobj_perform(p, what);
				}
				return;
			}
		}
	} else if (parsed[0] == "build") {
		build_menu(p);
	} else if (parsed[0] == "bAI" and parsed.length() > 1) {
		int mapindex = get_map_index(p.map);
		if (mapindex > -1) {
			for (uint i = 0; i < maps[mapindex].owners.length(); i++) {
				if (maps[mapindex].owners.find(p.name) > -1 or maps[mapindex].owners.find(p.partner) > -1 or p.is_admin()) {
					string what = parsed[1];
					if (what == "AI")
						send_reliable(p, "buildAI", 0);
					else if (what == "createAI")
						send_reliable(p, "createAI", 0);
					else if (what == "editAI") {
						server_menu2 m;
						m.intro = "choose an option";
						m.initial_packet = "editai";
						string[] a = find_files("ais/*.ai");
						for (uint i = 0; i < a.length(); i++)
							m.add(string_replace(a[i], ".ai", "", true), a[i]);
						m.send(p.peer_id);
					} else if (what == "removeAI") {
						server_menu2 m;
						m.intro = "choose an option";
						m.initial_packet = "removeai";
						string[] a = find_files("ais/*.ai");
						for (uint i = 0; i < a.length(); i++)
							m.add(string_replace(a[i], ".ai", "", true), a[i]);
						m.send(p.peer_id);
					} else if (what == "removeAIline") {
						server_menu2 m;
						m.intro = "choose an option";
						m.initial_packet = "removeailine";
						string[] a = find_files("ais/*.ai");
						for (uint i = 0; i < a.length(); i++)
							m.add(string_replace(a[i], ".ai", "", true), a[i]);
						m.send(p.peer_id);
					} else if (what == "spawnAI")
						send_reliable(p, "buildAI", 0);
				}
				return;
			}
		}
	} else if (parsed[0] == "bdrawsounds" and parsed.length() > 1) {
		int mapindex = get_map_index(p.map);
		if (mapindex > -1) {
			for (uint i = 0; i < maps[mapindex].owners.length(); i++) {
				if (maps[mapindex].owners.find(p.name) > -1 or maps[mapindex].owners.find(p.partner) > -1 or p.is_admin()) {
					string what = parsed[1];
					if (what == "createdrawsound")
						send_reliable(p, "createdrawsound", 0);
					else if (what == "editdrawsound") {
						server_menu m;
						m.intro = "Select the line that you'd like to edit";
						m.initial_packet = "drawsoundseditlinetext";
						file f;
						f.open("drawsounds.svr", "rb");
						string[] lines = string_split(f.read().replace("\r\n", "\n"), "\n", true);
						f.close();
						for (uint i = 0; i < lines.length(); i++) {
							if (string_contains(lines[i], "=", 1) < 0) {
								send_reliable(p, "error: all draw sounds take at least one argument, got " + lines[i] + "", 2);
								return;
							}
							m.add(lines[i], lines[i]);
						}
						m.send(p.peer_id);
					} else if (what == "removedrawsoundline") {
						server_menu m;
						m.intro = "Select the line that you'd like to remove";
						m.initial_packet = "drawsoundsremovelinetext";
						file f;
						f.open("drawsounds.svr", "rb");
						string[] lines = string_split(f.read().replace("\r\n", "\n"), "\n", true);
						f.close();
						for (uint i = 0; i < lines.length(); i++) {
							if (string_contains(lines[i], "=", 1) < 0) {
								send_reliable(p, "error: all draw sounds take at least one argument, got " + lines[i] + "", 2);
								return;
							}
							m.add(lines[i], lines[i]);
						}
						m.send(p.peer_id);
					}
				}
				return;
			}
		}
	} else if (parsed[0] == "bitemusagelimit" and parsed.length() > 1) {
		int mapindex = get_map_index(p.map);
		if (mapindex > -1) {
			for (uint i = 0; i < maps[mapindex].owners.length(); i++) {
				if (maps[mapindex].owners.find(p.name) > -1 or maps[mapindex].owners.find(p.partner) > -1 or p.is_admin()) {
					string what = parsed[1];
					if (what == "createitemusagelimit")
						send_reliable(p, "createitemusagelimit", 0);
					else if (what == "edititemusagelimit") {
						server_menu m;
						m.intro = "Select the line that you'd like to edit";
						m.initial_packet = "itemusagelimiteditlinetext";
						file f;
						f.open("notadg.svr", "rb");
						string[] lines = string_split(f.read().replace("\r\n", "\n"), "\n", true);
						f.close();
						for (uint i = 0; i < lines.length(); i++) {
							if (string_contains(lines[i], "=", 1) < 0) {
								send_reliable(p, "error: all draw sounds take at least one argument, got " + lines[i] + "", 2);
								return;
							}
							m.add(lines[i], lines[i]);
						}
						m.send(p.peer_id);
					} else if (what == "removeitemusagelimitline") {
						server_menu m;
						m.intro = "Select the line that you'd like to remove";
						m.initial_packet = "itemusagelimitremovelinetext";
						file f;
						f.open("notadg.svr", "rb");
						string[] lines = string_split(f.read().replace("\r\n", "\n"), "\n", true);
						f.close();
						for (uint i = 0; i < lines.length(); i++) {
							if (string_contains(lines[i], "=", 1) < 0) {
								send_reliable(p, "error: all draw sounds take at least one argument, got " + lines[i] + "", 2);
								return;
							}
							m.add(lines[i], lines[i]);
						}
						m.send(p.peer_id);
					}
				}
				return;
			}
		}
	} else if (parsed[0] == "bfad" and parsed.length() > 1) {
		int mapindex = get_map_index(p.map);
		if (mapindex > -1) {
			for (uint i = 0; i < maps[mapindex].owners.length(); i++) {
				if (maps[mapindex].owners.find(p.name) > -1 or maps[mapindex].owners.find(p.partner) > -1 or p.is_admin()) {
					string what = parsed[1];
					if (what == "fad")
						send_reliable(p, "buildfad", 0);
					else if (what == "createfad")
						send_reliable(p, "createfad", 0);
					else if (what == "editfad") {
						server_menu2 m;
						m.intro = "choose an option";
						m.initial_packet = "fadeditlinetext";
						string[] a = find_files("foods_and_drinks/*.fad");
						for (uint i = 0; i < a.length(); i++)
							m.add(string_replace(a[i], ".fad", "", true), a[i]);
						m.send(p.peer_id);
					} else if (what == "removefad") {
						server_menu2 m;
						m.intro = "choose an option";
						m.initial_packet = "removefad";
						string[] a = find_files("foods_and_drinks/*.fad");
						for (uint i = 0; i < a.length(); i++)
							m.add(string_replace(a[i], ".fad", "", true), a[i]);
						m.send(p.peer_id);
					}
				}
				return;
			}
		}
	} else if (parsed[0] == "item_desc_menu" && parsed.length() > 1) {
		string what = parsed[1];
		if (what == "add_desc") {
			if (p.assistant)
				send_reliable(p.peer_id, "add_item_desc", 0);
		} else if (what == "edit_desc") {
			if (p.assistant) {
				server_menu2 m;
				m.intro = "Choose an item to edit its description";
				m.initial_packet = "edit_item_desc_select";
				string[] items = descryptions.get_keys();
				if (items.length() > 0) {
					for (uint i = 0; i < items.length(); i++)
						m.add(items[i], items[i]);
					m.send(p.peer_id);
				} else
					send_reliable(p.peer_id, "There is no description created", 2);
			}
		} else if (what == "remove_desc") {
			if (p.assistant) {
				server_menu2 m;
				m.intro = "Select an item to delete its description";
				m.initial_packet = "del_desc";
				string[] items = descryptions.get_keys();
				if (items.length() > 0) {
					for (uint i = 0; i < items.length(); i++)
						m.add(items[i], items[i]);
					m.send(p.peer_id);
				} else
					send_reliable(p.peer_id, "There is no description created", 2);
			}
		} else if (what == "view_desc") {
			if (p.assistant) {
				server_menu2 m;
				m.intro = "Select an item to view its description";
				m.initial_packet = "view_item_desc";
				string[] items = descryptions.get_keys();
				if (items.length() > 0) {
					for (uint i = 0; i < items.length(); i++)
						m.add(items[i], items[i]);
					m.send(p.peer_id);
				} else
					send_reliable(p.peer_id, "There is no description created", 2);
			}
		}
	} else if (parsed[0] == "add_item_desc" && parsed.length() > 2) {
		if (p.assistant) {
			if (descryptions.exists(parsed[1]) == true)
				send_reliable(p.peer_id, "This item already has a description", 2);
			else {
				string text = string_replace(get_event_message(), parsed[0] + " " + parsed[1] + " ", "", false);
				descryptions.set(parsed[1], text);
				save_descriptions();
				send_reliable(p.peer_id, "Description added successfully", 2);
			}
		}
	} else if (parsed[0] == "edit_item_desc_select" && parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		if (p.assistant) {
			p.item_to_edit = parsed[1];
			string current_desc = get_item_descryption(parsed[1]);
			send_reliable(p.peer_id, "edit_item_desc " + current_desc, 0);
		}
	} else if (parsed[0] == "edit_item_desc" && parsed.length() > 1) {
		if (p.assistant) {
			if (parsed[1] == "back") {
				p.sendpacket("canceled", 0);
				return;
			}
			string new_desc = string_replace(get_event_message(), parsed[0] + " ", "", true);
			descryptions.set(p.item_to_edit, new_desc);
			save_descriptions();
			send_reliable(p.peer_id, "Description edited successfully", 2);
		}
	} else if (parsed[0] == "del_desc" && parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		if (p.assistant) {
			if (descryptions.exists(parsed[1]) == false)
				send_reliable(p.peer_id, "Description not available", 2);
			else {
				descryptions.delete(parsed[1]);
				save_descriptions();
				send_reliable(p.peer_id, "Description deleted successfully", 2);
			}
		}
	} else if (parsed[0] == "view_item_desc" && parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		if (p.assistant) {
			string desc = get_item_descryption(parsed[1]);
			send_reliable(p.peer_id, desc, 2);
		}
	} else if (parsed[0] == "bdoor" and parsed.length() > 1) {
		int mapindex = get_map_index(p.map);
		if (mapindex > -1) {
			for (uint i = 0; i < maps[mapindex].owners.length(); i++) {
				if (maps[mapindex].owners.find(p.name) > -1 or maps[mapindex].owners.find(p.partner) > -1 or p.is_admin()) {
					string what = parsed[1];
					if (what == "door")
						send_reliable(p, "builddoor", 0);
					else if (what == "pdoor")
						send_reliable(p, "buildpdoor", 0);
					else if (what == "icdoor")
						send_reliable(p, "buildicdoor", 0);
					else if (what == "itdoor")
						send_reliable(p, "builditdoor", 0);
					else if (what == "igdoor")
						send_reliable(p, "buildigdoor", 0);
				}
				return;
			}
		}
	} else if (parsed[0] == "bautomover" and parsed.length() > 1) {
		int mapindex = get_map_index(p.map);
		if (mapindex > -1) {
			for (uint i = 0; i < maps[mapindex].owners.length(); i++) {
				if (maps[mapindex].owners.find(p.name) > -1 or maps[mapindex].owners.find(p.partner) > -1 or p.is_admin()) {
					string what = parsed[1];
					if (what == "automover")
						send_reliable(p, "buildautomover", 0);
					else if (what == "pautomover")
						send_reliable(p, "buildpautomover", 0);
					else if (what == "icautomover")
						send_reliable(p, "buildicautomover", 0);
					else if (what == "itautomover")
						send_reliable(p, "builditautomover", 0);
					else if (what == "igautomover")
						send_reliable(p, "buildigautomover", 0);
				}
				return;
			}
		}
	} else if (parsed[0] == "btravelpoint" and parsed.length() > 1) {
		int mapindex = get_map_index(p.map);
		if (mapindex > -1) {
			for (uint i = 0; i < maps[mapindex].owners.length(); i++) {
				if (maps[mapindex].owners.find(p.name) > -1 or maps[mapindex].owners.find(p.partner) > -1 or p.is_admin()) {
					string what = parsed[1];
					if (what == "automatic_travelpoint")
						send_reliable(p, "buildautomatic_travelpoint", 0);
					else if (what == "pautomatic_travelpoint")
						send_reliable(p, "buildpautomatic_travelpoint", 0);
					else if (what == "icautomatic_travelpoint")
						send_reliable(p, "buildicautomatic_travelpoint", 0);
					else if (what == "itautomatic_travelpoint")
						send_reliable(p, "builditautomatic_travelpoint", 0);
					else if (what == "igautomatic_travelpoint")
						send_reliable(p, "buildigautomatic_travelpoint", 0);
					else if (what == "travelpoint")
						send_reliable(p, "buildtravelpoint", 0);
					else if (what == "ptravelpoint")
						send_reliable(p, "buildptravelpoint", 0);
					else if (what == "ictravelpoint")
						send_reliable(p, "buildictravelpoint", 0);
					else if (what == "ittravelpoint")
						send_reliable(p, "buildittravelpoint", 0);
					else if (what == "igtravelpoint")
						send_reliable(p, "buildigtravelpoint", 0);
				}
				return;
			}
		}
	} else if (parsed[0] == "btf" and parsed.length() > 1) {
		int mapindex = get_map_index(p.map);
		if (mapindex > -1) {
			for (uint i = 0; i < maps[mapindex].owners.length(); i++) {
				if (maps[mapindex].owners.find(p.name) > -1 or maps[mapindex].owners.find(p.partner) > -1 or p.is_admin()) {
					string what = parsed[1];
					if (what == "elocalchat")
						send_reliable(p, "buildelocalchat", 0);
					else if (what == "evoicechat")
						send_reliable(p, "buildevoicechat", 0);
					else if (what == "ettschat")
						send_reliable(p, "buildettschat", 0);
					else if (what == "etracking")
						send_reliable(p, "buildetracking", 0);
					else if (what == "edisasters")
						send_reliable(p, "buildedisasters", 0);
					else if (what == "ecoordinates")
						send_reliable(p, "buildecoordinates", 0);
					else if (what == "cameraoptions") {
						if (p.is_admin())
							send_menu(p.peer_id, "camera options menu", "bcmr", "enable camera:ecamera[]disable camera:dcamera[]enable passing camera through walls:ecamerawall[]disable passing camera through walls:dcamerawall[]enable mfwc:emfwc[]disable mfwc:mfwc[]enable camera seeing players:ecameraplayer[]disable camera seeing players:dcameraplayer[]enable camera seeing items:ecameraitem[]disable camera seeing items:dcameraitem[]enable camera seeing doors:ecameradoor[]disable camera seeing doors:dcameradoor[]enable camera seeing password protected doors:ecamerapdoor[]disable camera seeing password protected doors:dcamerapdoor[]enable camera seeing item checker doors:ecameraicdoor[]disable camera seeing item checker doors:dcameraicdoor[]enable camera seeing item taker doors:ecameraitdoor[]disable camera seeing item taker doors:dcameraitdoor[]enable camera seeing item giver doors:ecameraigdoor[]disable camera seeing item giver doors:dcameraigdoor[]enable camera seeing automovers:ecameraautomover[]disable camera seeing automovers:dcameraautomover[]enable camera seeing password protected automovers:ecamerapautomover[]disable camera seeing password protected automovers:dcamerapautomover[]enable camera seeing item checker automovers:ecameraicautomover[]disable camera seeing item checker automovers:dcameraicautomover[]enable camera seeing item taker automovers:ecameraitautomover[]disable camera seeing item taker automovers:dcameraitautomover[]enable camera seeing item giver automovers:ecameraigautomover[]disable camera seeing item giver automovers:dcameraigautomover[]enable camera seeing automatic_travelpoints:ecameraautomatic_travelpoint[]disable camera seeing automatic_travelpoints:dcameraautomatic_travelpoint[]enable camera seeing password protected automatic_travelpoints:ecamerapautomatic_travelpoint[]disable camera seeing password protected automatic_travelpoints:dcamerapautomatic_travelpoint[]enable camera seeing item checker automatic_travelpoints:ecameraicautomatic_travelpoint[]disable camera seeing item checker automatic_travelpoints:dcameraicautomatic_travelpoint[]enable camera seeing item taker automatic_travelpoints:ecameraitautomatic_travelpoint[]disable camera seeing item taker automatic_travelpoints:dcameraitautomatic_travelpoint[]enable camera seeing item giver automatic_travelpoints:ecameraigautomatic_travelpoint[]disable camera seeing item giver automatic_travelpoints:dcameraigautomatic_travelpoint[]enable camera seeing travelpoints:ecameratravelpoint[]disable camera seeing travelpoints:dcameratravelpoint[]enable camera seeing password protected travelpoints:ecameraptravelpoint[]disable camera seeing password protected travelpoints:dcameraptravelpoint[]enable camera seeing item checker travelpoints:ecameraictravelpoint[]disable camera seeing item checker travelpoints:dcameraictravelpoint[]enable camera seeing item taker travelpoints:ecameraittravelpoint[]disable camera seeing item taker travelpoints:dcameraittravelpoint[]enable camera seeing item giver travelpoints:ecameraigtravelpoint[]disable camera seeing item giver travelpoints:dcameraigtravelpoint[]enable camera seeing forcefields:ecameraff[]disable camera seeing forcefields:dcameraff[]enable camera seeing hazards:ecamerah[]disable camera seeing hazards:dcamerah[]enable camera seeing teleporters:ecameratp[]disable camera seeing teleporters:dcameratp[]enable camera seeing vanishing platforms:ecameravp[]disable camera seeing vanishing platforms:dcameravp[]enable camera seeing signs:ecamerasign[]disable camera seeing signs:dcamerasign[]enable camera seeing txts:ecameratxt[]disable camera seeing txts:dcameratxt");
						else
							send_menu(p.peer_id, "camera options menu", "bcmr", "enable camera:ecamera[]disable camera:dcamera[]enable passing camera through walls:ecamerawall[]disable passing camera through walls:dcamerawall[]enable mfwc:emfwc[]disable mfwc:mfwc[]enable camera seeing players:ecameraplayer[]disable camera seeing players:dcameraplayer[]enable camera seeing items:ecameraitem[]disable camera seeing items:dcameraitem[]enable camera seeing doors:ecameradoor[]disable camera seeing doors:dcameradoor[]enable camera seeing password protected doors:ecamerapdoor[]disable camera seeing password protected doors:dcamerapdoor[]enable camera seeing item checker doors:ecameraicdoor[]disable camera seeing item checker doors:dcameraicdoor[]enable camera seeing item taker doors:ecameraitdoor[]disable camera seeing item taker doors:dcameraitdoor[]enable camera seeing automovers:ecameraautomover[]disable camera seeing automovers:dcameraautomover[]enable camera seeing password protected automovers:ecamerapautomover[]disable camera seeing password protected automovers:dcamerapautomover[]enable camera seeing item checker automovers:ecameraicautomover[]disable camera seeing item checker automovers:dcameraicautomover[]enable camera seeing item taker automovers:ecameraitautomover[]disable camera seeing item taker automovers:dcameraitautomover[]enable camera seeing automatic_travelpoints:ecameraautomatic_travelpoint[]disable camera seeing automatic_travelpoints:dcameraautomatic_travelpoint[]enable camera seeing password protected automatic_travelpoints:ecamerapautomatic_travelpoint[]disable camera seeing password protected automatic_travelpoints:dcamerapautomatic_travelpoint[]enable camera seeing item checker automatic_travelpoints:ecameraicautomatic_travelpoint[]disable camera seeing item checker automatic_travelpoints:dcameraicautomatic_travelpoint[]enable camera seeing item taker automatic_travelpoints:ecameraitautomatic_travelpoint[]disable camera seeing item taker automatic_travelpoints:dcameraitautomatic_travelpoint[]enable camera seeing travelpoints:ecameratravelpoint[]disable camera seeing travelpoints:dcameratravelpoint[]enable camera seeing password protected travelpoints:ecameraptravelpoint[]disable camera seeing password protected travelpoints:dcameraptravelpoint[]enable camera seeing item checker travelpoints:ecameraictravelpoint[]disable camera seeing item checker travelpoints:dcameraictravelpoint[]enable camera seeing item taker travelpoints:ecameraittravelpoint[]disable camera seeing item taker travelpoints:dcameraittravelpoint[]enable camera seeing forcefields:ecameravp[]disable camera seeing forcefields:dcameravp[]enable camera seeing hazards:ecamerah[]disable camera seeing hazards:dcamerah[]enable camera seeing teleporters:ecameratp[]disable camera seeing teleporters:dcameratp[]enable camera seeing vanishing platforms:ecameravp[]disable camera seeing vanishing platforms:dcameravp[]enable camera seeing signs:ecamerasign[]disable camera seeing signs:dcamerasign[]enable camera seeing txts:ecameratxt[]disable camera seeing txts:dcameratxt");
					} else if (what == "e2dsupport")
						send_reliable(p, "builde2dsupport", 0);
					else if (what == "ejump")
						send_reliable(p, "buildejump", 0);
					else if (what == "spyglassoptions") {
						if (p.is_admin())
							send_menu(p.peer_id, "spyglass options menu", "bspg", "enable spyglass:espy[]disable spyglass:dspy[]enable spyglass seeing players:espyplayer[]disable spyglass seeing players:dspyplayer[]enable spyglass seeing items:espyitem[]disable spyglass seeing items:dspyitem[]enable spyglass seeing doors:espydoor[]disable spyglass seeing doors:dspydoor[]enable spyglass seeing password protected doors:espypdoor[]disable spyglass seeing password protected doors:dspypdoor[]enable spyglass seeing item checker doors:espyicdoor[]disable spyglass seeing item checker doors:dspyicdoor[]enable spyglass seeing item taker doors:espyitdoor[]disable spyglass seeing item taker doors:dspyitdoor[]enable spyglass seeing item giver doors:espyigdoor[]disable spyglass seeing item giver doors:dspyigdoor[]enable spyglass seeing automovers:espyautomover[]disable spyglass seeing automovers:dspyautomover[]enable spyglass seeing password protected automovers:espypautomover[]disable spyglass seeing password protected automovers:dspypautomover[]enable spyglass seeing item checker automovers:espyicautomover[]disable spyglass seeing item checker automovers:dspyicautomover[]enable spyglass seeing item taker automovers:espyitautomover[]disable spyglass seeing item taker automovers:dspyitautomover[]enable spyglass seeing item giver automovers:espyigautomover[]disable spyglass seeing item giver automovers:dspyigautomover[]enable spyglass seeing automatic_travelpoints:espyautomatic_travelpoint[]disable spyglass seeing automatic_travelpoints:dspyautomatic_travelpoint[]enable spyglass seeing password protected automatic_travelpoints:espypautomatic_travelpoint[]disable spyglass seeing password protected automatic_travelpoints:dspypautomatic_travelpoint[]enable spyglass seeing item checker automatic_travelpoints:espyicautomatic_travelpoint[]disable spyglass seeing item checker automatic_travelpoints:dspyicautomatic_travelpoint[]enable spyglass seeing item taker automatic_travelpoints:espyitautomatic_travelpoint[]disable spyglass seeing item taker automatic_travelpoints:dspyitautomatic_travelpoint[]enable spyglass seeing item giver automatic_travelpoints:espyigautomatic_travelpoint[]disable spyglass seeing item giver automatic_travelpoints:dspyigautomatic_travelpoint[]enable spyglass seeing travelpoints:espytravelpoint[]disable spyglass seeing travelpoints:dspytravelpoint[]enable spyglass seeing password protected travelpoints:espyptravelpoint[]disable spyglass seeing password protected travelpoints:dspyptravelpoint[]enable spyglass seeing item checker travelpoints:espyictravelpoint[]disable spyglass seeing item checker travelpoints:dspyictravelpoint[]enable spyglass seeing item taker travelpoints:espyittravelpoint[]disable spyglass seeing item taker travelpoints:dspyittravelpoint[]enable spyglass seeing item giver travelpoints:espyigtravelpoint[]disable spyglass seeing item giver travelpoints:dspyigtravelpoint[]enable spyglass seeing forcefields:espyff[]disable spyglass seeing forcefields:dspyff[]enable spyglass seeing hazards:espyh[]disable spyglass seeing hazards:dspyh[]enable spyglass seeing teleporters:espytp[]disable spyglass seeing teleporters:dspytp[]enable spyglass seeing vanishing platforms:espyvp[]disable spyglass seeing vanishing platforms:dspyvp[]enable spyglass seeing signs:espysign[]disable spyglass seeing signs:dspysign[]enable spyglass seeing txts:espytxt[]disable spyglass seeing txts:dspytxt");
						else
							send_menu(p.peer_id, "spyglass options menu", "bspg", "enable spyglass:espy[]disable spyglass:dspy[]enable spyglass seeing players:espyplayer[]disable spyglass seeing players:dspyplayer[]enable spyglass seeing items:espyitem[]disable spyglass seeing items:dspyitem[]enable spyglass seeing doors:espydoor[]disable spyglass seeing doors:dspydoor[]enable spyglass seeing password protected doors:espypdoor[]disable spyglass seeing password protected doors:dspypdoor[]enable spyglass seeing item checker doors:espyicdoor[]disable spyglass seeing item checker doors:dspyicdoor[]enable spyglass seeing item taker doors:espyitdoor[]disable spyglass seeing item taker doors:dspyitdoor[]enable spyglass seeing automovers:espyautomover[]disable spyglass seeing automovers:dspyautomover[]enable spyglass seeing password protected automovers:espypautomover[]disable spyglass seeing password protected automovers:dspypautomover[]enable spyglass seeing item checker automovers:espyicautomover[]disable spyglass seeing item checker automovers:dspyicautomover[]enable spyglass seeing item taker automovers:espyitautomover[]disable spyglass seeing item taker automovers:dspyitautomover[]enable spyglass seeing automatic_travelpoints:espyautomatic_travelpoint[]disable spyglass seeing automatic_travelpoints:dspyautomatic_travelpoint[]enable spyglass seeing password protected automatic_travelpoints:espypautomatic_travelpoint[]disable spyglass seeing password protected automatic_travelpoints:dspypautomatic_travelpoint[]enable spyglass seeing item checker automatic_travelpoints:espyicautomatic_travelpoint[]disable spyglass seeing item checker automatic_travelpoints:dspyicautomatic_travelpoint[]enable spyglass seeing item taker automatic_travelpoints:espyitautomatic_travelpoint[]disable spyglass seeing item taker automatic_travelpoints:dspyitautomatic_travelpoint[]enable spyglass seeing travelpoints:espytravelpoint[]disable spyglass seeing travelpoints:dspytravelpoint[]enable spyglass seeing password protected travelpoints:espyptravelpoint[]disable spyglass seeing password protected travelpoints:dspyptravelpoint[]enable spyglass seeing item checker travelpoints:espyictravelpoint[]disable spyglass seeing item checker travelpoints:dspyictravelpoint[]enable spyglass seeing item taker travelpoints:espyittravelpoint[]disable spyglass seeing item taker travelpoints:dspyittravelpoint[]enable spyglass seeing forcefields:espyff[]disable spyglass seeing forcefields:dspyff[]enable spyglass seeing hazards:espyh[]disable spyglass seeing hazards:dspyh[]enable spyglass seeing teleporters:espytp[]disable spyglass seeing teleporters:dspytp[]enable spyglass seeing vanishing platforms:espyvp[]disable spyglass seeing vanishing platforms:dspyvp[]enable spyglass seeing signs:espysign[]disable spyglass seeing signs:dspysign[]enable spyglass seeing txts:espytxt[]disable spyglass seeing txts:dspytxt");
					} else if (what == "dlocalchat")
						send_reliable(p, "builddlocalchat", 0);
					else if (what == "dvoicechat")
						send_reliable(p, "builddvoicechat", 0);
					else if (what == "dttschat")
						send_reliable(p, "builddttschat", 0);
					else if (what == "dtracking")
						send_reliable(p, "builddtracking", 0);
					else if (what == "ddisasters")
						send_reliable(p, "buildddisasters", 0);
					else if (what == "dcoordinates")
						send_reliable(p, "builddcoordinates", 0);
					else if (what == "d2dsupport")
						send_reliable(p, "buildd2dsupport", 0);
					else if (what == "djump")
						send_reliable(p, "builddjump", 0);
					else if (what == "drain")
						send_reliable(p, "builddrain", 0);
					else if (what == "dwind")
						send_reliable(p, "builddwind", 0);
					else if (what == "dnight")
						send_reliable(p, "builddnight", 0);
				}
				return;
			}
		}
	} else if (parsed[0] == "bcmr" and parsed.length() > 1) {
		int mapindex = get_map_index(p.map);
		if (mapindex > -1) {
			for (uint i = 0; i < maps[mapindex].owners.length(); i++) {
				if (maps[mapindex].owners.find(p.name) > -1 or maps[mapindex].owners.find(p.partner) > -1 or p.is_admin()) {
					string what = parsed[1];
					if (what == "ecamera")
						send_reliable(p, "buildecamera", 0);
					else if (what == "ecamerawall")
						send_reliable(p, "buildecamerawall", 0);
					else if (what == "emfwc")
						send_reliable(p, "buildemfwc", 0);
					else if (what == "dcamera")
						send_reliable(p, "builddcamera", 0);
					else if (what == "dcamerawall")
						send_reliable(p, "builddcamerawall", 0);
					else if (what == "dmfwc")
						send_reliable(p, "builddmfwc", 0);
					else if (what == "ecameraplayer")
						send_reliable(p, "buildecameraplayer", 0);
					else if (what == "dcameraplayer")
						send_reliable(p, "builddcameraplayer", 0);
					else if (what == "ecameraitem")
						send_reliable(p, "buildecameraitem", 0);
					else if (what == "dcameraitem")
						send_reliable(p, "builddcameraitem", 0);
					else if (what == "ecameradoor")
						send_reliable(p, "buildecameradoor", 0);
					else if (what == "dcameradoor")
						send_reliable(p, "builddcameradoor", 0);
					else if (what == "ecamerapdoor")
						send_reliable(p, "buildecamerapdoor", 0);
					else if (what == "dcamerapdoor")
						send_reliable(p, "builddcamerapdoor", 0);
					else if (what == "ecameraicdoor")
						send_reliable(p, "buildecameraicdoor", 0);
					else if (what == "dcameraicdoor")
						send_reliable(p, "builddcameraicdoor", 0);
					else if (what == "ecameraitdoor")
						send_reliable(p, "buildecameraitdoor", 0);
					else if (what == "dcameraitdoor")
						send_reliable(p, "builddcameraitdoor", 0);
					else if (what == "ecameraigdoor")
						send_reliable(p, "buildecameraigdoor", 0);
					else if (what == "dcameraigdoor")
						send_reliable(p, "builddcameraigdoor", 0);
					else if (what == "ecameraautomover")
						send_reliable(p, "buildecameraautomover", 0);
					else if (what == "dcameraautomover")
						send_reliable(p, "builddcameraautomover", 0);
					else if (what == "ecamerapautomover")
						send_reliable(p, "buildecamerapautomover", 0);
					else if (what == "dcamerapautomover")
						send_reliable(p, "builddcamerapautomover", 0);
					else if (what == "ecameraicautomover")
						send_reliable(p, "buildecameraicautomover", 0);
					else if (what == "dcameraicautomover")
						send_reliable(p, "builddcameraicautomover", 0);
					else if (what == "ecameraitautomover")
						send_reliable(p, "buildecameraitautomover", 0);
					else if (what == "dcameraitautomover")
						send_reliable(p, "builddcameraitautomover ", 0);
					else if (what == "ecameraigautomover")
						send_reliable(p, "buildecameraigautomover", 0);
					else if (what == "dcameraigautomover")
						send_reliable(p, "builddcameraigautomover", 0);
					else if (what == "ecameraautomatic_travelpoint")
						send_reliable(p, "buildecameraautomatic_travelpoint", 0);
					else if (what == "dcameraautomatic_travelpoint")
						send_reliable(p, "builddcameraautomatic_travelpoint", 0);
					else if (what == "ecamerapautomatic_travelpoint")
						send_reliable(p, "buildecamerapautomatic_travelpoint", 0);
					else if (what == "dcamerapautomatic_travelpoint")
						send_reliable(p, "builddcamerapautomatic_travelpoint", 0);
					else if (what == "ecameraicautomatic_travelpoint")
						send_reliable(p, "buildecameraicautomatic_travelpoint", 0);
					else if (what == "dcameraicautomatic_travelpoint")
						send_reliable(p, "builddcameraicautomatic_travelpoint", 0);
					else if (what == "ecameraitautomatic_travelpoint")
						send_reliable(p, "buildecameraitautomatic_travelpoint", 0);
					else if (what == "dcameraitautomatic_travelpoint")
						send_reliable(p, "builddcameraitautomatic_travelpoint ", 0);
					else if (what == "ecameraigautomatic_travelpoint")
						send_reliable(p, "buildecameraigautomatic_travelpoint", 0);
					else if (what == "dcameraigautomatic_travelpoint")
						send_reliable(p, "builddcameraigautomatic_travelpoint", 0);
					else if (what == "ecameratravelpoint")
						send_reliable(p, "buildecameratravelpoint", 0);
					else if (what == "dcameratravelpoint")
						send_reliable(p, "builddcameratravelpoint", 0);
					else if (what == "ecameraptravelpoint")
						send_reliable(p, "buildecameraptravelpoint", 0);
					else if (what == "dcameraptravelpoint")
						send_reliable(p, "builddcameraptravelpoint", 0);
					else if (what == "ecameraictravelpoint")
						send_reliable(p, "buildecameraictravelpoint", 0);
					else if (what == "dcameraictravelpoint")
						send_reliable(p, "builddcameraictravelpoint", 0);
					else if (what == "ecameraittravelpoint")
						send_reliable(p, "buildecameraittravelpoint", 0);
					else if (what == "dcameraittravelpoint")
						send_reliable(p, "builddcameraittravelpoint ", 0);
					else if (what == "ecameraigtravelpoint")
						send_reliable(p, "buildecameraigtravelpoint", 0);
					else if (what == "dcameraigtravelpoint")
						send_reliable(p, "builddcameraigtravelpoint", 0);
					else if (what == "ecameravp")
						send_reliable(p, "buildecameravp", 0);
					else if (what == "dcameravp")
						send_reliable(p, "builddcameravp", 0);
					else if (what == "ecamerasign")
						send_reliable(p, "buildecamerasign", 0);
					else if (what == "dcamerasign")
						send_reliable(p, "builddcamerasign", 0);
					else if (what == "ecameratxt")
						send_reliable(p, "buildecameratxt", 0);
					else if (what == "dcameratxt")
						send_reliable(p, "builddcameratxt", 0);
				}
				return;
			}
		}
	} else if (parsed[0] == "bspg" and parsed.length() > 1) {
		int mapindex = get_map_index(p.map);
		if (mapindex > -1) {
			for (uint i = 0; i < maps[mapindex].owners.length(); i++) {
				if (maps[mapindex].owners.find(p.name) > -1 or maps[mapindex].owners.find(p.partner) > -1 or p.is_admin()) {
					string what = parsed[1];
					if (what == "espy")
						send_reliable(p, "buildespy", 0);
					else if (what == "dspy")
						send_reliable(p, "builddspy", 0);
					else if (what == "espyplayer")
						send_reliable(p, "buildespyplayer", 0);
					else if (what == "dspyplayer")
						send_reliable(p, "builddspyplayer", 0);
					else if (what == "espyitem")
						send_reliable(p, "buildespyitem", 0);
					else if (what == "dspyitem")
						send_reliable(p, "builddspyitem", 0);
					else if (what == "espydoor")
						send_reliable(p, "buildespydoor", 0);
					else if (what == "dspydoor")
						send_reliable(p, "builddspydoor", 0);
					else if (what == "espypdoor")
						send_reliable(p, "buildespypdoor", 0);
					else if (what == "dspypdoor")
						send_reliable(p, "builddspypdoor", 0);
					else if (what == "espyicdoor")
						send_reliable(p, "buildespyicdoor", 0);
					else if (what == "dspyicdoor")
						send_reliable(p, "builddspyicdoor", 0);
					else if (what == "espyitdoor")
						send_reliable(p, "buildespyitdoor", 0);
					else if (what == "dspyitdoor")
						send_reliable(p, "builddspyitdoor", 0);
					else if (what == "espyigdoor")
						send_reliable(p, "buildespyigdoor", 0);
					else if (what == "dspyigdoor")
						send_reliable(p, "builddspyigdoor", 0);
					else if (what == "espyautomover")
						send_reliable(p, "buildespyautomover", 0);
					else if (what == "dspyautomover")
						send_reliable(p, "builddspyautomover", 0);
					else if (what == "espypautomover")
						send_reliable(p, "buildespypautomover", 0);
					else if (what == "dspypautomover")
						send_reliable(p, "builddspypautomover", 0);
					else if (what == "espyicautomover")
						send_reliable(p, "buildespyicautomover", 0);
					else if (what == "dspyicautomover")
						send_reliable(p, "builddspyicautomover", 0);
					else if (what == "espyitautomover")
						send_reliable(p, "buildespyitautomover", 0);
					else if (what == "dspyitautomover")
						send_reliable(p, "builddspyitautomover ", 0);
					else if (what == "espyigautomover")
						send_reliable(p, "buildespyigautomover", 0);
					else if (what == "dspyigautomover")
						send_reliable(p, "builddspyigautomover", 0);
					else if (what == "espyautomatic_travelpoint")
						send_reliable(p, "buildespyautomatic_travelpoint", 0);
					else if (what == "dspyautomatic_travelpoint")
						send_reliable(p, "builddspyautomatic_travelpoint", 0);
					else if (what == "espypautomatic_travelpoint")
						send_reliable(p, "buildespypautomatic_travelpoint", 0);
					else if (what == "dspypautomatic_travelpoint")
						send_reliable(p, "builddspypautomatic_travelpoint", 0);
					else if (what == "espyicautomatic_travelpoint")
						send_reliable(p, "buildespyicautomatic_travelpoint", 0);
					else if (what == "dspyicautomatic_travelpoint")
						send_reliable(p, "builddspyicautomatic_travelpoint", 0);
					else if (what == "espyitautomatic_travelpoint")
						send_reliable(p, "buildespyitautomatic_travelpoint", 0);
					else if (what == "dspyitautomatic_travelpoint")
						send_reliable(p, "builddspyitautomatic_travelpoint ", 0);
					else if (what == "espyigautomatic_travelpoint")
						send_reliable(p, "buildespyigautomatic_travelpoint", 0);
					else if (what == "dspyigautomatic_travelpoint")
						send_reliable(p, "builddspyigautomatic_travelpoint", 0);
					else if (what == "espytravelpoint")
						send_reliable(p, "buildespytravelpoint", 0);
					else if (what == "dspytravelpoint")
						send_reliable(p, "builddspytravelpoint", 0);
					else if (what == "espyptravelpoint")
						send_reliable(p, "buildespyptravelpoint", 0);
					else if (what == "dspyptravelpoint")
						send_reliable(p, "builddspyptravelpoint", 0);
					else if (what == "espyictravelpoint")
						send_reliable(p, "buildespyictravelpoint", 0);
					else if (what == "dspyictravelpoint")
						send_reliable(p, "builddspyictravelpoint", 0);
					else if (what == "espyittravelpoint")
						send_reliable(p, "buildespyittravelpoint", 0);
					else if (what == "dspyittravelpoint")
						send_reliable(p, "builddspyittravelpoint ", 0);
					else if (what == "espyigtravelpoint")
						send_reliable(p, "buildespyigtravelpoint", 0);
					else if (what == "dspyigtravelpoint")
						send_reliable(p, "builddspyigtravelpoint", 0);
					else if (what == "espyvp")
						send_reliable(p, "buildespyvp", 0);
					else if (what == "dspyvp")
						send_reliable(p, "builddspyvp", 0);
					else if (what == "espysign")
						send_reliable(p, "buildespysign", 0);
					else if (what == "dspysign")
						send_reliable(p, "builddspysign", 0);
					else if (what == "espytxt")
						send_reliable(p, "buildespytxt", 0);
					else if (what == "dspytxt")
						send_reliable(p, "builddspytxt", 0);
				}
				return;
			}
		}
	} else if (parsed[0] == "editai" and parsed.length() >= 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		p.aitoedit = parsed[1];
		server_menu m;
		m.intro = "Select the line that you'd like to edit";
		m.initial_packet = "aieditlinetext";
		file f;
		f.open("ais/" + parsed[1], "rb");
		string[] lines = string_split(f.read().replace("\r\n", "\n"), "\n", true);
		f.close();
		bool ai_has_gender = false;
		for (uint i = 0; i < lines.length(); i++) {
			if (lines[i].starts_with("gender")) ai_has_gender = true;
		}
		if (!ai_has_gender) {
			lines.insert_last("gender=-1");
			file_put("ais/" + parsed[1], join(lines, "\n"));
		}
		for (uint i = 0; i < lines.length(); i++) {
			if (string_contains(lines[i], "=", 1) < 0) {
				send_reliable(p, "error: all ai commands take at least one argument, got " + lines[i] + "", 2);
				return;
			}
			m.add(lines[i], lines[i]);
		}
		m.send(p.peer_id);
	} else if (parsed[0] == "aieditline" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		string aitext = string_replace(get_event_message(), "aieditline ", "", false);
		file f;
		f.open("ais/" + p.aitoedit, "rb");
		string aidata = f.read().replace("\r\n", "\n");
		f.close();
		string[] aisdata = string_split(aidata, "\n");
		int something = aisdata.find(p.aieditline);
		if (something > -1) {
			aisdata.remove_at(something);
			aisdata.insert_at(something, aitext);
			file_put_contents("ais/" + p.aitoedit, linear(aisdata), 250);
			for (uint i2 = 0; i2 < ais.length(); i2++) {
				if (ais[i2].voice != "" and ais[i2].rapidvoice == true) destroy_moving_sound(ais[i2].voice);
				ais.remove_at(i2);
				continue;
			}
			load_ais();
			send_reliable(p, "done", 2);
		}
	} else if (parsed[0] == "removeai" and parsed.length() >= 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		file_delete("ais/" + parsed[1] + "");
		send_reliable(p, "done", 2);
	} else if (parsed[0] == "removeailine" and parsed.length() >= 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		p.aitoremove = parsed[1];
		server_menu m;
		m.intro = "Select the line that you'd like to remove";
		m.initial_packet = "airemovelinetext";
		file f;
		f.open("ais/" + parsed[1], "rb");
		string[] lines = string_split(f.read().replace("\r\n", "\n"), "\n", true);
		f.close();
		for (uint i = 0; i < lines.length(); i++) {
			if (string_contains(lines[i], "=", 1) < 0) {
				send_reliable(p, "error: all ai commands take at least one argument, got " + lines[i] + "", 2);
				return;
			}
			m.add(lines[i], lines[i]);
		}
		m.send(p.peer_id);
	} else if (parsed[0] == "airemoveline" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		string aitext = string_replace(get_event_message(), "airemoveline ", "", false);
		file f;
		f.open("ais/" + p.aitoremove, "rb");
		string aidata = f.read().replace("\r\n", "\n");
		f.close();
		string[] aisdata = string_split(aidata, "\n");
		int something = aisdata.find(p.airemoveline);
		if (something > -1) {
			aisdata.remove_at(something);
			file_put_contents("ais/" + p.aitoremove, linear(aisdata), 250);
			for (uint i2 = 0; i2 < ais.length(); i2++) {
				if (ais[i2].voice != "" and ais[i2].rapidvoice == true) destroy_moving_sound(ais[i2].voice);
				ais.remove_at(i2);
				continue;
			}
			load_ais();
			send_reliable(p, "done", 2);
		}
	} else if (parsed[0] == "drawsoundseditline" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		string drawsoundstext = string_replace(get_event_message(), "drawsoundseditline ", "", false);
		file f;
		f.open("drawsounds.svr", "rb");
		string drawsoundsdata = f.read().replace("\r\n", "\n");
		f.close();
		string[] drawsoundssdata = string_split(drawsoundsdata, "\n");
		int something = drawsoundssdata.find(p.drawsoundseditline);
		if (something > -1) {
			drawsoundssdata.remove_at(something);
			drawsoundssdata.insert_at(something, drawsoundstext);
			file_put_contents("drawsounds.svr", linear(drawsoundssdata), 250);
			send_reliable(p, "done", 2);
		}
	} else if (parsed[0] == "drawsoundsremoveline" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		string drawsoundstext = string_replace(get_event_message(), "drawsoundsremoveline ", "", false);
		file f;
		f.open("drawsounds.svr", "rb");
		string drawsoundsdata = f.read().replace("\r\n", "\n");
		f.close();
		string[] drawsoundssdata = string_split(drawsoundsdata, "\n");
		int something = drawsoundssdata.find(p.drawsoundsremoveline);
		if (something > -1) {
			drawsoundssdata.remove_at(something);
			file_put_contents("drawsounds.svr", linear(drawsoundssdata), 250);
			send_reliable(p, "done", 2);
		}
	} else if (parsed[0] == "itemusagelimiteditline" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		string itemusagelimittext = string_replace(get_event_message(), "itemusagelimiteditline ", "", false);
		file f;
		f.open("notadg.svr", "rb");
		string itemusagelimitdata = f.read().replace("\r\n", "\n");
		f.close();
		string[] itemusagelimitsdata = string_split(itemusagelimitdata, "\n");
		int something = itemusagelimitsdata.find(p.itemusagelimiteditline);
		if (something > -1) {
			itemusagelimitsdata.remove_at(something);
			itemusagelimitsdata.insert_at(something, itemusagelimittext);
			file_put_contents("notadg.svr", linear(itemusagelimitsdata), 250);
			send_reliable(p, "done", 2);
		}
	} else if (parsed[0] == "itemusagelimitremoveline" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		string itemusagelimittext = string_replace(get_event_message(), "itemusagelimitremoveline ", "", false);
		file f;
		f.open("notadg.svr", "rb");
		string itemusagelimitdata = f.read().replace("\r\n", "\n");
		f.close();
		string[] itemusagelimitsdata = string_split(itemusagelimitdata, "\n");
		int something = itemusagelimitsdata.find(p.itemusagelimitremoveline);
		if (something > -1) {
			itemusagelimitsdata.remove_at(something);
			file_put_contents("notadg.svr", linear(itemusagelimitsdata), 250);
			send_reliable(p, "done", 2);
		}
	} else if (parsed[0] == "editfad" and parsed.length() >= 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		file_put_contents("foods_and_drinks/" + p.fadtoedit, string_replace(get_event_message(), parsed[0] + " ", "", true), 250);
		send_reliable(p, "done", 2);
	} else if (parsed[0] == "removefad" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		file_delete("foods_and_drinks/" + parsed[1]);
		send_reliable(p, "done", 2);
	} else if (parsed[0] == "getsnow" and parsed.length() >= 1) {
		if (p.gettimer.elapsed >= 100) {
			p.gettimer.restart();
			send_packet(6, "play getsnow.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.inv_add_item("snow", 1);
		}
	} else if (parsed[0] == "getgrass" and parsed.length() >= 1) {
		if (p.gettimer.elapsed >= 100) {
			p.gettimer.restart();
			send_packet(6, "play getgrass.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.inv_add_item("grass", 1);
		}
	} else if (parsed[0] == "getweed" and parsed.length() >= 1) {
		if (p.gettimer.elapsed >= 100) {
			p.gettimer.restart();
			send_packet(6, "play getweed.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.inv_add_item("weed", 1);
		}
	} else if (parsed[0] == "getstone" and parsed.length() >= 1) {
		if (p.gettimer.elapsed >= 100) {
			p.gettimer.restart();
			send_packet(6, "play getstone.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.inv_add_item("stone", 1);
		}
	} else if (parsed[0] == "getdirt" and parsed.length() >= 1) {
		if (p.gettimer.elapsed >= 100) {
			p.gettimer.restart();
			send_packet(6, "play getdirt.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.inv_add_item("dirt", 1);
		}
	} else if (parsed[0] == "getgravel" and parsed.length() >= 1) {
		if (p.gettimer.elapsed >= 100) {
			p.gettimer.restart();
			send_packet(6, "play getgravel.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.inv_add_item("gravel", 1);
		}
	} else if (parsed[0] == "getclay" and parsed.length() >= 1) {
		if (p.gettimer.elapsed >= 100) {
			p.gettimer.restart();
			send_packet(6, "play getclay.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.inv_add_item("clay", 1);
		}
	} else if (parsed[0] == "getglass" and parsed.length() >= 1) {
		if (p.gettimer.elapsed >= 100) {
			p.gettimer.restart();
			send_packet(6, "play getglass.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.inv_add_item("glass", 1);
		}
	} else if (parsed[0] == "getbranch" and parsed.length() >= 1) {
		if (p.gettimer.elapsed >= 100) {
			p.gettimer.restart();
			send_packet(6, "play getbranch.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.inv_add_item("branch", 1);
		}
	} else if (parsed[0] == "getsand" and parsed.length() >= 1) {
		if (p.gettimer.elapsed >= 100) {
			p.gettimer.restart();
			send_packet(6, "play getsand.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.inv_add_item("sand", 1);
		}
	} else if (parsed[0] == "getmud" and parsed.length() >= 1) {
		if (p.gettimer.elapsed >= 100) {
			p.gettimer.restart();
			send_packet(6, "play getmud.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.inv_add_item("mud", 1);
		}
	} else if (parsed[0] == "getice" and parsed.length() >= 1) {
		if (p.gettimer.elapsed >= 100) {
			p.gettimer.restart();
			send_packet(6, "play getice.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.inv_add_item("ice", 1);
		}
	} else if (parsed[0] == "getleaves" and parsed.length() >= 1) {
		if (p.gettimer.elapsed >= 100) {
			p.gettimer.restart();
			send_packet(6, "play getleaves.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.inv_add_item("leaves", 1);
		}
	} else if (parsed[0] == "getrocks" and parsed.length() >= 1) {
		if (p.gettimer.elapsed >= 100) {
			p.gettimer.restart();
			send_packet(6, "play getrocks.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.inv_add_item("rocks", 1);
		}
	} else if (parsed[0] == "getwood" and parsed.length() >= 1) {
		if (p.gettimer.elapsed >= 100) {
			p.gettimer.restart();
			send_packet(6, "play getwood.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.inv_add_item("wood", 1);
		}
	} else if (parsed[0] == "getmetal" and parsed.length() >= 1) {
		if (p.gettimer.elapsed >= 100) {
			p.gettimer.restart();
			send_packet(6, "play getmedal.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			p.inv_add_item("metal", 1);
		}
	} else if (parsed[0] == "burnhand" and parsed.length() >= 1) {
		if (is_on_fire(p.x, p.y, p.z, maps[get_map_index(p.map)]) and p.gettimer.elapsed >= 100) {
			p.gettimer.restart();
			p.health -= random(20, 500);
			send_packet(6, "play v" + string_to_number(p.voice) + "hit" + random(1, 5) + ".ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			send_reliable(p, "oopss, you've burned your hand!", 2);
		}
	} else if (parsed[0] == "getmmetal" and parsed.length() >= 1) {
		if (p.gettimer.elapsed >= 100) {
			p.gettimer.restart();
			p.inv_add_item("metal", 1);
		}
	} else if (parsed[0] == "getwood" and parsed.length() >= 1) {
		if (p.gettimer.elapsed >= 100) {
			p.gettimer.restart();
			p.inv_add_item("wood", 1);
		}
	} else if (parsed[0] == "turretclip" and parsed.length() >= 1) {
		for (uint i = 0; i < turrets.length(); i++) {
			if (p.x == turrets[i].x and p.y == turrets[i].y and p.z == turrets[i].z and p.map == turrets[i].map.name) {
				if (turrets[i].clipsize >= 1)
					send_reliable(p, "this turret is already loaded.", 0);
				else {
					send_packet(6, "play turretreload.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
					turrets[i].clipsize += 100;
					p.inv_add_item("turret_cartridge", -1);
				}
			}
		}
	} else if (parsed[0] == "turretbattery" and parsed.length() >= 1) {
		for (uint i = 0; i < turrets.length(); i++) {
			if (p.x == turrets[i].x and p.y == turrets[i].y and p.z == turrets[i].z and p.map == turrets[i].map.name) {
				if (turrets[i].chargelevel >= 500)
					send_reliable(p, "this turret is fully charged.", 0);
				else {
					send_packet(6, "play turretbattery.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
					turrets[i].chargelevel += 30;
					p.inv_add_item("turret_battery", -1);
				}
			}
		}
	} else if (parsed[0] == "turret" and parsed.length() >= 1) {
		send_packet(6, "play turretplace.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
		send_reliable(p, "stopmoving", 0);
		p.turrettimer.restart();
		p.turretspawning = true;
		p.inv_add_item("turret", -1);
	} else if (parsed[0] == "drinkwater" and parsed.length() >= 1) {
		if (p.gettimer.elapsed >= 100) {
			p.gettimer.restart();
			if (p.nthirst >= 2000) {
				p.nthirst = 2000;
				send_reliable(p, "you are full!", 2);
			} else {
				send_packet(6, "play drink" + random(1, 3) + ".ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
				p.thirst -= random(2, 10);
				p.nthirst += 5;
				p.sick += random(0, 1);
			}
		}
	} else if (parsed[0] == "ammocheck") {
		int ind = get_player_index_from(p.looking);
		if (ind > -1) {
			if (players[ind].weapon_copasity < 1) send_reliable(p, players[ind].weapon_name + " doesn't need ammo", 0);
			else send_reliable(p, players[ind].weapon_ammos + " out of " + players[ind].weapon_copasity + " " + players[ind].weapon_ammo_type + " loaded, and " + players[ind].inv_item_number(players[ind].weapon_ammo_type) + " " + players[ind].weapon_ammo_type + " in reserve", 0);
		} else {
			if (p.weapon_copasity < 1) send_reliable(p, p.weapon_name + " doesn't need ammo", 0);
			else send_reliable(p, p.weapon_ammos + " out of " + p.weapon_copasity + " " + p.weapon_ammo_type + " loaded, and " + p.inv_item_number(p.weapon_ammo_type) + " " + p.weapon_ammo_type + " in reserve", 0);
		}
	} else if (parsed[0] == "air") {
		int ind = get_player_index_from(p.looking);
		if (ind > -1) {
			if (p.gender == 0)p.gender2 = "him";
			else p.gender2 = "her";
			send_reliable(p, "" + players[ind].name + " has " + players[ind].air + " air. This should last " + players[ind].gender2 + " about " + ms_to_readable_time(players[ind].air * 3500), 2);
		} else
			send_reliable(p, "You have " + p.air + " air. This should last you about " + ms_to_readable_time(p.air * 3500), 2);
	} else if (parsed[0] == "sitstand") {
		p.sitting = toggle(p.sitting);
		if (p.sitting == 1) {
			send_reliable(p, "playfallsound " + p.x + " " + p.y + " " + p.z + " " + p.map, 0);
			send_reliable(p, "sitstart", 0);
		} else {
			if (p.drunk == true and p.energy <= 100) {
				int r = random(-50, 100);
				if (r > 49) {
					send_reliable(p, "you can't stand up!", 0);
					send_reliable(p, "playfallsound " + p.x + " " + p.y + " " + p.z + " " + p.map, 0);
				}
			}
			send_packet(6, "play stand" + random(1, 2) + ".ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			send_reliable(p, "playscuffsound " + p.x + " " + p.y + " " + p.z + " " + p.map, 0);
			spawn_timepacket(p.peer_id, "sitstop", 0, 100);
		}
	} else if (parsed[0] == "packsomething" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			send_reliable(p, "Canceled", 0);
			return;
		}
		if (string_contains(parsed[1], "coins", 1) != -1 or string_contains(parsed[1], "credit", 1) != -1 or string_contains(parsed[1], "corpse_bomb", 1) != -1 or string_contains(parsed[1], "paid_gift", 1) != -1 or string_contains(parsed[1], "quick_thirst_fix_drug", 1) != -1 or string_contains(parsed[1], "quick_hunger_fix_snack", 1) != -1 or string_contains(parsed[1], "xp_potion", 1) > -1 or string_contains(parsed[1], "armor", 1) > -1 or string_contains(parsed[1], "safe_card", 1) != -1 or string_contains(parsed[1], "health_box", 1) != -1 or string_contains(parsed[1], "energy_pill", 1) != -1 or string_contains(parsed[1], "teleporter", 1) != -1 or string_contains(parsed[1], "nuclear_bomb", 1) != -1 or string_contains(parsed[1], "small_nuclear_bomb", 1) > -1 or string_contains(parsed[1], "large_nuclear_bomb", 1) > -1) {
			send_reliable(p, "you can't put " + parsed[1] + " in to this pack", 0);
			return;
		}
		string item = parsed[1];
		string[] a = string_split(file_get_contents("notadg.svr").replace("\r\n", "\n"), "\n");
		int something = a.find(item);
		if (something > -1) {
			send_reliable(p, "You can't put " + item + " in this pack", 2);
			return;
		}
		p.inv_add_item(item, -10);
		p.inv_add_item("package_of_10_" + item, 1);
		p.inv_add_item("empty_pack", -1);
		send_packet(6, "play giftopen3.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
		send_reliable(p, "You put 10 " + item + " in a pack and close it", 2);
	} else if (parsed[0] == "boxsomething" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			send_reliable(p, "Canceled", 0);
			return;
		}
		send_serverbox(p.peer_id, 2, -1, 1, -1, "boxitems/" + parsed[1], "how much of " + parsed[1] + " would you like to put on this box?");
	} else if (parsed[0] == "skilletsomething" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			send_reliable(p, "Canceled", 0);
			return;
		}
		string item = parsed[1];
		string[] a = string_split(file_get_contents("notadg.svr").replace("\r\n", "\n"), "\n");
		int something = a.find(item);
		if (something > -1) {
			send_reliable(p, "You can't put " + item + " in this skillet", 2);
			return;
		}
		p.inv_add_item(item, -10);
		p.inv_add_item("skillet_of_10_" + item, 1);
		p.inv_add_item("skillet", -1);
		send_packet(6, "play getskillet.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
		send_reliable(p, "You put 10 " + item + " in a skillet", 2);
	} else if (string_left(parsed[0], 9) == "boxitems/" and parsed.length() > 1) {
		if (parsed[1] == "[cncel]") return;
		double amount = string_to_number(parsed[1]);
		parsed = string_split(parsed[0], "/", false);
		if (p.inv_item_number(parsed[1]) >= amount) {
			if (amount <= 0) {
				send_reliable(p, "An error has occured", 0);
				return;
			}
			string[] a = string_split(file_get_contents("notadg.svr").replace("\r\n", "\n"), "\n");
			int something = a.find(parsed[1]);
			if (something > -1) {
				send_reliable(p, "You can't put " + parsed[1] + " in this box", 2);
				return;
			}
			p.inv_add_item(parsed[1], -amount);
			p.inv_add_item("package_of_" + amount + "_" + parsed[1], 1);
			p.inv_add_item("box", -1);
			send_packet(6, "play giftopen3.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			send_reliable(p, "You put " + amount + " " + parsed[1] + " in a box and close it", 2);
		}
	} else if (parsed[0] == "ttlp") {
		string[] a = find_files("maptlps/*/!.map");
		string m;
		for (uint i = 0; i < a.length(); i++) {
			if (i < a.length()) m += a[i] + "\n";
			else if (i == a.length() - 1) m += a[i];
		}
		send_reliable(p, "tlptester " + m, 0);
	} else if (parsed[0] == "serverstats") {
		string received = convert_size(n.bytes_received);
		string sent = convert_size(n.bytes_sent);
		string totalreceived = convert_size(n.bytes_sent + n.bytes_received);
		int peers = n.get_peer_list().length();
		string[] chars = find_directories("chars/*");
		double finalms = 0;
		for (uint i = 0; i < chars.length(); i++) {
			if (file_exists("chars/" + chars[i] + "/playtime.usr"))
				finalms += string_to_number(get_char_val(chars[i], "playtime"));
		}
		send_reliable(p, "Server Stats: There are " + peers + " connected peers, with " + received + " received, and " + sent + " sent, Total: " + totalreceived + ". Peak: " + peak + ". Reached on: " + peakreached + ". Everyone's combined playtime is " + ms_to_readable_time(finalms) + ". " + connections + " Connections, and " + disconnections + " disconnections", 2);
	} else if (parsed[0] == "addsrc") {
		string maptext = string_replace(get_event_message(), "addsrc ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addopening_hours") {
		string maptext = string_replace(get_event_message(), "addopening_hours ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addlevel") {
		string maptext = string_replace(get_event_message(), "addlevel ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addreinforcement") {
		string maptext = string_replace(get_event_message(), "addreinforcement ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addmusic") {
		string maptext = string_replace(get_event_message(), "addmusic ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addvending_machine" and p.is_admin()) {
		string maptext = string_replace(get_event_message(), "addvending_machine ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addcheckpoint") {
		string maptext = string_replace(get_event_message(), "addcheckpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addowner") {
		string maptext = string_replace(get_event_message(), "addowner ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
		string maptxt = string_replace(get_event_message(), "addowner owner:", "", false);
		if (string_contains(p.map, "house_of_", 1) < 0) file_put_contents("chars/" + maptxt + "/maps.usr", "" + p.map + "\n", 255);
	} else if (parsed[0] == "addline") {
		string maptext = string_replace(get_event_message(), "addline ", "", false).replace("\r\n", "\n");
		string[] lines = string_split(maptext, "\n");
		for (uint i = 0; i < lines.length(); i++) {
		}
		string[] ld = string_split(maptext, ":", false);
		if (ld.length() < 1) {
			send_reliable(p, "maps update error: all map commands take at least one argument", 0);
			return;
		} else if (ld[0] == "mapname" and ld[1] != p.map) {
			send_reliable(p, "maps update error: map names do not match", 0);
			return;
		} else if (ld[0] == "item" and ld.length() < 10) {
			send_reliable(p, "maps update error: item spawn declaration has too few arguments. Syntax is item:minx:maxx:miny:maxy:minz:maxz:time:maxobjs:objs:amount, got " + maptext, 0);
			return;
		} else if (ld[0] == "task_status" and ld.length() < 9) {
			send_reliable(p, "maps update error: task status spawn declaration has too few arguments. Syntax is task_status:minX:maxX:minY:maxY:minZ:maxZ:item:amount, got " + maptext, 0);
			return;
		} else if (ld[0] == "pvp" and ld.length() < 8) {
			send_reliable(p, "maps update error: pvp spawn declaration has too few arguments. Syntax is pvp:minX:maxX:minY:maxY:minZ:maxZ:pvpStatus, got " + maptext, 0);
			return;
		} else if (ld[0] == "specified_air_temperature" and ld.length() < 8) {
			send_reliable(p, "maps update error: specified air temperature spawn declaration has too few arguments. Syntax is task_status:minX:maxX:minY:maxY:minZ:maxZ:specified_air_temperature, got " + maptext, 0);
			return;
		}
		else if (ld[0] == "item_usage_restriction" and ld.length() < 8) {
			send_reliable(p, "maps update error: item usage restriction spawn declaration has too few arguments. Syntax is item_usage_restriction:minx:maxx:miny:maxy:minz:maxz:items, got " + maptext, 0);
			return;
		} else if (ld[0] == "fishingcoordinate" and ld.length() < 6) {
			send_reliable(p, "maps update error: declaration of fishing coordinate has too few arguments. Syntax is fishingcoordinate:minx:maxx:miny:maxy:minz:maxz, got " + maptext, 0);
			return;
		} else if (ld[0] == "ai" and p.is_admin() == false)
			return;
		else if (ld[0] == "item" and p.is_admin() == false)
			return;
		else if (ld[0] == "task_status" and p.is_admin() == false)
			return;
		else if (ld[0] == "vending_machine" and p.is_admin() == false)
			return;
		else if (ld[0] == "fishing_coordinate" and p.is_admin() == false)
			return;
		else if (ld[0] == "toilet" and ld.length() < 6) {
			send_reliable(p, "maps update error: declaration of toilet has too few arguments. Syntax is toilet:minx:maxx:miny:maxy:minz:maxz, got " + maptext, 0);
			return;
		} else if (ld[0] == "trashcan" and ld.length() < 6) {
			send_reliable(p, "maps update error: declaration of trashcan has too few arguments. Syntax is trashcan:minx:maxx:miny:maxy:minz:maxz, got " + maptext, 0);
			return;
		} else if (ld[0] == "bed" and ld.length() < 6) {
			send_reliable(p, "maps update error: declaration of bed has too few arguments. Syntax is bed:minx:maxx:miny:maxy:minz:maxz, got " + maptext, 0);
			return;
		} else if (ld[0] == "clock" and ld.length() < 6) {
			send_reliable(p, "maps update error: declaration of clock has too few arguments. Syntax is clock:minx:maxx:miny:maxy:minz:maxz:optional_text, got " + maptext, 0);
			return;
		} else if (ld[0] == "calendar" and ld.length() < 6) {
			send_reliable(p, "maps update error: declaration of calendar has too few arguments. Syntax is calendar:minx:maxx:miny:maxy:minz:maxz:optional_text, got " + maptext, 0);
			return;
		} else if (ld[0] == "oven" and ld.length() < 6) {
			send_reliable(p, "maps update error: declaration of oven has too few arguments. Syntax is oven:minx:maxx:miny:maxy:minz:maxz, got " + maptext, 0);
			return;
		} else if (ld[0] == "starting_point" and ld.length() < 6) {
			send_reliable(p, "maps update error: declaration of starting_point has too few arguments. Syntax is starting_point:minx:maxx:miny:maxy:minz:maxz, got " + maptext, 0);
			return;
		} else if (ld[0] == "deathpoint" and ld.length() < 6) {
			send_reliable(p, "maps update error: declaration of deathpoint has too few arguments. Syntax is deathpoint:minx:maxx:miny:maxy:minz:maxz, got " + maptext, 0);
			return;
		} else if (ld[0] == "washbasin" and ld.length() < 6) {
			send_reliable(p, "maps update error: declaration of washbasin has too few arguments. Syntax is washbasin:minx:maxx:miny:maxy:minz:maxz, got " + maptext, 0);
			return;
		} else if (ld[0] == "shower" and ld.length() < 6) {
			send_reliable(p, "maps update error: declaration of shower has too few arguments. Syntax is shower:minx:maxx:miny:maxy:minz:maxz, got " + maptext, 0);
			return;
		} else if (ld[0] == "travelpoint" and ld.length() < 12) {
			send_reliable(p, "maps update error: travelpoint declaration has too few arguments. Syntax is travelpoint:minx:maxx:miny:maxy:minz:maxz:newmap:newx:newy:newz:text:extra_functions, got " + maptext, 0);
			return;
		} else if (ld[0] == "tile" and ld.length() < 8) {
			send_reliable(p, "maps update error: declaration of tile has too few arguments. Syntax is tile:minx:maxx:miny:maxy:minz:maxz:type, got " + maptext, 0);
			return;
		} else if (ld[0] == "zone" and ld.length() < 8) {
			send_reliable(p, "maps update error: declaration of zone has too few arguments. Syntax is zone:minx:maxx:miny:maxy:minz:maxz:text[:trackme], got " + maptext, 0);
			return;
		} else if ((string_contains(maptext, "_store", 1) > -1 or string_contains(maptext, "bank_service_desk", 1) > -1 or string_contains(maptext, "cash_machine", 1) > -1 or string_contains(maptext, "cash_miner", 1) > -1 or string_contains(maptext, "civil registry office", 1) > -1 or string_contains(maptext, "entertainment_center", 1) > -1 or string_contains(maptext, "employment_agency", 1) > -1 or string_contains(maptext, "cemetery", 1) > -1) and p.is_admin() == false) {
			send_reliable(p, "maps update error: zone declaration is not allowed, got " + maptext, 0);
			return;
		} else if (ld[0] == "safezone" and ld.length() < 5) {
			send_reliable(p, "maps update error: declaration of safe zone has too few arguments. Syntax is safezone:minx:maxx:miny:maxy:minz:maxz, got " + maptext, 0);
			return;
		} else if (ld[0] == "txt" and ld.length() < 6) {
			send_reliable(p, "maps update error: declaration of txt has too few arguments. Syntax is txt:minx:maxx:miny:maxy:minz:maxz:text, got " + maptext, 0);
			return;
		} else if (ld[0] == "sign" and ld.length() < 7) {
			send_reliable(p, "maps update error: declaration of sign has too few arguments. Syntax is sign:minx:maxx:miny:maxy:minz:maxz:text:soundname, got " + maptext, 0);
			return;
		} else if (ld[0] == "timedtext" and ld.length() < 8) {
			send_reliable(p, "maps update error: declaration of timed text has too few arguments. Syntax is timedtext:minx:maxx:miny:maxy:minz:maxz:time:text, got " + maptext, 0);
			return;
		} else if (ld[0] == "vanishing_platform" and ld.length() < 10) {
			send_reliable(p, "maps update error: declaration of vanishing platform has too few arguments. Syntax is vanishing_platform:min_x:max_x:min_y:max_y:min_z:max_z:time:tile:sound, got " + maptext, 0);
			return;
		} else if (ld[0] == "forcefield" and ld.length() < 10) {
			send_reliable(p, "maps update error: declaration of forcefield has too few arguments. Syntax is forcefield:min_x:max_x:min_y:max_y:min_z:max_z:time:health:sound, got " + maptext, 0);
			return;
		} else if (ld[0] == "checkpoint" and ld.length() < 4) {
			send_reliable(p, "maps update error: declaration of checkpoint has too few arguments. Syntax is checkpoint:x:y:z, got " + maptext, 0);
			return;
		} else if (ld[0] == "hazard" and ld.length() < 7) {
			send_reliable(p, "maps update error: declaration of hazard has too few arguments. Syntax is hazard:min_x:max_x:min_y:max_y:min_z:max_z, got " + maptext, 0);
			return;
		} else if (ld[0] == "teleporter" and ld.length() < 7) {
			send_reliable(p, "maps update error: declaration of teleporter has too few arguments. Syntax is teleporter:min_x:max_x:min_y:max_y:min_z:max_z, got " + maptext, 0);
			return;
		} else if (ld[0] == "door" and ld.length() < 16) {
			send_reliable(p, "maps update error: declaration of door has too few arguments. Syntax is door:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text:speed:loop:moveloop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "pdoor" and ld.length() < 17) {
			send_reliable(p, "maps update error: declaration of password protected door has too few arguments. Syntax is door:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:password:speed:loop:moveloop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "icdoor" and ld.length() < 18) {
			send_reliable(p, "maps update error: declaration of item checker door has too few arguments. Syntax is door:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:speed:loop:moveloop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "itdoor" and ld.length() < 18) {
			send_reliable(p, "maps update error: declaration of item taker door has too few arguments. Syntax is door:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:speed:loop:moveloop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "igdoor" and ld.length() < 18) {
			send_reliable(p, "maps update error: declaration of item giver door has too few arguments. Syntax is door:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:speed:loop:moveloop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "igdoor" and p.is_admin() == false)
			return;
		else if (ld[0] == "automover" and ld.length() < 16) {
			send_reliable(p, "maps update error: declaration of automover has too few arguments. Syntax is automover:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text:speed:loop:moveloop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "pautomover" and ld.length() < 17) {
			send_reliable(p, "maps update error: declaration of password protected automover has too few arguments. Syntax is automover:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:password:speed:loop:moveloop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "icautomover" and ld.length() < 18) {
			send_reliable(p, "maps update error: declaration of item checker automover has too few arguments. Syntax is automover:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:speed:loop:moveloop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "itautomover" and ld.length() < 18) {
			send_reliable(p, "maps update error: declaration of item taker automover has too few arguments. Syntax is automover:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:speed:loop:moveloop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "igautomover" and ld.length() < 18) {
			send_reliable(p, "maps update error: declaration of item giver automover has too few arguments. Syntax is automover:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:speed:loop:moveloop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "igautomover" and p.is_admin() == false)
			return;
		else if (ld[0] == "automatic_travelpoint" and ld.length() < 15) {
			send_reliable(p, "maps update error: declaration of automatic_travelpoint has too few arguments. Syntax is automatic_travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text:loop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "pautomatic_travelpoint" and ld.length() < 16) {
			send_reliable(p, "maps update error: declaration of password protected automatic_travelpoint has too few arguments. Syntax is automatic_travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:password:loop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "icautomatic_travelpoint" and ld.length() < 17) {
			send_reliable(p, "maps update error: declaration of item checker automatic_travelpoint has too few arguments. Syntax is automatic_travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:loop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "itautomatic_travelpoint" and ld.length() < 17) {
			send_reliable(p, "maps update error: declaration of item taker automatic_travelpoint has too few arguments. Syntax is automatic_travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:loop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "igautomatic_travelpoint" and ld.length() < 17) {
			send_reliable(p, "maps update error: declaration of item giver automatic_travelpoint has too few arguments. Syntax is automatic_travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:loop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "igautomatic_travelpoint" and p.is_admin() == false)
			return;
		else if (ld[0] == "travelpoint" and ld.length() < 15) {
			send_reliable(p, "maps update error: declaration of travelpoint has too few arguments. Syntax is travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text:loop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "ptravelpoint" and ld.length() < 16) {
			send_reliable(p, "maps update error: declaration of password protected travelpoint has too few arguments. Syntax is travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:password:loop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "ictravelpoint" and ld.length() < 17) {
			send_reliable(p, "maps update error: declaration of item checker travelpoint has too few arguments. Syntax is travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:loop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "ittravelpoint" and ld.length() < 17) {
			send_reliable(p, "maps update error: declaration of item taker travelpoint has too few arguments. Syntax is travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:loop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "igtravelpoint" and ld.length() < 17) {
			send_reliable(p, "maps update error: declaration of item giver travelpoint has too few arguments. Syntax is travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:loop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "igtravelpoint" and p.is_admin() == false)
			return;
		else if (ld[0] == "src" and ld.length() < 10) {
			send_reliable(p, "maps update error: declaration of source has too few arguments. Syntax is src:minx:maxx:miny:maxy:minz:maxz:volume:pitch:loop.ogg[:id], got " + maptext, 0);
			return;
		} else if (ld[0] == "music" and ld.length() < 10) {
			send_reliable(p, "maps update error: declaration of music has too few arguments. Syntax is music:minx:maxx:miny:maxy:minz:maxz:volume:pitch:loop.ogg[:id], got " + maptext, 0);
			return;
		} else if (ld[0] == "timedsound" and ld.length() < 10) {
			send_reliable(p, "maps update error: declaration of timed sound has too few arguments. Syntax is timedsound:minx:maxx:miny:maxy:minz:maxz:time:volume:pitch:soundname, got " + maptext, 0);
			return;
		} else if (ld[0] == "timedmusic" and ld.length() < 10) {
			send_reliable(p, "maps update error: declaration of timed music has too few arguments. Syntax is timedmusic:minx:maxx:miny:maxy:minz:maxz:time:volume:pitch:musicname, got " + maptext, 0);
			return;
		}
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addeditline") {
		string maptext = string_replace(get_event_message(), "addeditline ", "", false);
		string[] ld = string_split(maptext, ":", false);
		if (ld.length() < 1) {
			send_reliable(p, "maps update error: all map commands take at least one argument", 0);
			return;
		} else if (ld[0] == "mapname" and ld[1] != p.map) {
			send_reliable(p, "maps update error: map names do not match", 0);
			return;
		} else if (ld[0] == "item" and ld.length() < 10) {
			send_reliable(p, "maps update error: item spawn declaration has too few arguments. Syntax is item:minx:maxx:miny:maxy:minz:maxz:time:maxobjs:objs:amount, got " + maptext, 0);
			return;
		} else if (ld[0] == "task_status" and ld.length() < 9) {
			send_reliable(p, "maps update error: task status spawn declaration has too few arguments. Syntax is task_status:minX:maxX:minY:maxY:minZ:maxZ:item:amount, got " + maptext, 0);
			return;
		} else if (ld[0] == "pvp" and ld.length() < 8) {
			send_reliable(p, "maps update error: pvp spawn declaration has too few arguments. Syntax is pvp:minX:maxX:minY:maxY:minZ:maxZ:pvpStatus, got " + maptext, 0);
			return;
		} else if (ld[0] == "specified_air_temperature" and ld.length() < 8) {
			send_reliable(p, "maps update error: specified air temperature spawn declaration has too few arguments. Syntax is task_status:minX:maxX:minY:maxY:minZ:maxZ:specified_air_temperature, got " + maptext, 0);
			return;
		} else if (ld[0] == "item_usage_restriction" and ld.length() < 8) {
			send_reliable(p, "maps update error: item usage restriction spawn declaration has too few arguments. Syntax is item_usage_restriction:minx:maxx:miny:maxy:minz:maxz:items, got " + maptext, 0);
			return;
		} else if (ld[0] == "fishingcoordinate" and ld.length() < 6) {
			send_reliable(p, "maps update error: declaration of fishing coordinate has too few arguments. Syntax is fishingcoordinate:minx:maxx:miny:maxy:minz:maxz, got " + maptext, 0);
			return;
		} else if (ld[0] == "ai" and p.is_admin() == false)
			return;
		else if (ld[0] == "item" and p.is_admin() == false)
			return;
		else if (ld[0] == "task_status" and p.is_admin() == false)
			return;
		else if (ld[0] == "vending_machine" and p.is_admin() == false)
			return;
		else if (ld[0] == "fishing_coordinate" and p.is_admin() == false)
			return;
		else if (ld[0] == "toilet" and ld.length() < 6) {
			send_reliable(p, "maps update error: declaration of toilet has too few arguments. Syntax is toilet:minx:maxx:miny:maxy:minz:maxz, got " + maptext, 0);
			return;
		} else if (ld[0] == "trashcan" and ld.length() < 6) {
			send_reliable(p, "maps update error: declaration of trashcan has too few arguments. Syntax is trashcan:minx:maxx:miny:maxy:minz:maxz, got " + maptext, 0);
			return;
		} else if (ld[0] == "bed" and ld.length() < 6) {
			send_reliable(p, "maps update error: declaration of bed has too few arguments. Syntax is bed:minx:maxx:miny:maxy:minz:maxz, got " + maptext, 0);
			return;
		} else if (ld[0] == "clock" and ld.length() < 6) {
			send_reliable(p, "maps update error: declaration of clock has too few arguments. Syntax is clock:minx:maxx:miny:maxy:minz:maxz:optional_text, got " + maptext, 0);
			return;
		} else if (ld[0] == "calendar" and ld.length() < 6) {
			send_reliable(p, "maps update error: declaration of calendar has too few arguments. Syntax is calendar:minx:maxx:miny:maxy:minz:maxz:optional_text, got " + maptext, 0);
			return;
		} else if (ld[0] == "oven" and ld.length() < 6) {
			send_reliable(p, "maps update error: declaration of oven has too few arguments. Syntax is oven:minx:maxx:miny:maxy:minz:maxz, got " + maptext, 0);
			return;
		} else if (ld[0] == "starting_point" and ld.length() < 6) {
			send_reliable(p, "maps update error: declaration of starting_point has too few arguments. Syntax is starting_point:minx:maxx:miny:maxy:minz:maxz, got " + maptext, 0);
			return;
		} else if (ld[0] == "deathpoint" and ld.length() < 6) {
			send_reliable(p, "maps update error: declaration of deathpoint has too few arguments. Syntax is deathpoint:minx:maxx:miny:maxy:minz:maxz, got " + maptext, 0);
			return;
		} else if (ld[0] == "washbasin" and ld.length() < 6) {
			send_reliable(p, "maps update error: declaration of washbasin has too few arguments. Syntax is washbasin:minx:maxx:miny:maxy:minz:maxz, got " + maptext, 0);
			return;
		} else if (ld[0] == "shower" and ld.length() < 6) {
			send_reliable(p, "maps update error: declaration of shower has too few arguments. Syntax is shower:minx:maxx:miny:maxy:minz:maxz, got " + maptext, 0);
			return;
		} else if (ld[0] == "travelpoint" and ld.length() < 12) {
			send_reliable(p, "maps update error: travelpoint declaration has too few arguments. Syntax is travelpoint:minx:maxx:miny:maxy:minz:maxz:newmap:newx:newy:newz:text:extra_functions, got " + maptext, 0);
			return;
		} else if (ld[0] == "tile" and ld.length() < 8) {
			send_reliable(p, "maps update error: declaration of tile has too few arguments. Syntax is tile:minx:maxx:miny:maxy:minz:maxz:type, got " + maptext, 0);
			return;
		} else if (ld[0] == "zone" and ld.length() < 8) {
			send_reliable(p, "maps update error: declaration of zone has too few arguments. Syntax is zone:minx:maxx:miny:maxy:minz:maxz:text[:trackme], got " + maptext, 0);
			return;
		} else if ((string_contains(maptext, "_store", 1) > -1 or string_contains(maptext, "bank_service_desk", 1) > -1 or string_contains(maptext, "cash_machine", 1) > -1 or string_contains(maptext, "cash_miner", 1) > -1 or string_contains(maptext, "civil registry office", 1) > -1 or string_contains(maptext, "entertainment_center", 1) > -1 or string_contains(maptext, "employment_agency", 1) > -1 or string_contains(maptext, "cemetery", 1) > -1) and p.is_admin() == false) {
			send_reliable(p, "maps update error: zone declaration is not allowed, got " + maptext, 0);
			return;
		} else if (ld[0] == "safezone" and ld.length() < 5) {
			send_reliable(p, "maps update error: declaration of safe zone has too few arguments. Syntax is safezone:minx:maxx:miny:maxy:minz:maxz, got " + maptext, 0);
			return;
		} else if (ld[0] == "txt" and ld.length() < 6) {
			send_reliable(p, "maps update error: declaration of txt has too few arguments. Syntax is txt:minx:maxx:miny:maxy:minz:maxz:text, got " + maptext, 0);
			return;
		} else if (ld[0] == "sign" and ld.length() < 7) {
			send_reliable(p, "maps update error: declaration of sign has too few arguments. Syntax is sign:minx:maxx:miny:maxy:minz:maxz:text:soundname, got " + maptext, 0);
			return;
		} else if (ld[0] == "timedtext" and ld.length() < 8) {
			send_reliable(p, "maps update error: declaration of timed text has too few arguments. Syntax is timedtext:minx:maxx:miny:maxy:minz:maxz:time:text, got " + maptext, 0);
			return;
		} else if (ld[0] == "vanishing_platform" and ld.length() < 10) {
			send_reliable(p, "maps update error: declaration of vanishing platform has too few arguments. Syntax is vanishing_platform:min_x:max_x:min_y:max_y:min_z:max_z:time:tile:sound, got " + maptext, 0);
			return;
		} else if (ld[0] == "forcefield" and ld.length() < 10) {
			send_reliable(p, "maps update error: declaration of forcefield has too few arguments. Syntax is forcefield:min_x:max_x:min_y:max_y:min_z:max_z:time:health:sound, got " + maptext, 0);
			return;
		} else if (ld[0] == "checkpoint" and ld.length() < 4) {
			send_reliable(p, "maps update error: declaration of checkpoint has too few arguments. Syntax is checkpoint:x:y:z, got " + maptext, 0);
			return;
		} else if (ld[0] == "hazard" and ld.length() < 7) {
			send_reliable(p, "maps update error: declaration of hazard has too few arguments. Syntax is hazard:min_x:max_x:min_y:max_y:min_z:max_z, got " + maptext, 0);
			return;
		} else if (ld[0] == "teleporter" and ld.length() < 7) {
			send_reliable(p, "maps update error: declaration of teleporter has too few arguments. Syntax is teleporter:min_x:max_x:min_y:max_y:min_z:max_z, got " + maptext, 0);
			return;
		} else if (ld[0] == "door" and ld.length() < 16) {
			send_reliable(p, "maps update error: declaration of door has too few arguments. Syntax is door:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text:speed:loop:moveloop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "pdoor" and ld.length() < 17) {
			send_reliable(p, "maps update error: declaration of password protected door has too few arguments. Syntax is door:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:password:speed:loop:moveloop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "icdoor" and ld.length() < 18) {
			send_reliable(p, "maps update error: declaration of item checker door has too few arguments. Syntax is door:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:speed:loop:moveloop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "itdoor" and ld.length() < 18) {
			send_reliable(p, "maps update error: declaration of item taker door has too few arguments. Syntax is door:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:speed:loop:moveloop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "igdoor" and ld.length() < 18) {
			send_reliable(p, "maps update error: declaration of item giver door has too few arguments. Syntax is door:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:speed:loop:moveloop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "igdoor" and p.is_admin() == false)
			return;
		else if (ld[0] == "automover" and ld.length() < 16) {
			send_reliable(p, "maps update error: declaration of automover has too few arguments. Syntax is automover:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text:speed:loop:moveloop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "pautomover" and ld.length() < 17) {
			send_reliable(p, "maps update error: declaration of password protected automover has too few arguments. Syntax is automover:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:password:speed:loop:moveloop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "icautomover" and ld.length() < 18) {
			send_reliable(p, "maps update error: declaration of item checker automover has too few arguments. Syntax is automover:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:speed:loop:moveloop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "itautomover" and ld.length() < 18) {
			send_reliable(p, "maps update error: declaration of item taker automover has too few arguments. Syntax is automover:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:speed:loop:moveloop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "igautomover" and ld.length() < 18) {
			send_reliable(p, "maps update error: declaration of item giver automover has too few arguments. Syntax is automover:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:speed:loop:moveloop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "igautomover" and p.is_admin() == false)
			return;
		else if (ld[0] == "automatic_travelpoint" and ld.length() < 15) {
			send_reliable(p, "maps update error: declaration of automatic_travelpoint has too few arguments. Syntax is automatic_travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text:loop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "pautomatic_travelpoint" and ld.length() < 16) {
			send_reliable(p, "maps update error: declaration of password protected automatic_travelpoint has too few arguments. Syntax is automatic_travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:password:loop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "icautomatic_travelpoint" and ld.length() < 17) {
			send_reliable(p, "maps update error: declaration of item checker automatic_travelpoint has too few arguments. Syntax is automatic_travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:loop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "itautomatic_travelpoint" and ld.length() < 17) {
			send_reliable(p, "maps update error: declaration of item taker automatic_travelpoint has too few arguments. Syntax is automatic_travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:loop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "igautomatic_travelpoint" and ld.length() < 17) {
			send_reliable(p, "maps update error: declaration of item giver automatic_travelpoint has too few arguments. Syntax is automatic_travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:loop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "igautomatic_travelpoint" and p.is_admin() == false)
			return;
		else if (ld[0] == "travelpoint" and ld.length() < 15) {
			send_reliable(p, "maps update error: declaration of travelpoint has too few arguments. Syntax is travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text:loop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "ptravelpoint" and ld.length() < 16) {
			send_reliable(p, "maps update error: declaration of password protected travelpoint has too few arguments. Syntax is travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:password:loop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "ictravelpoint" and ld.length() < 17) {
			send_reliable(p, "maps update error: declaration of item checker travelpoint has too few arguments. Syntax is travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:loop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "ittravelpoint" and ld.length() < 17) {
			send_reliable(p, "maps update error: declaration of item taker travelpoint has too few arguments. Syntax is travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:loop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "igtravelpoint" and ld.length() < 17) {
			send_reliable(p, "maps update error: declaration of item giver travelpoint has too few arguments. Syntax is travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:loop:opensound:closesound, got " + maptext, 0);
			return;
		} else if (ld[0] == "igtravelpoint" and p.is_admin() == false)
			return;
		else if (ld[0] == "src" and ld.length() < 10) {
			send_reliable(p, "maps update error: declaration of source has too few arguments. Syntax is src:minx:maxx:miny:maxy:minz:maxz:volume:pitch:loop.ogg[:id], got " + maptext, 0);
			return;
		} else if (ld[0] == "music" and ld.length() < 10) {
			send_reliable(p, "maps update error: declaration of music has too few arguments. Syntax is music:minx:maxx:miny:maxy:minz:maxz:volume:pitch:loop.ogg[:id], got " + maptext, 0);
			return;
		} else if (ld[0] == "timedsound" and ld.length() < 10) {
			send_reliable(p, "maps update error: declaration of timed sound has too few arguments. Syntax is timedsound:minx:maxx:miny:maxy:minz:maxz:time:volume:pitch:soundname, got " + maptext, 0);
			return;
		} else if (ld[0] == "timedmusic" and ld.length() < 10) {
			send_reliable(p, "maps update error: declaration of timed music has too few arguments. Syntax is timedmusic:minx:maxx:miny:maxy:minz:maxz:time:volume:pitch:musicname, got " + maptext, 0);
			return;
		}
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mdata = f.read().replace("\r\n", "\n");
		f.close();
		string[] mapdata = string_split(mdata, "\n");
		int something = mapdata.find(p.editline);
		if (something > -1) {
			mapdata.remove_at(something);
			mapdata.insert_at(something, maptext);
			file_put_contents("maps/" + p.map + "/!.map", linear(mapdata), 250);
			send_reliable(p, "Map updated", 0);
			mapupdate(p.map);map_updated(p.map);
		}
	} else if (parsed[0] == "addremoveline" and parsed.length() > 1) {
		string maptext = string_replace(get_event_message(), "addremoveline ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mdata = f.read().replace("\r\n", "\n");
		f.close();
		string[] mapdata = string_split(mdata, "\n");
		int something = mapdata.find(p.removeline);
		if (something > -1) {
			mapdata.remove_at(something);
			file_put_contents("maps/" + p.map + "/!.map", linear(mapdata), 250);
			send_reliable(p, "Map updated", 0);
			mapupdate(p.map);map_updated(p.map);
		}
	} else if (parsed[0] == "addremoveowner" and parsed.length() > 1) {
		string maptext = string_replace(get_event_message(), "addremoveowner ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mdata = f.read().replace("\r\n", "\n");
		f.close();
		string[] mapdata = string_split(mdata, "\n");
		int something = mapdata.find(p.removeowner);
		if (something > -1) {
			mapdata.remove_at(something);
			file_put_contents("maps/" + p.map + "/!.map", linear(mapdata), 250);
			send_reliable(p, "Map updated", 0);
			mapupdate(p.map);map_updated(p.map);
			string maptxt = string_replace(get_event_message(), "addremoveowner owner:", "", false);
			f.open("chars/" + maptxt + "/maps.usr", "rb");
			mdata = f.read().replace("\r\n", "\n");
			f.close();
			mapdata = string_split(mdata, "\n");
			something = mapdata.find(p.removeowner);
			if (something > -1) {
				mapdata.remove_at(something);
				file_put_contents("chars/" + maptxt + "/maps.usr", linear(mapdata), 250);
			}
		}
	} else if (parsed[0] == "addlitem") {
		string maptext = string_replace(get_event_message(), "addlitem ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddescription") {
		string maptext = string_replace(get_event_message(), "adddescription ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addpvp") {
		string maptext = string_replace(get_event_message(), "addpvp ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addtoilet") {
		string maptext = string_replace(get_event_message(), "addtoilet ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addtrashcan") {
		string maptext = string_replace(get_event_message(), "addtrashcan ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addstarting_point") {
		string maptext = string_replace(get_event_message(), "addstarting_point ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddeathpoint") {
		string maptext = string_replace(get_event_message(), "adddeathpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addwashbasin") {
		string maptext = string_replace(get_event_message(), "addwashbasin ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addfiremap") {
		string maptext = string_replace(get_event_message(), "addfiremap ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addtask_status") {
		string maptext = string_replace(get_event_message(), "addtask_status ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addshower") {
		string maptext = string_replace(get_event_message(), "addshower ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addtxt") {
		string maptext = string_replace(get_event_message(), "addtxt ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddialog") {
		string maptext = string_replace(get_event_message(), "adddialog ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addautomatic_dialog") {
		string maptext = string_replace(get_event_message(), "addautomatic_dialog ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addtimedtext") {
		string maptext = string_replace(get_event_message(), "addtimedtext ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addtimedsound") {
		string maptext = string_replace(get_event_message(), "addtimedsound ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addtimedmusic") {
		string maptext = string_replace(get_event_message(), "addtimedmusic ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "additem" and p.is_admin()) {
		string maptext = string_replace(get_event_message(), "additem ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "additem_usage_restriction") {
		string maptext = string_replace(get_event_message(), "additem_usage_restriction ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addAI" and p.is_admin()) {
		string maptext = string_replace(get_event_message(), "addAI ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addsign") {
		string maptext = string_replace(get_event_message(), "addsign ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addurl") {
		string maptext = string_replace(get_event_message(), "addurl ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addvanishing_platform") {
		string maptext = string_replace(get_event_message(), "addvanishing_platform ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addforcefield") {
		string maptext = string_replace(get_event_message(), "addforcefield ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addhazard") {
		string maptext = string_replace(get_event_message(), "addhazard ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addteleporter") {
		string maptext = string_replace(get_event_message(), "addteleporter ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addspecified_air_temperature") {
		string maptext = string_replace(get_event_message(), "addspecified_air_temperature ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddoor") {
		string maptext = string_replace(get_event_message(), "adddoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addpdoor") {
		string maptext = string_replace(get_event_message(), "addpdoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addicdoor") {
		string maptext = string_replace(get_event_message(), "addicdoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "additdoor") {
		string maptext = string_replace(get_event_message(), "additdoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addigdoor") {
		string maptext = string_replace(get_event_message(), "addigdoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addautomover") {
		string maptext = string_replace(get_event_message(), "addautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addpautomover") {
		string maptext = string_replace(get_event_message(), "addpautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addicautomover") {
		string maptext = string_replace(get_event_message(), "addicautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "additautomover") {
		string maptext = string_replace(get_event_message(), "additautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addigautomover") {
		string maptext = string_replace(get_event_message(), "addigautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addautomatic_travelpoint") {
		file f;
		string maptext = string_replace(get_event_message(), "addautomatic_travelpoint ", "", false);
		if (p.is_admin() == false) {
			string[] a = string_split(file_get_contents("chars/" + p.name + "/maps.usr").replace("\r\n", "\n"), "\n");
			for (uint i = 0; i < a.length(); i++) {
				if (string_contains(maptext, a[i], 1) > -1) {
					f.open("maps/" + p.map + "/!.map", "rb");
					string mapdata = f.read().replace("\r\n", "\n");
					f.close();
					mapdata += "\n" + maptext;
					f.open("maps/" + p.map + "/!.map", "wb");
					f.write(mapdata);
					f.close();
					send_reliable(p, "Map updated", 0);
					mapupdate(p.map);map_updated(p.map);
				}
			}
		} else {
			f.open("maps/" + p.map + "/!.map", "rb");
			string mapdata = f.read().replace("\r\n", "\n");
			f.close();
			mapdata += "\n" + maptext;
			f.open("maps/" + p.map + "/!.map", "wb");
			f.write(mapdata);
			f.close();
			send_reliable(p, "Map updated", 0);
			mapupdate(p.map);map_updated(p.map);
		}
	} else if (parsed[0] == "addpautomatic_travelpoint") {
		string maptext = string_replace(get_event_message(), "addpautomatic_travelpoint ", "", false);
		file f;
		if (p.is_admin() == false) {
			string[] a = string_split(file_get_contents("chars/" + p.name + "/maps.usr").replace("\r\n", "\n"), "\n");
			for (uint i = 0; i < a.length(); i++) {
				if (string_contains(maptext, a[i], 1) > -1) {
					f.open("maps/" + p.map + "/!.map", "rb");
					string mapdata = f.read().replace("\r\n", "\n");
					f.close();
					mapdata += "\n" + maptext;
					f.open("maps/" + p.map + "/!.map", "wb");
					f.write(mapdata);
					f.close();
					send_reliable(p, "Map updated", 0);
					mapupdate(p.map);map_updated(p.map);
				}
			}
		} else {
			f.open("maps/" + p.map + "/!.map", "rb");
			string mapdata = f.read().replace("\r\n", "\n");
			f.close();
			mapdata += "\n" + maptext;
			f.open("maps/" + p.map + "/!.map", "wb");
			f.write(mapdata);
			f.close();
			send_reliable(p, "Map updated", 0);
			mapupdate(p.map);map_updated(p.map);
		}
	} else if (parsed[0] == "addicautomatic_travelpoint") {
		string maptext = string_replace(get_event_message(), "addicautomatic_travelpoint ", "", false);
		file f;
		if (p.is_admin() == false) {
			string[] a = string_split(file_get_contents("chars/" + p.name + "/maps.usr").replace("\r\n", "\n"), "\n");
			for (uint i = 0; i < a.length(); i++) {
				if (string_contains(maptext, a[i], 1) > -1) {
					f.open("maps/" + p.map + "/!.map", "rb");
					string mapdata = f.read().replace("\r\n", "\n");
					f.close();
					mapdata += "\n" + maptext;
					f.open("maps/" + p.map + "/!.map", "wb");
					f.write(mapdata);
					f.close();
					send_reliable(p, "Map updated", 0);
					mapupdate(p.map);map_updated(p.map);
				}
			}
		} else {
			f.open("maps/" + p.map + "/!.map", "rb");
			string mapdata = f.read().replace("\r\n", "\n");
			f.close();
			mapdata += "\n" + maptext;
			f.open("maps/" + p.map + "/!.map", "wb");
			f.write(mapdata);
			f.close();
			send_reliable(p, "Map updated", 0);
			mapupdate(p.map);map_updated(p.map);
		}
	} else if (parsed[0] == "additautomatic_travelpoint") {
		string maptext = string_replace(get_event_message(), "additautomatic_travelpoint ", "", false);
		file f;
		if (p.is_admin() == false) {
			string[] a = string_split(file_get_contents("chars/" + p.name + "/maps.usr").replace("\r\n", "\n"), "\n");
			for (uint i = 0; i < a.length(); i++) {
				if (string_contains(maptext, a[i], 1) > -1) {
					f.open("maps/" + p.map + "/!.map", "rb");
					string mapdata = f.read().replace("\r\n", "\n");
					f.close();
					mapdata += "\n" + maptext;
					f.open("maps/" + p.map + "/!.map", "wb");
					f.write(mapdata);
					f.close();
					send_reliable(p, "Map updated", 0);
					mapupdate(p.map);map_updated(p.map);
				}
			}
		} else {
			f.open("maps/" + p.map + "/!.map", "rb");
			string mapdata = f.read().replace("\r\n", "\n");
			f.close();
			mapdata += "\n" + maptext;
			f.open("maps/" + p.map + "/!.map", "wb");
			f.write(mapdata);
			f.close();
			send_reliable(p, "Map updated", 0);
			mapupdate(p.map);map_updated(p.map);
		}
	} else if (parsed[0] == "addigautomatic_travelpoint") {
		string maptext = string_replace(get_event_message(), "addigautomatic_travelpoint ", "", false);
		file f;
		if (p.is_admin() == false) {
			string[] a = string_split(file_get_contents("chars/" + p.name + "/maps.usr").replace("\r\n", "\n"), "\n");
			for (uint i = 0; i < a.length(); i++) {
				if (string_contains(maptext, a[i], 1) > -1) {
					f.open("maps/" + p.map + "/!.map", "rb");
					string mapdata = f.read().replace("\r\n", "\n");
					f.close();
					mapdata += "\n" + maptext;
					f.open("maps/" + p.map + "/!.map", "wb");
					f.write(mapdata);
					f.close();
					send_reliable(p, "Map updated", 0);
					mapupdate(p.map);map_updated(p.map);
				}
			}
		} else {
			f.open("maps/" + p.map + "/!.map", "rb");
			string mapdata = f.read().replace("\r\n", "\n");
			f.close();
			mapdata += "\n" + maptext;
			f.open("maps/" + p.map + "/!.map", "wb");
			f.write(mapdata);
			f.close();
			send_reliable(p, "Map updated", 0);
			mapupdate(p.map);map_updated(p.map);
		}
	} else if (parsed[0] == "addtravelpoint") {
		string maptext = string_replace(get_event_message(), "addtravelpoint ", "", false);
		file f;
		if (p.is_admin() == false) {
			string[] a = string_split(file_get_contents("chars/" + p.name + "/maps.usr").replace("\r\n", "\n"), "\n");
			for (uint i = 0; i < a.length(); i++) {
				if (string_contains(maptext, a[i], 1) > -1) {
					f.open("maps/" + p.map + "/!.map", "rb");
					string mapdata = f.read().replace("\r\n", "\n");
					f.close();
					mapdata += "\n" + maptext;
					f.open("maps/" + p.map + "/!.map", "wb");
					f.write(mapdata);
					f.close();
					send_reliable(p, "Map updated", 0);
					mapupdate(p.map);map_updated(p.map);
				}
			}
		} else {
			f.open("maps/" + p.map + "/!.map", "rb");
			string mapdata = f.read().replace("\r\n", "\n");
			f.close();
			mapdata += "\n" + maptext;
			f.open("maps/" + p.map + "/!.map", "wb");
			f.write(mapdata);
			f.close();
			send_reliable(p, "Map updated", 0);
			mapupdate(p.map);map_updated(p.map);
		}
	} else if (parsed[0] == "addptravelpoint") {
		string maptext = string_replace(get_event_message(), "addptravelpoint ", "", false);
		file f;
		if (p.is_admin() == false) {
			string[] a = string_split(file_get_contents("chars/" + p.name + "/maps.usr").replace("\r\n", "\n"), "\n");
			for (uint i = 0; i < a.length(); i++) {
				if (string_contains(maptext, a[i], 1) > -1) {
					f.open("maps/" + p.map + "/!.map", "rb");
					string mapdata = f.read().replace("\r\n", "\n");
					f.close();
					mapdata += "\n" + maptext;
					f.open("maps/" + p.map + "/!.map", "wb");
					f.write(mapdata);
					f.close();
					send_reliable(p, "Map updated", 0);
					mapupdate(p.map);map_updated(p.map);
				}
			}
		} else {
			f.open("maps/" + p.map + "/!.map", "rb");
			string mapdata = f.read().replace("\r\n", "\n");
			f.close();
			mapdata += "\n" + maptext;
			f.open("maps/" + p.map + "/!.map", "wb");
			f.write(mapdata);
			f.close();
			send_reliable(p, "Map updated", 0);
			mapupdate(p.map);map_updated(p.map);
		}
	} else if (parsed[0] == "addictravelpoint") {
		string maptext = string_replace(get_event_message(), "addictravelpoint ", "", false);
		file f;
		if (p.is_admin() == false) {
			string[] a = string_split(file_get_contents("chars/" + p.name + "/maps.usr").replace("\r\n", "\n"), "\n");
			for (uint i = 0; i < a.length(); i++) {
				if (string_contains(maptext, a[i], 1) > -1) {
					f.open("maps/" + p.map + "/!.map", "rb");
					string mapdata = f.read().replace("\r\n", "\n");
					f.close();
					mapdata += "\n" + maptext;
					f.open("maps/" + p.map + "/!.map", "wb");
					f.write(mapdata);
					f.close();
					send_reliable(p, "Map updated", 0);
					mapupdate(p.map);map_updated(p.map);
				}
			}
		} else {
			f.open("maps/" + p.map + "/!.map", "rb");
			string mapdata = f.read().replace("\r\n", "\n");
			f.close();
			mapdata += "\n" + maptext;
			f.open("maps/" + p.map + "/!.map", "wb");
			f.write(mapdata);
			f.close();
			send_reliable(p, "Map updated", 0);
			mapupdate(p.map);map_updated(p.map);
		}
	} else if (parsed[0] == "addittravelpoint") {
		string maptext = string_replace(get_event_message(), "addittravelpoint ", "", false);
		file f;
		if (p.is_admin() == false) {
			string[] a = string_split(file_get_contents("chars/" + p.name + "/maps.usr").replace("\r\n", "\n"), "\n");
			for (uint i = 0; i < a.length(); i++) {
				if (string_contains(maptext, a[i], 1) > -1) {
					f.open("maps/" + p.map + "/!.map", "rb");
					string mapdata = f.read().replace("\r\n", "\n");
					f.close();
					mapdata += "\n" + maptext;
					f.open("maps/" + p.map + "/!.map", "wb");
					f.write(mapdata);
					f.close();
					send_reliable(p, "Map updated", 0);
					mapupdate(p.map);map_updated(p.map);
				}
			}
		} else {
			f.open("maps/" + p.map + "/!.map", "rb");
			string mapdata = f.read().replace("\r\n", "\n");
			f.close();
			mapdata += "\n" + maptext;
			f.open("maps/" + p.map + "/!.map", "wb");
			f.write(mapdata);
			f.close();
			send_reliable(p, "Map updated", 0);
			mapupdate(p.map);map_updated(p.map);
		}
	} else if (parsed[0] == "addigtravelpoint") {
		string maptext = string_replace(get_event_message(), "addigtravelpoint ", "", false);
		file f;
		if (p.is_admin() == false) {
			string[] a = string_split(file_get_contents("chars/" + p.name + "/maps.usr").replace("\r\n", "\n"), "\n");
			for (uint i = 0; i < a.length(); i++) {
				if (string_contains(maptext, a[i], 1) > -1) {
					f.open("maps/" + p.map + "/!.map", "rb");
					string mapdata = f.read().replace("\r\n", "\n");
					f.close();
					mapdata += "\n" + maptext;
					f.open("maps/" + p.map + "/!.map", "wb");
					f.write(mapdata);
					f.close();
					send_reliable(p, "Map updated", 0);
					mapupdate(p.map);map_updated(p.map);
				}
			}
		} else {
			f.open("maps/" + p.map + "/!.map", "rb");
			string mapdata = f.read().replace("\r\n", "\n");
			f.close();
			mapdata += "\n" + maptext;
			f.open("maps/" + p.map + "/!.map", "wb");
			f.write(mapdata);
			f.close();
			send_reliable(p, "Map updated", 0);
			mapupdate(p.map);map_updated(p.map);
		}
	} else if (parsed[0] == "adddcoordinates") {
		string maptext = string_replace(get_event_message(), "adddcoordinates ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcamera") {
		string maptext = string_replace(get_event_message(), "adddcamera ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcamerawall") {
		string maptext = string_replace(get_event_message(), "adddcamerawall ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddmfwc") {
		string maptext = string_replace(get_event_message(), "adddmfwc ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecameraplayer") {
		string maptext = string_replace(get_event_message(), "addecameraplayer ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcameraplayer") {
		string maptext = string_replace(get_event_message(), "adddcameraplayer ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecameraitem") {
		string maptext = string_replace(get_event_message(), "addecameraitem ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcameraitem") {
		string maptext = string_replace(get_event_message(), "adddcameraitem ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecameradoor") {
		string maptext = string_replace(get_event_message(), "addecameradoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcameradoor") {
		string maptext = string_replace(get_event_message(), "adddcameradoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecamerapdoor") {
		string maptext = string_replace(get_event_message(), "addecamerapdoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcamerapdoor") {
		string maptext = string_replace(get_event_message(), "adddcamerapdoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecameraicdoor") {
		string maptext = string_replace(get_event_message(), "addecameraicdoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcameraicdoor") {
		string maptext = string_replace(get_event_message(), "adddcameraicdoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecameraitdoor") {
		string maptext = string_replace(get_event_message(), "addecameraitdoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcameraitdoor") {
		string maptext = string_replace(get_event_message(), "adddcameraitdoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecameraigdoor") {
		string maptext = string_replace(get_event_message(), "addecameraigdoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcameraigdoor") {
		string maptext = string_replace(get_event_message(), "adddcameraigdoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecameraautomover") {
		string maptext = string_replace(get_event_message(), "addecameraautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcameraautomover") {
		string maptext = string_replace(get_event_message(), "adddcameraautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecamerapautomover") {
		string maptext = string_replace(get_event_message(), "addecamerapautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcamerapautomover") {
		string maptext = string_replace(get_event_message(), "adddcamerapautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecameraicautomover") {
		string maptext = string_replace(get_event_message(), "addecameraicautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcameraicautomover") {
		string maptext = string_replace(get_event_message(), "adddcameraicautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecameraitautomover") {
		string maptext = string_replace(get_event_message(), "addecameraitautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcameraitautomover") {
		string maptext = string_replace(get_event_message(), "adddcameraitautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecameraigautomover") {
		string maptext = string_replace(get_event_message(), "addecameraigautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcameraigautomover") {
		string maptext = string_replace(get_event_message(), "adddcameraigautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecameraautomatic_travelpoint") {
		string maptext = string_replace(get_event_message(), "addecameraautomatic_travelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcameraautomatic_travelpoint") {
		string maptext = string_replace(get_event_message(), "adddcameraautomatic_travelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecamerapautomatic_travelpoint") {
		string maptext = string_replace(get_event_message(), "addecamerapautomatic_travelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcamerapautomatic_travelpoint") {
		string maptext = string_replace(get_event_message(), "adddcamerapautomatic_travelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecameraicautomatic_travelpoint") {
		string maptext = string_replace(get_event_message(), "addecameraicautomatic_travelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcameraicautomatic_travelpoint") {
		string maptext = string_replace(get_event_message(), "adddcameraicautomatic_travelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecameraitautomatic_travelpoint") {
		string maptext = string_replace(get_event_message(), "addecameraitautomatic_travelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcameraitautomatic_travelpoint") {
		string maptext = string_replace(get_event_message(), "adddcameraitautomatic_travelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecameraigautomatic_travelpoint") {
		string maptext = string_replace(get_event_message(), "addecameraigautomatic_travelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcameraigautomatic_travelpoint") {
		string maptext = string_replace(get_event_message(), "adddcameraigautomatic_travelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecameratravelpoint") {
		string maptext = string_replace(get_event_message(), "addecameratravelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcameratravelpoint") {
		string maptext = string_replace(get_event_message(), "adddcameratravelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecameraptravelpoint") {
		string maptext = string_replace(get_event_message(), "addecameraptravelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcameraptravelpoint") {
		string maptext = string_replace(get_event_message(), "adddcameraptravelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecameraictravelpoint") {
		string maptext = string_replace(get_event_message(), "addecameraictravelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcameraictravelpoint") {
		string maptext = string_replace(get_event_message(), "adddcameraictravelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecameraittravelpoint") {
		string maptext = string_replace(get_event_message(), "addecameraittravelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcameraittravelpoint") {
		string maptext = string_replace(get_event_message(), "adddcameraittravelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecameraigtravelpoint") {
		string maptext = string_replace(get_event_message(), "addecameraigtravelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcameraigtravelpoint") {
		string maptext = string_replace(get_event_message(), "adddcameraigtravelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecameravp") {
		string maptext = string_replace(get_event_message(), "addecameravp ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcameravp") {
		string maptext = string_replace(get_event_message(), "adddcameravp ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecamerasign") {
		string maptext = string_replace(get_event_message(), "addecamerasign ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcamerasign") {
		string maptext = string_replace(get_event_message(), "adddcamerasign ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecameratxt") {
		string maptext = string_replace(get_event_message(), "addecameratxt ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddcameratxt") {
		string maptext = string_replace(get_event_message(), "adddcameratxt ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addd2dsupport") {
		string maptext = string_replace(get_event_message(), "addd2dsupport ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddjump") {
		string maptext = string_replace(get_event_message(), "adddjump ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspy") {
		string maptext = string_replace(get_event_message(), "adddspy ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecoordinates") {
		string maptext = string_replace(get_event_message(), "addecoordinates ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecamera") {
		string maptext = string_replace(get_event_message(), "addecamera ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addecamerawall") {
		string maptext = string_replace(get_event_message(), "addecamerawall ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addemfwc") {
		string maptext = string_replace(get_event_message(), "addemfwc ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addejump") {
		string maptext = string_replace(get_event_message(), "addejump ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespy") {
		string maptext = string_replace(get_event_message(), "addespy ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adde2dsupport") {
		string maptext = string_replace(get_event_message(), "adde2dsupport ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddlocalchat") {
		string maptext = string_replace(get_event_message(), "adddlocalchat ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addelocalchat") {
		string maptext = string_replace(get_event_message(), "addelocalchat ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddvoicechat") {
		string maptext = string_replace(get_event_message(), "adddvoicechat ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addevoicechat") {
		string maptext = string_replace(get_event_message(), "addevoicechat ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddttschat") {
		string maptext = string_replace(get_event_message(), "adddttschat ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addettschat") {
		string maptext = string_replace(get_event_message(), "addettschat ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddtracking") {
		string maptext = string_replace(get_event_message(), "adddtracking ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addetracking") {
		string maptext = string_replace(get_event_message(), "addetracking ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addddisasters") {
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mdata = f.read().replace("\r\n", "\n");
		f.close();
		string[] mapdata = string_split(mdata, "\n");
		int something = mapdata.find("enable:disasters");
		if (something > -1) {
			mapdata.remove_at(something);
			file_put_contents("maps/" + p.map + "/!.map", linear(mapdata), 250);
			send_reliable(p, "Map updated", 0);
			mapupdate(p.map);map_updated(p.map);
		}
	} else if (parsed[0] == "addedisasters") {
		string maptext = string_replace(get_event_message(), "addedisasters ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddrain") {
		string maptext = string_replace(get_event_message(), "adddrain ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddwind") {
		string maptext = string_replace(get_event_message(), "adddwind ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddnight") {
		string maptext = string_replace(get_event_message(), "adddnight ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespyplayer") {
		string maptext = string_replace(get_event_message(), "addespyplayer ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspyplayer") {
		string maptext = string_replace(get_event_message(), "adddspyplayer ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespyitem") {
		string maptext = string_replace(get_event_message(), "addespyitem ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspyitem") {
		string maptext = string_replace(get_event_message(), "adddspyitem ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespydoor") {
		string maptext = string_replace(get_event_message(), "addespydoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspydoor") {
		string maptext = string_replace(get_event_message(), "adddspydoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespypdoor") {
		string maptext = string_replace(get_event_message(), "addespypdoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspypdoor") {
		string maptext = string_replace(get_event_message(), "adddspypdoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespyicdoor") {
		string maptext = string_replace(get_event_message(), "addespyicdoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspyicdoor") {
		string maptext = string_replace(get_event_message(), "adddspyicdoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespyitdoor") {
		string maptext = string_replace(get_event_message(), "addespyitdoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspyitdoor") {
		string maptext = string_replace(get_event_message(), "adddspyitdoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespyigdoor") {
		string maptext = string_replace(get_event_message(), "addespyigdoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspyigdoor") {
		string maptext = string_replace(get_event_message(), "adddspyigdoor ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespyautomover") {
		string maptext = string_replace(get_event_message(), "addespyautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspyautomover") {
		string maptext = string_replace(get_event_message(), "adddspyautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespypautomover") {
		string maptext = string_replace(get_event_message(), "addespypautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspypautomover") {
		string maptext = string_replace(get_event_message(), "adddspypautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespyicautomover") {
		string maptext = string_replace(get_event_message(), "addespyicautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspyicautomover") {
		string maptext = string_replace(get_event_message(), "adddspyicautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespyitautomover") {
		string maptext = string_replace(get_event_message(), "addespyitautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspyitautomover") {
		string maptext = string_replace(get_event_message(), "adddspyitautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespyigautomover") {
		string maptext = string_replace(get_event_message(), "addespyigautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspyigautomover") {
		string maptext = string_replace(get_event_message(), "adddspyigautomover ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespyautomatic_travelpoint") {
		string maptext = string_replace(get_event_message(), "addespyautomatic_travelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspyautomatic_travelpoint") {
		string maptext = string_replace(get_event_message(), "adddspyautomatic_travelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespypautomatic_travelpoint") {
		string maptext = string_replace(get_event_message(), "addespypautomatic_travelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspypautomatic_travelpoint") {
		string maptext = string_replace(get_event_message(), "adddspypautomatic_travelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespyicautomatic_travelpoint") {
		string maptext = string_replace(get_event_message(), "addespyicautomatic_travelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspyicautomatic_travelpoint") {
		string maptext = string_replace(get_event_message(), "adddspyicautomatic_travelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespyitautomatic_travelpoint") {
		string maptext = string_replace(get_event_message(), "addespyitautomatic_travelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspyitautomatic_travelpoint") {
		string maptext = string_replace(get_event_message(), "adddspyitautomatic_travelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespyigautomatic_travelpoint") {
		string maptext = string_replace(get_event_message(), "addespyigautomatic_travelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspyigautomatic_travelpoint") {
		string maptext = string_replace(get_event_message(), "adddspyigautomatic_travelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespytravelpoint") {
		string maptext = string_replace(get_event_message(), "addespytravelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspytravelpoint") {
		string maptext = string_replace(get_event_message(), "adddspytravelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespyptravelpoint") {
		string maptext = string_replace(get_event_message(), "addespyptravelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspyptravelpoint") {
		string maptext = string_replace(get_event_message(), "adddspyptravelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespyictravelpoint") {
		string maptext = string_replace(get_event_message(), "addespyictravelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspyictravelpoint") {
		string maptext = string_replace(get_event_message(), "adddspyictravelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespyittravelpoint") {
		string maptext = string_replace(get_event_message(), "addespyittravelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspyittravelpoint") {
		string maptext = string_replace(get_event_message(), "adddspyittravelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespyigtravelpoint") {
		string maptext = string_replace(get_event_message(), "addespyigtravelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspyigtravelpoint") {
		string maptext = string_replace(get_event_message(), "adddspyigtravelpoint ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespyvp") {
		string maptext = string_replace(get_event_message(), "addespyvp ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspyvp") {
		string maptext = string_replace(get_event_message(), "adddspyvp ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespysign") {
		string maptext = string_replace(get_event_message(), "addespysign ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspysign") {
		string maptext = string_replace(get_event_message(), "adddspysign ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addespytxt") {
		string maptext = string_replace(get_event_message(), "addespytxt ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "adddspytxt") {
		string maptext = string_replace(get_event_message(), "adddspytxt ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addfishingcoordinate") {
		string maptext = string_replace(get_event_message(), "addfishingcoordinate ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addzone") {
		string maptext = string_replace(get_event_message(), "addzone ", "", false);
		file f;
		if (p.is_admin() == false) {
			if (string_contains(maptext, "_store", 1) > -1 or string_contains(maptext, "bank_service_desk", 1) > -1 or string_contains(maptext, "cash_machine", 1) > -1 or string_contains(maptext, "cash_miner", 1) > -1 or string_contains(maptext, "civil registry office", 1) > -1 or string_contains(maptext, "entertainment_center", 1) > -1 or string_contains(maptext, "employment_agency", 1) > -1 or string_contains(maptext, "cemetery", 1) > -1) {
				send_reliable(p, "this zone text is not allowed", 2);
				return;
			}
			f.open("maps/" + p.map + "/!.map", "rb");
			string mapdata = f.read().replace("\r\n", "\n");
			f.close();
			mapdata += "\n" + maptext;
			f.open("maps/" + p.map + "/!.map", "wb");
			f.write(mapdata);
			f.close();
			send_reliable(p, "Map updated", 0);
			mapupdate(p.map);map_updated(p.map);
		} else {
			f.open("maps/" + p.map + "/!.map", "rb");
			string mapdata = f.read().replace("\r\n", "\n");
			f.close();
			mapdata += "\n" + maptext;
			f.open("maps/" + p.map + "/!.map", "wb");
			f.write(mapdata);
			f.close();
			send_reliable(p, "Map updated", 0);
			mapupdate(p.map);map_updated(p.map);
		}
	} else if (parsed[0] == "addsafezone") {
		string maptext = string_replace(get_event_message(), "addsafezone ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addbed") {
		string maptext = string_replace(get_event_message(), "addbed ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addclock") {
		string maptext = string_replace(get_event_message(), "addclock ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addcalendar") {
		string maptext = string_replace(get_event_message(), "addcalendar ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addoven") {
		string maptext = string_replace(get_event_message(), "addoven ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "addtile") {
		string maptext = string_replace(get_event_message(), "addtile ", "", false);
		file f;
		f.open("maps/" + p.map + "/!.map", "rb");
		string mapdata = f.read().replace("\r\n", "\n");
		f.close();
		mapdata += "\n" + maptext;
		f.open("maps/" + p.map + "/!.map", "wb");
		f.write(mapdata);
		f.close();
		send_reliable(p, "Map updated", 0);
		mapupdate(p.map);map_updated(p.map);
	} else if (parsed[0] == "coinadd") {
		int vending = get_vending_index(p.x, p.y, p.z, p.map);
		if (vending > -1)
			send_serverbox(p.peer_id, 2, -1, 1, -1, "insertamount", "how many coins do you want to insert into this vending machine?");
	} else if (parsed[0] == "usepack" and parsed.length() > 1) {
		string draw;
		string s = string_trim_left(draw, 8);
		string[] pp = string_split(s, "_", false);
		p.inv_add_item(string_replace(s, pp[0] + "_", "", false), string_to_number(pp[0]));
		send_packet(6, "play openpack.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
		p.inv_add_item("empty_pack", 1);
	} else if (parsed[0] == "insertamount" and parsed.length() > 1) {
		if (parsed[1] == "[cncel]") {
			send_reliable(p, "canceled", 0);
			return;
		}
		int v = get_vending_index(p.x, p.y, p.z, p.map);
		double amount = string_to_number(parsed[1]);
		if (amount > 0) {
			if (p.inv_item_number("coins") <= amount) {
				send_reliable(p, "not enough money", 0);
				return;
			}
			if (v > -1) {
				vending_machines[v].vplay("insert");
				vending_machines[v].coins += amount;
				p.inv_add_item("coins", -amount);
			}
		}
	} else if (parsed[0] == "insertdonations" and parsed.length() > 1) {
		if (parsed[1] == "[cncel]") {
			send_reliable(p, "canceled", 0);
			return;
		}
		double amount = string_to_number(parsed[1]);
		if (amount > 0) {
			if (p.inv_item_number("coins") <= amount) {
				send_reliable(p, "not enough money", 0);
				return;
			}
			p.inv_add_item("coins", -amount);
			servermoney += amount;
			send_reliable(p, "donations thanks for donating " + amount + " coins in to the donation chest", 0);
			send_reliable(0, "donations " + p.name + " donated " + amount + " coins to the donation chest!", 0);
		}
	} else if (parsed[0] == "enter") {
		if (usentm(@p, "", 0)) return;
		int h = get_tent_index(p.x, p.y, p.z, maps[get_map_index(p.map)]);
		if (h > -1) {
			tent@ t = @tents[h];
			if (t.owner != p.name) {
				p.sendpacket("You are not the owner to take this tent", 0);
				return;
			}
			t.hitby = "";
			t.health = 0;
			p.inv_add_item("tent", 1);
			send_packet(6, "play getumbrella.ogg " + t.x + " " + t.y + " " + t.z, t.x, t.y, t.z, maps[get_map_index(t.map)]);
			p.sendpacket("You took your tent", 0);
			return;
		}
		for (uint i = 0; i < microwaves.length(); i++) {
			if (p.map == microwaves[i].map and get_3d_distance(p.x, p.y, p.z, microwaves[i].x, microwaves[i].y, microwaves[i].z) <= 1) {
				if (microwaves[i].readytotake == 0) {
					if (microwaves[i].battery <= 0)
						send_reliable(p, "this microwave is out of battery", 2);
					else {
						if (microwaves[i].on == 0 and microwaves[i].foodtype != "") {
							microwaves[i].midsound = spawn_moving_sound("microwave.ogg", microwaves[i].x, microwaves[i].y, microwaves[i].z, microwaves[i].map);
							microwaves[i].on = 1;
							microwaves[i].waitingtimer.restart();
						} else if (microwaves[i].on == 1) {
							destroy_moving_sound(microwaves[i].midsound);
							microwaves[i].midsound = "";
							send_packet(6, "play get" + get_draw_and_get_sound(microwaves[i].foodtype) + ".ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
							p.inv_add_item(microwaves[i].foodtype, 1);
							microwaves[i].on = 0;
							microwaves[i].foodonit = 0;
							microwaves[i].foodtype = "";
							microwaves[i].waitingtimer.restart();
						}
					}
				} else {
					string s;
					if (string_left(microwaves[i].foodtype, 7) == "gutted_") s = string_trim_left(microwaves[i].foodtype, 7);
					send_packet(6, "play get" + get_draw_and_get_sound(s) + ".ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
					p.inv_add_item("cooked_" + s, 1);
					microwaves[i].readytotake = 0;
					microwaves[i].foodonit = 0;
					microwaves[i].foodtype = "";
				}
			}
		}
		for (uint i = 0; i < air_conditioners.length(); i++) {
			if (p.map == air_conditioners[i].map and get_3d_distance(p.x, p.y, p.z, air_conditioners[i].x, air_conditioners[i].y, air_conditioners[i].z) <= 1) {
				air_conditioners[i].on = toggle(air_conditioners[i].on);
				if (air_conditioners[i].on == 1) {
					send_packet(6, "play elevator_start2.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
					air_conditioners[i].mid = spawn_moving_sound("elevator_running.ogg", air_conditioners[i].x, air_conditioners[i].y, air_conditioners[i].z, air_conditioners[i].map);
					send_reliable(p, "on", 2);
				} else {
					send_packet(6, "play elevator_stop2.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
					destroy_moving_sound(air_conditioners[i].mid);
					send_reliable(p, "off", 2);
				}
			}
		}
		for (uint i = 0; i < steams.length(); i++) {
			if (p.map == steams[i].map and get_3d_distance(p.x, p.y, p.z, steams[i].x, steams[i].y, steams[i].z) <= 1) {
				steams[i].on = toggle(steams[i].on);
				if (steams[i].on == 1) {
					send_packet(6, "play slidestart.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
					steams[i].mid = spawn_moving_sound("slide.ogg", steams[i].x, steams[i].y, steams[i].z, steams[i].map);
					send_reliable(p, "on", 2);
				} else {
					send_packet(6, "play slidestop.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
					destroy_moving_sound(steams[i].mid);
					send_reliable(p, "off", 2);
				}
			}
		}
		for (uint i = 0; i < fans.length(); i++) {
			if (p.map == fans[i].map and get_3d_distance(p.x, p.y, p.z, fans[i].x, fans[i].y, fans[i].z) <= 1) {
				fans[i].on = toggle(fans[i].on);
				if (fans[i].on == 1) {
					send_packet(6, "play base_breaker_on.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
					fans[i].mid = spawn_moving_sound("fan6.ogg", fans[i].x, fans[i].y, fans[i].z, fans[i].map);
					send_reliable(p, "on", 2);
				} else {
					send_packet(6, "play base_breaker_off.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
					destroy_moving_sound(fans[i].mid);
					send_reliable(p, "off", 2);
				}
			}
		}
		for (uint i = 0; i < houses.length(); i++) {
			if (houses[i].canbell == 1 and houses[i].bellsound != "" and houses[i].map == p.map and houses[i].x == p.x and houses[i].y == p.y and houses[i].z == p.z) {
				if (p.waitingtimer.elapsed >= random(500, 600)) {
					p.waitingtimer.restart();
					send_packet(6, "play " + houses[i].bellsound + ".ogg " + houses[i].x + " " + houses[i].y + " " + houses[i].z, houses[i].x, houses[i].y, houses[i].z, maps[get_map_index(houses[i].map)]);
					int howner = get_player_index_from(houses[i].owner);
					if (howner > -1) {
						if (players[howner].smartphoneon == 1) {
							send_packet(6, "play " + houses[i].bellsound + ".ogg " + players[howner].x + " " + players[howner].y + " " + players[howner].z, players[howner].x, players[howner].y, players[howner].z, maps[get_map_index(players[howner].map)]);
							send_reliable(players[howner], "spnotify attention, " + p.name + " is Ringing your house bell!", 0);
						}
					}
				}
			}
		}
		for (uint i = 0; i < robots.length(); i++) {
			if (robots[i].enterable == true and robots[i].id == p.rid and robots[i].map.name == p.map and robots[i].x == p.x and robots[i].y == p.y and robots[i].z == p.z) robotstart(p.rid);
		}
		for (uint i = 0; i < toilets.length(); i++) {
			if (toilets[i].map == p.map and toilets[i].minx <= p.x and toilets[i].maxx >= p.x and toilets[i].miny <= p.y and toilets[i].maxy >= p.y and toilets[i].minz <= p.z and toilets[i].maxz >= p.z) {
				if (p.sitting == 0 and p.tmaquina.elapsed >= 1000) {
					send_packet(6, "play dando_descarga1.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
					p.tmaquina.restart();
					toilets[i].descarga = 0;
				} else if (p.sitting == 1 and p.tmaquina.elapsed >= 2500) {
					if (p.nthirst > 0) {
						p.nthirst -= random(80, 110);
						if (p.nthirst < 0)p.nthirst = 0;
						send_packet(6, "play dando_descarga2.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
						p.dirty += 1;
					}
					if (p.nhunger > 0) {
						p.nhunger -= random(80, 110);
						if (p.nhunger < 0)p.nhunger = 0;
						send_packet(6, "play cagando" + random(1, 3) + ".ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
						p.dirty += 1;
					}
					toilets[i].descarga = 1;
				}
			}
		}
		for (uint i = 0; i < washbasins.length(); i++) {
			if (washbasins[i].map == p.map and washbasins[i].aberta == false and washbasins[i].minx <= p.x and washbasins[i].maxx >= p.x and washbasins[i].miny <= p.y and washbasins[i].maxy >= p.y and washbasins[i].minz <= p.z and washbasins[i].maxz >= p.z) {
				send_reliable(p, "stopmoving", 0);
				send_packet(6, "play lavando_maos.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
				washbasins[i].fechando.restart();
				washbasins[i].fechar.restart();
				washbasins[i].aberta = true;
			}
		}
		for (uint i = 0; i < showers.length(); i++) {
			if (showers[i].map == p.map and showers[i].aberta == false and showers[i].minx <= p.x and showers[i].maxx >= p.x and showers[i].miny <= p.y and showers[i].maxy >= p.y and showers[i].minz <= p.z and showers[i].maxz >= p.z) {
				send_reliable(p, "stopmoving", 0);
				send_packet(6, "play shower.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
				showers[i].fechando.restart();
				showers[i].fechar.restart();
				showers[i].aberta = true;
			}
		}
		for (uint i = 0; i < objs.length(); i++) {
			if (p.afk == true or p.away == true or p.is_dead == true) continue;
			if (p.map == objs[i].map.name and get_3d_distance(objs[i].x, objs[i].y, objs[i].z, p.x, p.y, p.z) <= 1) {
				send_packet(6, "play get" + get_draw_and_get_sound(objs[i].name) + ".ogg " + objs[i].x + " " + objs[i].y + " " + objs[i].z, objs[i].x, objs[i].y, objs[i].z, maps[get_map_index(objs[i].map.name)]);
				objgrabs++;
				send_reliable(p, string_replace(objs[i].name, "_", " ", true), 2);
				if (string_contains(objs[i].name, "bag_of_", 1) > -1 or string_contains(objs[i].name, "skillet_with_", 1) > -1) {
					int c = get_corpses_from(string_right(objs[i].name, 5));
					if (c < 0) {
						string cid = randomstring(5);
						new_corpse(objs[i].name + ";", cid);
						p.inv_add_item(objs[i].name + "_" + cid, 1);
					} else
						p.inv_add_item(objs[i].name, 1);
				} else if (string_contains(objs[i].name, "pack_of_", 1) > -1 or string_contains(objs[i].name, "box_of_", 1) > -1) {
					int c = get_corpses_from(string_right(objs[i].name, 5));
					if (c < 0) {
						string cid = randomstring(5);
						string[] parsed2 = string_split(objs[i].name, "_", false);
						new_corpse("" + parsed2[3] + "=" + parsed2[2] + ";", cid);
						p.inv_add_item(objs[i].name + "_" + cid, 1);
					} else
						p.inv_add_item(objs[i].name, 1);
				} else
					p.inv_add_item(objs[i].name, objs[i].amount);
				send_reliable(p, "itemtrackstop", 0);
				remove_obj(i);
				continue;
			}
		}
		for (uint i = 0; i < silenceobjs.length(); i++) {
			if (p.afk == true or p.away == true or p.is_dead == true) continue;
			if (p.map == silenceobjs[i].map.name and get_3d_distance(silenceobjs[i].x, silenceobjs[i].y, silenceobjs[i].z, p.x, p.y, p.z) <= 1) {
				send_packet(6, "play get" + get_draw_and_get_sound(silenceobjs[i].name) + ".ogg " + silenceobjs[i].x + " " + silenceobjs[i].y + " " + silenceobjs[i].z, silenceobjs[i].x, silenceobjs[i].y, silenceobjs[i].z, maps[get_map_index(silenceobjs[i].map.name)]);
				send_reliable(p, string_replace(silenceobjs[i].name, "_", " ", true), 2);
				p.inv_add_item(silenceobjs[i].name, silenceobjs[i].amount);
				remove_silenceobj(i);
				continue;
			}
		}
		int l = get_locker_at(p.x, p.y, p.z, maps[get_map_index(p.map)]);
		if (l > -1)
			send_serverbox(p.peer_id, 2, 4, 1, -1, "lock_auth", "Enter security code");
		int f = get_fridge_at(p.x, p.y, p.z, maps[get_map_index(p.map)]);
		if (f > -1) {
			send_packet(6, "play base_fridge_open.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
			fridges[f].main_ui(p);
		}
		for (uint i = 0; i < mines.length(); i++) {
			if (mines[i].map.name == p.map and get_3d_distance(mines[i].x, mines[i].y, mines[i].z, p.x, p.y, p.z) <= 1) {
				send_packet(6, "play mine_death.ogg " + mines[i].x + " " + mines[i].y + " " + mines[i].z, mines[i].x, mines[i].y, mines[i].z, maps[get_map_index(mines[i].map.name)]);
				p.inv_add_item("mine", 1);
				send_reliable(p, "You have successfully disarmed " + mines[i].owner.name + "'s mine!", 2);
				mines.remove_at(i);
			}
		}
		if (get_zone_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "marriage_place" and p.partner == "") {
			if (p.langchan == "" or p.age == 0 or p.country == "" or p.day == 0 or p.month == 0 or p.year == 0) {
				send_reliable(p, "You didn't complete your profile yet, please go to your smart phone to complete your profile", 2);
				return;
			}
			if (p.age < 18) {
				send_reliable(p, "You are still not reached the age of eighteen which is the legal age for getting married", 2);
				return;
			}
			server_menu m;
			m.intro = "who would you like to marry with?";
			m.initial_packet = "marriage";
			for (uint i = 0; i < players.length(); i++) {
				if (players[i].name == p.name || players[i].is_dead || p.map != players[i].map || players[i].gender == 0 && p.gender == 0 || players[i].gender == 1 && p.gender == 1 || players[i].x != p.x || players[i].y != p.y || players[i].z != p.z || players[i].partner != "" || players[i].age < 18) continue;
				m.add(players[i].name, players[i].name);
			}
			m.send(p.peer_id);
		}
		if (get_zone_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "divorce_place" and p.map == "court" and p.partner != "") {
			if (p.langchan == "" or p.age == 0 or p.country == "" or p.day == 0 or p.month == 0 or p.year == 0) {
				send_reliable(p, "You didn't complete your profile yet, please go to your smart phone to complete your profile", 2);
				return;
			}
			server_menu m;
			m.intro = "who would you like to divorce from?";
			m.initial_packet = "divorce";
			int ind = get_player_index_from(p.partner);
			if (ind > -1 and p.map == players[ind].map || players[ind].x == p.x || players[ind].y == p.y || players[ind].z == p.z)
				m.add(players[ind].name, players[ind].name);
			m.send(p.peer_id);
		}
		if (get_zone_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "employment_agency") {
			server_menu m;
			m.intro = "select your job";
			m.initial_packet = "employ";
			if (p.job != "")
				m.add("quit your current job. Costs 20000 coins", "quitjob");
			else {
				if (p.gender == 0) m.add("salesman. Costs 15000 coins", "salesman");
				else m.add("saleswoman. Costs 15000 coins", "saleswoman");
			}
			m.send(p.peer_id);
		}
		if (get_zone_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "cash_miner") {
			if (p.contabancaria == 1) {
				if (p.waitingtimer.elapsed >= 1500) {
					p.waitingtimer.restart();
					send_packet(6, "play getstw_point.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
					send_packet(6, "play drawstw_credit.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
					p.balance += random(3, 7);
				}
			} else
				send_reliable(p, "you should have bank account to use the cash miner", 2);
		}
		if (get_zone_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "server_chest" and p.is_admin())
			send_reliable(p, "this chest has " + servermoney + " coins", 2);
		if (get_zone_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "donation_chest")
			send_serverbox(p.peer_id, 2, -1, -1, -1, "insertdonations", "how many coins do you want to donate?");
		for (uint i = 0; i < candles.length(); i++) {
			if (p.map == candles[i].map.name and get_3d_distance(p.x, p.y, p.z, candles[i].x, candles[i].y, candles[i].z) <= 2) {
				if (p.gettimer.elapsed >= 100) {
					p.gettimer.restart();
					send_packet(6, "play spiked_iron_mace.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
					candles.remove_at(i);
					continue;
				}
			}
		}
		if (is_clock(p.x, p.y, p.z, maps[get_map_index(p.map)])) {
			for (uint i = 0; i < clocks.length(); i++) {
				if (clocks[i].map == p.map and clocks[i].minx <= p.x and clocks[i].maxx >= p.x and clocks[i].miny <= p.y and clocks[i].maxy >= p.y and clocks[i].minz <= p.z and clocks[i].maxz >= p.z)
					send_reliable(p, "" + (clocks[i].text == "empty" ? "" + get_time() + "" : "" + map_vars(p, clocks[i].text) + " " + get_time() + "") + "", 2);
			}
		}
		if (is_calendar(p.x, p.y, p.z, maps[get_map_index(p.map)])) {
			for (uint i = 0; i < ccalendars.length(); i++) {
				if (ccalendars[i].map == p.map and ccalendars[i].minx <= p.x and ccalendars[i].maxx >= p.x and ccalendars[i].miny <= p.y and ccalendars[i].maxy >= p.y and ccalendars[i].minz <= p.z and ccalendars[i].maxz >= p.z)
					send_reliable(p, "" + (ccalendars[i].text == "empty" ? "" + get_date() + "" : "" + map_vars(p, ccalendars[i].text) + " " + get_date() + "") + "", 2);
			}
		}
		if (get_zone_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "credit_purchase_place")
			send_serverbox(p.peer_id, 2, -1, 1, -1, "creditpurchase", "How much credits would you like to buy?");
		if (is_bed(p.x, p.y, p.z, maps[get_map_index(p.map)])) {
			if (p.sitting == 0)
				send_reliable(p, "you must be sitting to do this action", 2);
			else {
				send_packet(6, "play hammock.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
				p.sleep("");
			}
		}
		if (get_zone_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "bank_service_desk") {
			if (p.contabancaria == 1)send_reliable(p, "You already have a bank account!", 0);
			else if (p.inv_item_number("coins") < 50)send_reliable(p, "you must have 50 coins to do this action", 0);
			else {
				p.inv_add_item("coins", -50);
				p.balance += 50;
				send_reliable(p, "stopmoving", 0);
				send_packet(6, "play impressora.ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
				p.tmaquina.restart();
				p.cbank = true;
			}
		}
		if (get_zone_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == "cash_machine") {
			if (p.contabancaria == 0) {
				send_reliable(p, "you do not have a bank account", 0);
				return;
			}
			server_menu m;
			m.intro = "welcome to " + app.name + "'s bank!";
			m.initial_packet = "bank_menu";
			m.add("Check your funds", "balance_check");
			m.add("Withdraw", "balance_withdrawal");
			m.add("Deposit", "balance_deposit");
			m.add("Deposit in another account", "balance_deposit2");
			m.send(e.peer_id);
		}
		if (get_zone_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == app.name.lower() + "'s_menu") {
			check_maps_for(p.name);
			server_menu m;
			m.intro = app.name + "'s menu.";
			m.initial_packet = "main_mapmenu";
			m.add("Public maps", "publicmaps");
			m.add("Tasks", "task");
			m.add("Your contributions", "yourmaps");
			m.add("New map", "newmap");
			//m.add("arena","arena");
			m.send(p.peer_id);
		}
		int v = get_vending_index(p.x, p.y, p.z, p.map);
		if (v > -1)
			send_serverbox(e.peer_id, 1, -1, 1, 1, "vendingpress", "Press Space to buy something and get the menu. Press C to see how many coins are in the machine. Press r to return any money inside the machine. Press escape to cancel");
		for (int i = 0; i < stores.length(); i++) {
			if (get_zone_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == stores[i].name)
				stores[i].send(p.peer_id, false);
		}
		for (int i = 0; i < paid_stores.length(); i++) {
			if (get_zone_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == paid_stores[i].name)
				paid_stores[i].send(p.peer_id, false);
		}
		for (int i = 0; i < team_stores.length(); i++) {
			if (get_zone_at(p.x, p.y, p.z, maps[get_map_index(p.map)]) == team_stores[i].name) {
				int t = is_in_team(p.name);
				if (t < 0) {
					send_reliable(p, "You are not in a team", 2);
					return;
				}
				if (!teams[t].is_leader(p.name)) {
					send_reliable(p, "You are not the team leader to purchase items from this store", 2);
					return;
				}
				team_stores[i].send(p.peer_id, false);
			}
		}
	} else if (parsed[0] == "eenter") {
		for (uint i = 0; i < apartments.length(); i++) {
			if (apartments[i].x == p.x and apartments[i].y == p.y and apartments[i].z == p.z and apartments[i].map == p.map) {
				if (apartments[i].dooropen == 1) {
					int mi = get_map_index(apartments[i].housemap);
					if (mi > -1) {
						move_player(p, apartments[i].housemap, random(maps[mi].spminx, maps[mi].spmaxx), random(maps[mi].spminy, maps[mi].spmaxy), random(maps[mi].spminz, maps[mi].spmaxz), false);
						send_reliable(p, "enterplace " + apartments[i].x + " " + apartments[i].y + " " + apartments[i].z + " " + apartments[i].map, 0);
						return;
					}
				} else {
					send_serverbox(p.peer_id, 2, 4, 0, -1, "enterapartment", "enter the apartment code");
				}
				return;
			}
		}
		for (uint i = 0; i < tents.length(); i++) {
			if (tents[i].x == p.x and tents[i].y == p.y and tents[i].z == p.z and tents[i].map == p.map) {
				if (tents[i].dooropen == 1) {
					int mi = get_map_index(tents[i].housemap);
					if (mi > -1) {
						move_player(p, tents[i].housemap, random(maps[mi].spminx, maps[mi].spmaxx), random(maps[mi].spminy, maps[mi].spmaxy), random(maps[mi].spminz, maps[mi].spmaxz), false);
						send_reliable(p, "enterplace " + tents[i].x + " " + tents[i].y + " " + tents[i].z + " " + tents[i].map, 0);
						return;
					}
				} else {
					send_serverbox(p.peer_id, 2, 4, 0, -1, "entertent", "enter the tent code");
				}
				return;
			}
		}
		for (uint i = 0; i < houses.length(); i++) {
			if (houses[i].x == p.x and houses[i].y == p.y and houses[i].z == p.z and houses[i].map == p.map) {
				if (houses[i].dooropen == 1) {
					int mi = get_map_index(houses[i].housemap);
					if (mi > -1) {
						move_player(p, houses[i].housemap, random(maps[mi].spminx, maps[mi].spmaxx), random(maps[mi].spminy, maps[mi].spmaxy), random(maps[mi].spminz, maps[mi].spmaxz), false);
						send_reliable(p, "enterplace " + houses[i].x + " " + houses[i].y + " " + houses[i].z + " " + houses[i].map, 0);
						return;
					}
				} else {
					send_serverbox(p.peer_id, 2, 4, 0, -1, "enterhouse", "enter the house code");
				}
				return;
			}
		}
		for (uint i = 0; i < villas.length(); i++) {
			if (villas[i].x == p.x and villas[i].y == p.y and villas[i].z == p.z and villas[i].map == p.map)
				send_serverbox(p.peer_id, 2, 4, 0, -1, "entervilla", "enter the villa code");
		}
		for (uint i = 0; i < beehives.length(); i++) {
			if (beehives[i].map == p.map and beehives[i].x == p.x and beehives[i].y == p.y and beehives[i].z == p.z) {
				int mi = get_map_index(beehives[i].beehivemap);
				if ((mi > -1)) {
					move_player(p, beehives[i].beehivemap, random(maps[mi].spminx, maps[mi].spmaxx), random(maps[mi].spminy, maps[mi].spmaxy), random(maps[mi].spminz, maps[mi].spmaxz), false);
					send_reliable(p, "enterplace " + beehives[i].x + " " + beehives[i].y + " " + beehives[i].z + " " + beehives[i].map, 0);
				}
			}
		}
		for (uint i = 0; i < playerstores.length(); i++) {
			if (playerstores[i].x == p.x and playerstores[i].y == p.y and playerstores[i].z == p.z and playerstores[i].map == p.map) {
				int psowner = get_player_index_from(playerstores[i].owner);
				if (psowner < 0 or players[psowner].gender == 0 and players[psowner].job != "salesman" or players[psowner].gender == 1 and players[psowner].job != "saleswoman")
					send_reliable(p, "This store is currently closed", 2);
				int mi = get_map_index(playerstores[i].playerstoremap);
				if ((mi > -1)) {
					move_player(p, playerstores[i].playerstoremap, random(maps[mi].spminx, maps[mi].spmaxx), random(maps[mi].spminy, maps[mi].spmaxy), random(maps[mi].spminz, maps[mi].spmaxz), false);
					send_packet(6, "play dooropen32.ogg " + playerstores[i].x + " " + playerstores[i].y + " " + playerstores[i].z, playerstores[i].x, playerstores[i].y, playerstores[i].z, maps[get_map_index(playerstores[i].map)]);
					send_packet(6, "play dooropen32.ogg " + 0 + ", " + 0 + ", " + 0, playerstores[i].x, playerstores[i].y, playerstores[i].z, maps[get_map_index(playerstores[i].playerstoremap)]);
					send_reliable(p, "enterplace " + playerstores[i].x + " " + playerstores[i].y + " " + playerstores[i].z + " " + playerstores[i].map, 0);
				}
			}
		}
		if (p.x == 2 and p.y == 0 and p.z == 0 and in_house(p) > -1) {
			int stuff = in_house(p);
			if (stuff < 0) {}
			else {
				move_player(p, houses[stuff].map, houses[stuff].x, houses[stuff].y, houses[stuff].z);
				send_reliable(p, "exitplace", 0);
			}
		}
		if (round(p.x, 0) == 0 and round(p.y, 0) == 0 and round(p.z, 0) == 0 and in_apartment(p) > -1) {
			int stuff = in_apartment(p);
			if (stuff < 0) {}
			else {
				move_player(p, apartments[stuff].map, apartments[stuff].x, apartments[stuff].y, apartments[stuff].z);
				send_reliable(p, "exitplace", 0);
				return;
			}
		}
		if (round(p.x, 0) == 5 and round(p.y, 0) == 0 and round(p.z, 0) == 0 and in_tent(p) > -1) {
			int stuff = in_tent(p);
			if (stuff < 0) {}
			else {
				move_player(p, tents[stuff].map, tents[stuff].x, tents[stuff].y, tents[stuff].z);
				send_reliable(p, "exitplace", 0);
				return;
			}
		}
		if (p.x == 30 and p.y == 0 and p.z == 0 and in_villa(p) > -1) {
			int stuff = in_villa(p);
			if (stuff < 0) {}
			else {
				move_player(p, villas[stuff].map, villas[stuff].x, villas[stuff].y, villas[stuff].z);
				send_reliable(p, "exitplace", 0);
			}
		}
		if (p.x == 0 and p.y == 0 and p.z == 0 and in_playerstore(p) > -1) {
			int stuff = in_playerstore(p);
			if (stuff < 0) {}
			else {
				int psowner = get_player_index_from(playerstores[stuff].owner);
				if (psowner < 0 or players[psowner].gender == 0 and players[psowner].job != "salesman" or players[psowner].gender == 1 and players[psowner].job != "saleswoman")
					send_reliable(p, "This store is currently closed", 2);
				int mi = get_map_index(playerstores[stuff].playerstoremap);
				if ((mi > -1)) {
					move_player(p, playerstores[stuff].map, playerstores[stuff].x, playerstores[stuff].y, playerstores[stuff].z);
					send_packet(6, "play doorclose35.ogg " + playerstores[stuff].x + " " + playerstores[stuff].y + " " + playerstores[stuff].z, playerstores[stuff].x, playerstores[stuff].y, playerstores[stuff].z, maps[get_map_index(playerstores[stuff].map)]);
					send_packet(6, "play doorclose35.ogg " + 0 + ", " + 0 + ", " + 0, playerstores[stuff].x, playerstores[stuff].y, playerstores[stuff].z, maps[get_map_index(playerstores[stuff].playerstoremap)]);
					send_reliable(p, "exitplace", 0);
				}
			}
		}
	} else if (parsed[0] == "travelto" and parsed.length() > 4) {
		int nx = string_to_number(parsed[1]);
		int ny = string_to_number(parsed[2]);
		int nz = string_to_number(parsed[3]);
		string nmap = parsed[4];
		file f;
		if (map_exists(nmap)) {
			int pmapind = get_map_index(p.map);
			if (pmapind > -1) {
				if (maps[pmapind].chminx <= p.x and maps[pmapind].chmaxx >= p.x and maps[pmapind].chminy <= p.y and maps[pmapind].chmaxy >= p.y and maps[pmapind].chminz <= p.z and maps[pmapind].chmaxz >= p.z and maps[pmapind].finishitem != "" and maps[pmapind].finishamount > 0) {
					if (maps[pmapind].finishitem == "coins" or maps[pmapind].finishitem == "credit") {
						p.inv_add_item(maps[pmapind].finishitem, round(maps[pmapind].finishamount - (p.finishtasktimer.elapsed / 1000), 0));
						send_reliable(p, "as a reward, you've recieved " + round(maps[pmapind].finishamount - (p.finishtasktimer.elapsed / 1000), 0) + " " + maps[pmapind].finishitem + "", 2);
						bsend(0, "maps", "", p.name + " finished " + p.map + " in " + ms_to_readable_time(p.finishtasktimer.elapsed) + " and won " + round(maps[pmapind].finishamount - (p.finishtasktimer.elapsed / 1000), 0) + " " + maps[pmapind].finishitem + "!");
					} else {
						p.inv_add_item(maps[pmapind].finishitem, maps[pmapind].finishamount);
						send_reliable(p, "as a reward, you've recieved " + maps[pmapind].finishamount + " " + maps[pmapind].finishitem + "", 2);
						bsend(0, "maps", "", p.name + " finished " + p.map + " in " + ms_to_readable_time(p.finishtasktimer.elapsed) + " and won " + maps[pmapind].finishamount + " " + maps[pmapind].finishitem + "!");
					}
					p.finishtasktimer.restart();
					p.finishtasktimer.pause();
				}
			}
			int nind = get_map_index(nmap);
			if (nind > -1) {
				if (TIME_HOUR<maps[nind].minhour or TIME_HOUR>maps[nind].maxhour) {
					send_reliable(p, "" + maps[nind].name + " is currently closed. Opening hours: " + maps[nind].minhour + " until " + maps[nind].maxhour + "", 2);
					return;
				}
				if ((maps[nind].minlevel > 0 && p.level<maps[nind].minlevel) || (maps[nind].maxlevel > 0 && p.level>maps[nind].maxlevel)) {
					send_reliable(p, "" + maps[nind].name + " is only for players with level range of " + maps[nind].minlevel + " until " + maps[nind].maxlevel + "", 2);
					return;
				}
				if ((maps[nind].minreinforcement > 0 && p.reinforcement<maps[nind].minreinforcement) || (maps[nind].maxreinforcement > 0 && p.reinforcement>maps[nind].maxreinforcement)) {
					send_reliable(p, "" + maps[nind].name + " is only for players with reinforcement range of " + maps[nind].minreinforcement + " until " + maps[nind].maxreinforcement + "", 2);
					return;
				}
				string mdata = maps[nind].rawdata;
				string[] p1 = delinear(mdata);
				for (uint i = 0; i < p1.length(); i++) {
					string[] parsed = string_split(p1[i], ":", true);
					if (parsed[0] == "safezone" and parsed.length() > 6 and p.pvp == 1) {
						send_reliable(p, "you can't enter this map when you are pvp", 2);
						return;
					}
				}
			}
			if (in_house(p) > -1) {
				int h = in_house(p);
				f.open("maps/" + p.map + "/!.map", "rb");
				string[] lines = string_split(f.read().replace("\r\n", "\n"), "\n");
				f.close();
				for (uint i = 0; i < lines.length(); i++) {
					string[] ld = string_split(lines[i], ":", false);
					if (ld[0] == "owner" and ld[1] == p.name and p.is_admin() == false) {
						f.open("maps/" + nmap + "/!.map", "rb");
						string[] lines = string_split(f.read().replace("\r\n", "\n"), "\n");
						f.close();
						int something = lines.find("owner:" + p.name + "");
						if (something < 0) {
							string[] a = string_split(file_get_contents("chmaps.svr").replace("\r\n", "\n"), "\n");
							int something = a.find(p.map);
							if (something < 0) {
								send_reliable(p, "you can't go to a map that you aren't owner of it", 2);
								return;
							}
						}
					}
				}
			}
			if (in_villa(p) > -1) {
				int v = in_villa(p);
				f.open("maps/" + p.map + "/!.map", "rb");
				string[] lines = string_split(f.read().replace("\r\n", "\n"), "\n");
				f.close();
				for (uint i = 0; i < lines.length(); i++) {
					string[] ld = string_split(lines[i], ":", false);
					if (ld[0] == "owner" and ld[1] == p.name and p.is_admin() == false) {
						f.open("maps/" + nmap + "/!.map", "rb");
						string[] lines = string_split(f.read().replace("\r\n", "\n"), "\n");
						f.close();
						int something = lines.find("owner:" + p.name + "");
						if (something < 0) {
							string[] a = string_split(file_get_contents("chmaps.svr").replace("\r\n", "\n"), "\n");
							int something = a.find(p.map);
							if (something < 0) {
								send_reliable(p, "you can't go to a map that you aren't owner of it", 2);
								return;
							}
						}
					}
				}
			} else {
				f.open("maps/" + p.map + "/!.map", "rb");
				string[] lines = string_split(f.read().replace("\r\n", "\n"), "\n");
				f.close();
				for (uint i = 0; i < lines.length(); i++) {
					string[] ld = string_split(lines[i], ":", false);
					if (ld[0] == "owner" and ld[1] == p.name and p.is_admin() == false) {
						f.open("maps/" + nmap + "/!.map", "rb");
						string[] lines = string_split(f.read().replace("\r\n", "\n"), "\n");
						f.close();
						int something = lines.find("owner:" + p.name + "");
						if (something < 0) {
							string[] a = string_split(file_get_contents("chmaps.svr").replace("\r\n", "\n"), "\n");
							int somethinga = a.find(p.map);
							if (somethinga < 0) {
								send_reliable(p, "you can't go to a map that you aren't owner of it", 2);
								return;
							}
						}
					}
				}
			}
			move_player(p, nmap, nx, ny, nz, true);
			int mapindex = get_map_index(p.map);
			if ((mapindex > -1 and maps[mapindex].pvp == 1 and maps[mapindex].pvpminx <= p.x and maps[mapindex].pvpmaxx >= p.x and maps[mapindex].pvpminy <= p.y and maps[mapindex].pvpmaxy >= p.y and maps[mapindex].pvpminz <= p.z and maps[mapindex].pvpmaxz >= p.z)) {
				if (p.pvp != 1) {
					p.pvp = 1;
					send_reliable(p, "You are now pvp!", 2);
					send_reliable(0, "play_s pvpon.ogg", 6);
					send_reliable(0, "" + p.nickname + " is now pvp!", 2);
				}
			}
		} else {
			send_reliable(p, "this map does not exists", 2);
			return;
		}
	} else if (parsed[0] == "enterapartment") {
		int code = string_to_number(parsed[1]);
		int h = get_apartment_index(p.x, p.y, p.z, maps[get_map_index(p.map)]);
		if (h > -1) {
			if (apartments[h].dooropen == 1 && apartments[h].dooropener != "noone") {
				int mi = get_map_index(apartments[h].housemap);
				if ((mi > -1)) {
					move_player(p, apartments[h].housemap, random(maps[mi].spminx, maps[mi].spmaxx), random(maps[mi].spminy, maps[mi].spmaxy), random(maps[mi].spminz, maps[mi].spmaxz), false);
					send_reliable(p, "enterplace " + apartments[h].x + " " + apartments[h].y + " " + apartments[h].z + " " + apartments[h].map, 0);
				}
			} else if (apartments[h].code == code) {
				int mi = get_map_index(apartments[h].housemap);
				if ((mi > -1)) {
					move_player(p, apartments[h].housemap, random(maps[mi].spminx, maps[mi].spmaxx), random(maps[mi].spminy, maps[mi].spmaxy), random(maps[mi].spminz, maps[mi].spmaxz), false);
					send_reliable(p, "enterplace " + apartments[h].x + " " + apartments[h].y + " " + apartments[h].z + " " + apartments[h].map, 0);
				}
			} else {
				send_reliable(p, "wrong code", 0);
				return;
			}
		}
	} else if (parsed[0] == "entertent") {
		int code = string_to_number(parsed[1]);
		int h = get_tent_index(p.x, p.y, p.z, maps[get_map_index(p.map)]);
		if (h > -1) {
			if (tents[h].dooropen == 1 && tents[h].dooropener != "noone") {
				int mi = get_map_index(tents[h].housemap);
				if ((mi > -1)) {
					move_player(p, tents[h].housemap, random(maps[mi].spminx, maps[mi].spmaxx), random(maps[mi].spminy, maps[mi].spmaxy), random(maps[mi].spminz, maps[mi].spmaxz), false);
					send_reliable(p, "enterplace " + tents[h].x + " " + tents[h].y + " " + tents[h].z + " " + tents[h].map, 0);
				}
			} else if (tents[h].code == code) {
				int mi = get_map_index(tents[h].housemap);
				if ((mi > -1)) {
					move_player(p, tents[h].housemap, random(maps[mi].spminx, maps[mi].spmaxx), random(maps[mi].spminy, maps[mi].spmaxy), random(maps[mi].spminz, maps[mi].spmaxz), false);
					send_reliable(p, "enterplace " + tents[h].x + " " + tents[h].y + " " + tents[h].z + " " + tents[h].map, 0);
				}
			} else {
				send_reliable(p, "wrong code", 0);
				return;
			}
		}
	} else if (parsed[0] == "enterhouse") {
		int code = string_to_number(parsed[1]);
		int h = get_house_index(p.x, p.y, p.z, maps[get_map_index(p.map)]);
		if (h > -1) {
			if (houses[h].dooropen == 1 && houses[h].dooropener != "noone") {
				int mi = get_map_index(houses[h].housemap);
				if ((mi > -1)) {
					move_player(p, houses[h].housemap, random(maps[mi].spminx, maps[mi].spmaxx), random(maps[mi].spminy, maps[mi].spmaxy), random(maps[mi].spminz, maps[mi].spmaxz), false);
					send_reliable(p, "enterplace " + houses[h].x + " " + houses[h].y + " " + houses[h].z + " " + houses[h].map, 0);
				}
			} else if (houses[h].code == code) {
				int mi = get_map_index(houses[h].housemap);
				if ((mi > -1)) {
					move_player(p, houses[h].housemap, random(maps[mi].spminx, maps[mi].spmaxx), random(maps[mi].spminy, maps[mi].spmaxy), random(maps[mi].spminz, maps[mi].spmaxz), false);
					send_reliable(p, "enterplace " + houses[h].x + " " + houses[h].y + " " + houses[h].z + " " + houses[h].map, 0);
				}
			} else {
				send_reliable(p, "wrong code", 0);
				return;
			}
		}
	} else if (parsed[0] == "entervilla") {
		int code = string_to_number(parsed[1]);
		int v = get_villa_index(p.x, p.y, p.z, maps[get_map_index(p.map)]);
		if (v > -1) {
			if (villas[v].code == code) {
				int mi = get_map_index(villas[v].villamap);
				if ((mi > -1)) {
					move_player(p, villas[v].villamap, random(maps[mi].spminx, maps[mi].spmaxx), random(maps[mi].spminy, maps[mi].spmaxy), random(maps[mi].spminz, maps[mi].spmaxz), false);
					send_reliable(p, "enterplace " + villas[v].x + " " + villas[v].y + " " + villas[v].z + " " + villas[v].map, 0);
				}
			} else {
				send_reliable(p, "wrong code", 0);
				return;
			}
		}
	} else if (parsed[0] == "opendoor") {
		int h = -1;
		h = get_house_index(p.x, p.y, p.z, maps[get_map_index(p.map)]);
		if (h == -1) {
			h = in_house(p);
		}
		if (h > -1) {
			if (houses[h].owner == p.name || p.partner == houses[h].owner) {
				if (houses[h].dooropen == 1) {
					houses[h].dooropen = 0;
					houses[h].dooropener = "noone";
					send_reliable(p, "Door closed", 2);
					send_packet(6, "play door98close.ogg " + houses[h].x + " " + houses[h].y + " " + houses[h].z, houses[h].x, houses[h].y, houses[h].z, maps[get_map_index(houses[h].map)]);
					send_packet(6, "play door98close.ogg 0 0 0", 2, 0, 0, maps[get_map_index(houses[h].housemap)]);
					return;
				}
				houses[h].dooropen = 1;
				houses[h].dooropener = houses[h].owner;
				houses[h].doortimer.restart();
				send_reliable(p, "Door opened for 8 seconds. Others can enter without code.", 2);
				send_packet(6, "play door98open.ogg " + houses[h].x + " " + houses[h].y + " " + houses[h].z, houses[h].x, houses[h].y, houses[h].z, maps[get_map_index(houses[h].map)]);
				send_packet(6, "play door98open.ogg 0 0 0", 2, 0, 0, maps[get_map_index(houses[h].housemap)]);
				return;
			}
			send_reliable(p, "You are not the owner of this house", 2);
			return;
		}
		h = get_apartment_index(p.x, p.y, p.z, maps[get_map_index(p.map)]);
		if (h == -1) {
			h = in_apartment(p);
		}
		if (h > -1) {
			if (apartments[h].owner == p.name || p.partner == apartments[h].owner) {
				if (apartments[h].dooropen == 1) {
					apartments[h].dooropen = 0;
					apartments[h].dooropener = "noone";
					send_reliable(p, "Door closed", 2);
					send_packet(6, "play door98close.ogg " + apartments[h].x + " " + apartments[h].y + " " + apartments[h].z, apartments[h].x, apartments[h].y, apartments[h].z, maps[get_map_index(apartments[h].map)]);
					send_packet(6, "play door98close.ogg 0 0 0", 2, 0, 0, maps[get_map_index(apartments[h].housemap)]);
					return;
				}
				apartments[h].dooropen = 1;
				apartments[h].dooropener = apartments[h].owner;
				apartments[h].doortimer.restart();
				send_reliable(p, "Door opened for 8 seconds. Others can enter without code.", 2);
				send_packet(6, "play door98open.ogg " + apartments[h].x + " " + apartments[h].y + " " + apartments[h].z, apartments[h].x, apartments[h].y, apartments[h].z, maps[get_map_index(apartments[h].map)]);
				send_packet(6, "play door98open.ogg 0 0 0", 2, 0, 0, maps[get_map_index(apartments[h].housemap)]);
				return;
			}
			send_reliable(p, "You are not the owner of this apartment", 2);
			return;
		}
		h = get_tent_index(p.x, p.y, p.z, maps[get_map_index(p.map)]);
		if (h == -1) {
			h = in_tent(p);
		}
		if (h > -1) {
			if (tents[h].owner == p.name || p.partner == tents[h].owner) {
				if (tents[h].dooropen == 1) {
					tents[h].dooropen = 0;
					tents[h].dooropener = "noone";
					send_reliable(p, "Flap closed", 2);
					send_packet(6, "play door156close.ogg " + tents[h].x + " " + tents[h].y + " " + tents[h].z, tents[h].x, tents[h].y, tents[h].z, maps[get_map_index(tents[h].map)]);
					send_packet(6, "play door156close.ogg 5 0 0", 5, 0, 0, maps[get_map_index(tents[h].housemap)]);
					return;
				}
				tents[h].dooropen = 1;
				tents[h].dooropener = tents[h].owner;
				tents[h].doortimer.restart();
				send_reliable(p, "Flap opened for 8 seconds. Others can enter without code.", 2);
				send_packet(6, "play door156open.ogg " + tents[h].x + " " + tents[h].y + " " + tents[h].z, tents[h].x, tents[h].y, tents[h].z, maps[get_map_index(tents[h].map)]);
				send_packet(6, "play door156open.ogg 5 0 0", 5, 0, 0, maps[get_map_index(tents[h].housemap)]);
				return;
			}
			send_reliable(p, "You are not the owner of this tent", 2);
			return;
		}
		send_reliable(p, "No house / apartment / tent found", 2);
		return;
	} else if (parsed[0] == "creditpurchase" and parsed.length() > 1) {
		if (parsed[1] == "back") {
			p.sendpacket("canceled", 0);
			return;
		}
		int amount = string_to_number(parsed[1]);
		send_reliable(p, "creditpurchase " + p.name + " " + amount, 0);
	} else if (parsed[0] == "playonmap" and parsed.length() > 1) {
		int x = p.x;
		int y = p.y;
		int z = p.z;
		string map = p.map;
		for (uint i = 0; i < players.length(); i++) {
			if (players[i].name != p.name)
				send_reliable(players[i], string_replace(parsed[1], ".ogg", "", true) + " " + x + " " + y + " " + z + " " + map, 3);
		}
	} else if (parsed[0] == "playsnd" and parsed.length() > 1) {
		string soundstring = string_replace(parsed[1], ".ogg", "", true);
		send_packet(6, "play " + soundstring + ".ogg " + p.x + " " + p.y + " " + p.z, p.x, p.y, p.z, maps[get_map_index(p.map)]);
	} else if (parsed[0] == "apacket" and cid != -1)
		send_reliable(cid, string_trim_left(get_event_message(), 8), 2);
	else if (parsed[0] == "cheatengine" or parsed[0] == "speedhacking") {
		send_reliable(0, p.name + " just got caught speedhacking", 2);
		remove_player(p.name);
	} else if (parsed[0] == "turn" and parsed.length() > 1)
		p.facing = string_to_number(parsed[1]);
	else if (parsed[0] == "tturn" and parsed.length() > 1)
		p.ffacing = string_to_number(parsed[1]);
	else if (parsed[0] == "purchase" and parsed.length() > 2) {
		if (in_playerstore(p) > -1)
			pspurchase(parsed[1], string_to_number(parsed[2]), p);
		else
			purchase(parsed[1], string_to_number(parsed[2]), p);
	} else if (parsed[0] == "paid_purchase" and parsed.length() > 2)
		paid_purchase(parsed[1], string_to_number(parsed[2]), p);
	else if (parsed[0] == "team_purchase" and parsed.length() > 2)
		team_purchase(parsed[1], string_to_number(parsed[2]), p);
	else if (parsed[0] == "buysomething" and parsed.length() > 1) {
		if (parsed[1] == "back") return;
		if (parsed[1] == "sky_racer" or parsed[1] == "ford" or parsed[1] == "sorento" or parsed[1] == "BMV" or parsed[1] == "dogan_slx" or parsed[1] == "grayhound_bus" or parsed[1] == "m60_tank" or parsed[1] == "police_car" or parsed[1] == "police_car_pluss" or parsed[1] == "tank" or parsed[1] == "truck" or parsed[1] == "v4_by_4_jeep" or parsed[1] == "dodge_charger" or parsed[1] == "doom_buggy" or parsed[1] == "ford_pickup_truck" or parsed[1] == "mlk_mission_cruiser" or parsed[1] == "muscle_car") {
			if (in_playerstore(p) > -1)
				pspurchase(parsed[1], 1, p);
			else
				purchase(parsed[1], 1, p);
		} else send_serverbox(p.peer_id, 2, 1, 0, -1, "purchase " + parsed[1], "type the amount you wish to buy");
	} else if (parsed[0] == "paid_buysomething" and parsed.length() > 1) {
		if (parsed[1] == "back") return;
		send_serverbox(p.peer_id, 2, 1, 0, -1, "paid_purchase " + parsed[1], "type the amount you wish to buy");
	} else if (parsed[0] == "xp_potion_paid_buysomething" and parsed.length() > 1) {
		if (parsed[1] == "back") return;
		send_serverbox(p.peer_id, 2, 1, 0, -1, "paid_purchase " + parsed[1], "for how much minutes do you want to have the potion?");
	} else if (parsed[0] == "team_buysomething" and parsed.length() > 1) {
		if (parsed[1] == "back") return;
		send_serverbox(p.peer_id, 2, 1, 0, -1, "team_purchase " + parsed[1], "type the amount you wish to buy");
	} else if (parsed[0] == "revive") {
		if (p.is_dead = true)
			respawn(p);
	} else if (parsed[0] == "message") {
		string ms = motd;
		if (ms == "") ms = "No message of the day";
		ms.insert(0, "Message of the day: ");
		send_reliable(p, ms, 2);
	} else if (parsed[0] == "bmessage") {
		string d = motd;
		if (d == "") {
			send_reliable(p, "No message of the day", 0);
			return;
		}
		serverinput m;
		m.title = "Message of the day";
		m.text = "Message";
		m.default_text = d;
		m.button1 = "";
		m.button2 = "&close";
		m.button2primary = 2;
		m.readonly = 1;
		m.multiline = 1;
		m.send(p.peer_id);
	} else if (parsed[0] == "chmessage") {
		string ms = get_lmotd(p.langchan);
		if (ms == "") ms = "No message of the day";
		ms.insert(0, "Message of the day of " + p.langchan + ": ");
		send_reliable(p, ms, 2);
	} else if (parsed[0] == "chbmessage") {
		string d = get_lmotd(p.langchan);
		if (d == "") {
			send_reliable(p, "No message of the day", 0);
			return;
		}
		serverinput m;
		m.title = "Message of the day of " + p.langchan;
		m.text = "Message";
		m.default_text = d;
		m.button1 = "";
		m.button2 = "&close";
		m.button2primary = 2;
		m.readonly = 1;
		m.multiline = 1;
		m.send(p.peer_id);
	} else if (parsed[0] == "close") {
		log("disconnections", p.name + " offline", true);
		for (uint i2 = 0; i2 < arenas.length(); i2++) {
			if (p.map == arenas[i2].map) {
				p.bullet_proof_vested = 0;
				p.bullet_proof_vestshots = 0;
				p.armored = 0;
				p.armorshots = 0;
				p.large_armor_plated = 0;
				p.large_armor_plateshots = 0;
				p.shielded = 0;
				p.shieldshots = 0;
				p.steel_shielded = 0;
				p.steel_shieldshots = 0;
				p.hurtlevel = 0;
				p.hurttimer.restart();
				p.healtimer.restart();
				p.poisoned = false;
				p.hurt = false;
				p.cbombplacing = false;
				p.drunk = false;
				if (p.weapon_name != "fists") {
					p.weapon_name = "fists";
					if (p.weapon_ammos > 0)
						p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
					p.firetimer = 180;
					p.weapon_ammos = 0;
					p.weapon_ammo_type = "";
					p.weapon_copasity = 0;
					send_reliable(p, "notrapid", 0);
				}
				int newx = string_to_number(get_char_val(p.name, "oldx"));
				int newy = string_to_number(get_char_val(p.name, "oldy"));
				int newz = string_to_number(get_char_val(p.name, "oldz"));
				string charfolder = "chars/" + p.name;
				scd(p);
				if (p.inv.get_size() > 0) p.inv.reset();
				file_copy(charfolder + "/oldinv.usr", charfolder + "/inv.usr", true);
				if (p.inv.get_size() < 1) p.inv_add_item("starter_pack", 1);
				load_char_data(p, true);
				file_delete(charfolder + "/oldx.usr");
				file_delete(charfolder + "/oldy.usr");
				file_delete(charfolder + "/oldz.usr");
				file_delete(charfolder + "/oldmap.usr");
				file_delete(charfolder + "/oldinv.usr");
				move_player(p, "main_map", newx, newy, newz);
				arenas[i2].joined--;
				int amath = arenas[i2].length - arenas[i2].joined;
				if (arenas[i2].length > 1) send_reliable(0, "arena " + p.name + " has escaped from " + arenas[i2].owner + "'s " + arenas[i2].type + " Arena. " + amath + " participators stil left.", 0);
				else send_reliable(0, "arena " + p.name + " has escaped from " + arenas[i2].owner + "'s " + arenas[i2].type + " Arena", 0);
				if (p.pvpd == 1 and p.pvp == 1) {
					p.pvp = 0;
					p.pvpd = 0;
				}
				if (p.pvpd == 3) {
					p.pvp = 1;
					p.pvpd = 2;
				}
				remove_player(p.name, true);
				return;
			}
		}
		if (cheatercheck(p) || p.cheater == 1 || file_exists("chars/" + p.name + "/cheater.usr")) {
			create_temp_ban(p.name, 60000);
			write_to(p.name, "cheater.usr", p.name + " is a cheater! They closed the game in " + ms_to_readable_time(p.statchangetimer.elapsed) + " of being hit");
			send_reliable(0, p.name + " is a cheater!", 2);
			p.persisttimer.restart();
			p.disconnected = true;
		} else if (p.nuclearbombspawned == 1) {
			create_temp_ban(p.name, 60000);
			p.persisttimer.restart();
			p.disconnected = true;
		} else
			remove_player(p.name);
	} else if (parsed[0] == "changeeml" and parsed.length() > 2) {
		if (directory_exists("chars/" + parsed[1]) == false) {
			send_reliable(p, "nochar", 0);
			return;
		}
		file f;
		f.open("chars/" + parsed[1] + "/eml.usr", "wb");
		f.write(parsed[2]);
		f.close();
		send_reliable(p, "changed", 0);
	} else if (parsed[0] == "levelcheck") {
		int ind = get_player_index_from(p.looking);
		if (ind > -1) {
			if (players[ind].gender == 0)players[ind].gender2 = "he";
			else players[ind].gender2 = "she";
			send_reliable(p, "" + players[ind].name + " is level " + players[ind].level + " and in reinforcement " + players[ind].reinforcement + ". " + players[ind].gender2 + " has " + players[ind].xp + " experience And " + genderreplace(players[ind].gender, "%pd%") + " next level requires " + (players[ind].xprequired - players[ind].xp) + " experience", 2);
		} else
			send_reliable(p, "you are level " + p.level + " and in reinforcement " + p.reinforcement + ". You have " + p.xp + " experience And Your next level requires " + (p.xprequired - p.xp) + " experience", 2);
	} else if (parsed[0] == "xpcheck") {
		int ind = get_player_index_from(p.looking);
		if (ind > -1)
			send_reliable(p, "" + players[ind].name + " has " + players[ind].xp + " experience", 2);
		else
			send_reliable(p, "you have " + p.xp + " experience", 2);
	} else if (parsed[0] == "xprcheck") {
		int ind = get_player_index_from(p.looking);
		if (ind > -1) {
			if (p.gender == 0)p.gender2 = "he";
			else p.gender2 = "she";
			send_reliable(p, "" + players[ind].gender2 + " next level requires " + (players[ind].xprequired - players[ind].xp) + " experience", 2);
		} else
			send_reliable(p, "Your next level requires " + (p.xprequired - p.xp) + " experience", 2);
	} else if (parsed[0] == "ffhhealth" and parsed.length() > 1)
		p.health -= string_to_number(parsed[1]);
	else if (parsed[0] == "hhealth")
		p.health = 0;
	else if (parsed[0] == "healthcheck") {
		int ind = get_player_index_from(p.looking);
		if (ind > -1) {
			if (players[ind].bullet_proof_vested == 0 and players[ind].armored == 0 and players[ind].large_armor_plated == 0 and players[ind].shielded == 0 and players[ind].steel_shielded == 0) send_reliable(p, " " + players[ind].name + " has " + players[ind].health + " health", 2);
			else if (players[ind].bullet_proof_vested == 1) send_reliable(p, "" + players[ind].name + " has " + players[ind].health + " health, with " + players[ind].bullet_proof_vestshots + " shots", 2);
			else if (players[ind].armored == 1) send_reliable(p, "" + players[ind].name + " has " + players[ind].health + " health, with " + players[ind].armorshots + " shots", 2);
			else if (players[ind].large_armor_plated == 1) send_reliable(p, "" + players[ind].name + " has " + players[ind].health + " health, with " + players[ind].large_armor_plateshots + " shots", 2);
			else if (players[ind].shielded == 1) send_reliable(p, " " + players[ind].name + " has " + players[ind].health + " health, with " + players[ind].shieldshots + " shielded shots", 2);
			else if (players[ind].steel_shielded == 1) send_reliable(p, " " + players[ind].name + " has " + players[ind].health + " health, with " + players[ind].steel_shieldshots + " shielded shots", 2);
		} else {
			if (p.bullet_proof_vested == 0 and p.armored == 0 and p.large_armor_plated == 0 and p.shielded == 0 and p.steel_shielded == 0) send_reliable(p, "" + p.health + " health", 2);
			else if (p.bullet_proof_vested == 1) send_reliable(p, "" + p.health + " health, with " + p.bullet_proof_vestshots + " shots", 2);
			else if (p.armored == 1) send_reliable(p, "" + p.health + " health, with " + p.armorshots + " shots", 2);
			else if (p.large_armor_plated == 1) send_reliable(p, "" + p.health + " health, with " + p.large_armor_plateshots + " shots", 2);
			else if (p.shielded == 1) send_reliable(p, "" + p.health + " health, with " + p.shieldshots + " shielded shots", 2);
			else if (p.steel_shielded == 1) send_reliable(p, "" + p.health + " health, with " + p.steel_shieldshots + " shielded shots", 2);
		}
	} else if (parsed[0] == "energycheck") {
		int ind = get_player_index_from(p.looking);
		if (ind > -1)
			send_reliable(p, "" + players[ind].name + " has " + players[ind].energy + " energy", 2);
		else
			send_reliable(p, "" + p.energy + " energy", 2);
	} else if (parsed[0] == "drunkcheck") {
		int ind = get_player_index_from(p.looking);
		if (ind > -1) {
			if (players[ind].gender == 0)players[ind].gender2 = "hes";
			else players[ind].gender2 = "her";
			send_reliable(p, "" + players[ind].gender2 + " " + (players[ind].drunkstage == 0 ? "not" : "" + players[ind].drunkstage * 2 + "%") + " drunk", 2);
		} else
			send_reliable(p, "you are " + (p.drunkstage == 0 ? "not" : "" + p.drunkstage * 2 + "%") + " drunk", 2);
	} else if (parsed[0] == "thirstcheck") {
		int ind = get_player_index_from(p.looking);
		if (ind > -1)
			send_reliable(p, "" + players[ind].thirst + " /1000 thirst", 2);
		else
			send_reliable(p, "" + p.thirst + " /1000 thirst", 2);
	} else if (parsed[0] == "hungercheck") {
		int ind = get_player_index_from(p.looking);
		if (ind > -1)
			send_reliable(p, "" + players[ind].hunger + " /1000 hunger", 2);
		else
			send_reliable(p, " " + p.hunger + " /1000 hunger", 2);
	} else if (parsed[0] == "fullcheck") {
		int ind = get_player_index_from(p.looking);
		if (ind > -1)
			send_reliable(p, "" + players[ind].name + " is " + (round(percent(players[ind].nthirst, players[ind].nthirst + players[ind].nhunger), 0) == 0 ? "not" : "" + round(percent(players[ind].nthirst, players[ind].nthirst + players[ind].nhunger), 0) + "%") + " full", 2);
		else
			send_reliable(p, "you are " + (round(percent(p.nthirst, p.nthirst + p.nhunger), 0) == 0 ? "not" : "" + round(percent(p.nthirst, p.nthirst + p.nhunger), 0) + "%") + " full", 2);
	} else if (parsed[0] == "sickcheck") {
		int ind = get_player_index_from(p.looking);
		if (ind > -1)
			send_reliable(p, "" + players[ind].name + " is " + (players[ind].sick == 0 ? "not" : "" + players[ind].sick + "%") + " sick", 2);
		else
			send_reliable(p, "you are " + (p.sick == 0 ? "not" : "" + p.sick + "%") + " sick", 2);
	} else if (parsed[0] == "factorcheck") {
		int ind = get_player_index_from(p.looking);
		if (ind > -1)
			send_reliable(p, "" + players[ind].name + " is " + players[ind].dirty + "% dirty, and " + players[ind].wet + "% wet", 2);
		else
			send_reliable(p, "you are " + p.dirty + "% dirty, and " + p.wet + "% wet", 2);
	} else if (parsed[0] == "bonescheck") {
		int ind = get_player_index_from(p.looking);
		if (ind > -1) {
			if (players[ind].gender == 0)players[ind].gender2 = "His";
			else players[ind].gender2 = "Her";
			send_reliable(p, "" + (players[ind].bone_break == true ? "" + players[ind].gender2 + " " + players[ind].bonebreak + " is " + players[ind].bone_level / 10 + "% broken" : "" + genderreplace(players[ind].gender, "%u_s%") + " is OK") + "", 2);
		} else
			send_reliable(p, "" + (p.bone_break == true ? "Your " + p.bonebreak + " is " + p.bone_level / 10 + "% broken" : "Your OK") + "", 2);
	} else if (parsed[0] == "temperaturecheck") {
		int ind = get_player_index_from(p.looking);
		if (ind > -1) {
			if (players[ind].gender == 0)players[ind].gender2 = "his";
			else players[ind].gender2 = "shis";
			send_reliable(p, "" + players[ind].gender2 + " " + players[ind].temperature + "", 2);
		} else
			send_reliable(p, "your " + p.temperature + "", 2);
	} else if (parsed[0] == "maptimecheck") {
		int ind = get_player_index_from(p.looking);
		if (ind > -1) {
			int pmapind = get_map_index(players[ind].map);
			if (pmapind > -1) {
				string charfolder = "chars/" + players[ind].name;
				string[] a = string_split(file_get_contents("pbmaps.svr").replace("\r\n", "\n"), "\n");
				string[] a2 = string_split(file_get_contents(charfolder + "/maps.usr").replace("\r\n", "\n"), "\n");
				string[] a3 = string_split(file_get_contents("chmaps.svr").replace("\r\n", "\n"), "\n");
				int something = a.find(players[ind].map);
				int something2 = a2.find(players[ind].map);
				int something3 = a3.find(players[ind].map);
				if (something > -1 or something2 > -1 or something3 > -1) {
					if (players[ind].gender == 0)players[ind].gender2 = "his";
					else players[ind].gender2 = "shis";
					send_reliable(p, "" + players[ind].gender2 + " in " + players[ind].map + " map for " + ms_to_readable_time(players[ind].finishtasktimer.elapsed) + "", 2);
				} else
					send_reliable(p, "" + players[ind].gender2 + " is not in a public, private, or task map", 2);
			}
		} else {
			string charfolder = "chars/" + p.name;
			string[] a = string_split(file_get_contents("pbmaps.svr").replace("\r\n", "\n"), "\n");
			string[] a2 = string_split(file_get_contents(charfolder + "/maps.usr").replace("\r\n", "\n"), "\n");
			string[] a3 = string_split(file_get_contents("chmaps.svr").replace("\r\n", "\n"), "\n");
			int something = a.find(p.map);
			int something2 = a2.find(p.map);
			int something3 = a3.find(p.map);
			if (something > -1 or something2 > -1 or something3 > -1)
				send_reliable(p, "you are in " + p.map + " map for " + ms_to_readable_time(p.finishtasktimer.elapsed) + "", 2);
			else
				send_reliable(p, "your not in a public, private, or task map", 2);
		}
	} else if (parsed[0] == "track" and parsed.length() > 1) {
		int index2 = get_player_index_from(parsed[1]);
		if (index2 < 0) {
			send_reliable(p, "Player not found", 0);
			return;
		} else {
			if (players[index2].invisible or players[index2].is_dead)
				send_reliable(p, "This player can not be tracked", 0);
			else {
				string soundname;
				if (are_teamed(players[index2].name, p.name) == true)
					soundname = "beacon2";
				else
					soundname = "track";
				send_reliable(p, "trackplayer " + players[index2].name + " " + players[index2].x + " " + players[index2].y + " " + players[index2].z + " " + players[index2].map + " " + soundname, 0);
			}
		}
	} else if (parsed[0] == "whatnear") {
		string s;
		foreach (ntm@ l: ntms) {
			if (l.map == p.map and l.min.x < p.x + 15 and l.min.x > p.x - 15 and l.min.y < p.y + 15 and l.min.y > p.y - 15 and get_1d_distance(p.z, l.min.z) <= 15) {
				int level = 1;
				if (l.min.z > p.z)
					level = 2;
				else if (l.min.z < p.z)
					level = 0;
				else
					level = 1;
				if (l.making) s += "A working in progress nutrition machine";
				else if (l.finv.size > 0) s += "A nutrition machine full of " + l.fname;
				else if (l.what != "") s += "A nutrition machine with " + l.what + " added";
				else s += "A nutrition machine";
				s += " is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, l.x, l.y, p.facing)) + ", " + int(p.distancecheck(l.x, l.y, l.z)) + " feet away. ";
			}
		}
		for (uint i = 0; i < objs.length(); i++) {
			if (objs[i].map.name == p.map and objs[i].x < p.x + 15 and objs[i].x > p.x - 15 and objs[i].y < p.y + 15 and objs[i].y > p.y - 15 and get_1d_distance(p.z, objs[i].z) <= 30) {
				int level = 1;
				if (objs[i].z > p.z)
					level = 2;
				else if (objs[i].z < p.z)
					level = 0;
				else
					level = 1;
				s += objs[i].name + " is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, objs[i].x, objs[i].y, p.facing)) + ", " + p.distancecheck(objs[i].x, objs[i].y, objs[i].z) + " feet away. ";
			}
		}
		for (uint i = 0; i < silenceobjs.length(); i++) {
			if (silenceobjs[i].map.name == p.map and silenceobjs[i].x < p.x + 15 and silenceobjs[i].x > p.x - 15 and silenceobjs[i].y < p.y + 15 and silenceobjs[i].y > p.y - 15 and get_1d_distance(p.z, silenceobjs[i].z) <= 30) {
				int level = 1;
				if (silenceobjs[i].z > p.z)
					level = 2;
				else if (silenceobjs[i].z < p.z)
					level = 0;
				else
					level = 1;
				s += silenceobjs[i].name + " is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, silenceobjs[i].x, silenceobjs[i].y, p.facing)) + ", " + p.distancecheck(silenceobjs[i].x, silenceobjs[i].y, silenceobjs[i].z) + " feet away. ";
			}
		}
		for (uint i = 0; i < apartments.length(); i++) {
			if (apartments[i].map == p.map and apartments[i].x < p.x + 15 and apartments[i].x > p.x - 15 and apartments[i].y < p.y + 15 and apartments[i].y > p.y - 15 and get_1d_distance(p.z, apartments[i].z) <= 30) {
				int level = 1;
				if (apartments[i].z > p.z)
					level = 2;
				else if (apartments[i].z < p.z)
					level = 0;
				else
					level = 1;
				s += "" + apartments[i].owner + "'s " + apartments[i].itemdeleted + " with " + apartments[i].health + " health is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, apartments[i].x, apartments[i].y, p.facing)) + ", " + p.distancecheck(apartments[i].x, apartments[i].y, apartments[i].z) + " feet away. ";
			}
		}
		for (uint i = 0; i < tents.length(); i++) {
			if (tents[i].map == p.map and tents[i].x < p.x + 15 and tents[i].x > p.x - 15 and tents[i].y < p.y + 15 and tents[i].y > p.y - 15 and get_1d_distance(p.z, tents[i].z) <= 30) {
				int level = 1;
				if (tents[i].z > p.z)
					level = 2;
				else if (tents[i].z < p.z)
					level = 0;
				else
					level = 1;
				s += "" + tents[i].owner + "'s " + tents[i].itemdeleted + " with " + tents[i].health + " health is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, tents[i].x, tents[i].y, p.facing)) + ", " + p.distancecheck(tents[i].x, tents[i].y, tents[i].z) + " feet away. ";
			}
		}
		for (uint i = 0; i < houses.length(); i++) {
			if (houses[i].map == p.map and houses[i].x < p.x + 15 and houses[i].x > p.x - 15 and houses[i].y < p.y + 15 and houses[i].y > p.y - 15 and get_1d_distance(p.z, houses[i].z) <= 30) {
				int level = 1;
				if (houses[i].z > p.z)
					level = 2;
				else if (houses[i].z < p.z)
					level = 0;
				else
					level = 1;
				s += "" + houses[i].owner + "'s " + houses[i].itemdeleted + " with " + houses[i].health + " health is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, houses[i].x, houses[i].y, p.facing)) + ", " + p.distancecheck(houses[i].x, houses[i].y, houses[i].z) + " feet away. ";
			}
		}
		for (uint i = 0; i < villas.length(); i++) {
			if (villas[i].map == p.map and villas[i].x < p.x + 15 and villas[i].x > p.x - 15 and villas[i].y < p.y + 15 and villas[i].y > p.y - 15 and get_1d_distance(p.z, villas[i].z) <= 30) {
				int level = 1;
				if (villas[i].z > p.z)
					level = 2;
				else if (villas[i].z < p.z)
					level = 0;
				else
					level = 1;
				s += "" + villas[i].owner + "'s " + villas[i].itemdeleted + " with " + villas[i].health + " health and " + villas[i].security_boosts + " added security is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, villas[i].x, villas[i].y, p.facing)) + ", " + p.distancecheck(villas[i].x, villas[i].y, villas[i].z) + " feet away. ";
			}
		}
		for (uint i = 0; i < espionage_cameras.length(); i++) {
			if (espionage_cameras[i].map.name == p.map and espionage_cameras[i].x < p.x + 15 and espionage_cameras[i].x > p.x - 15 and espionage_cameras[i].y < p.y + 15 and espionage_cameras[i].y > p.y - 15 and get_1d_distance(p.z, espionage_cameras[i].z) <= 30) {
				int level = 1;
				if (espionage_cameras[i].z > p.z)
					level = 2;
				else if (espionage_cameras[i].z < p.z)
					level = 0;
				else
					level = 1;
				s += "" + espionage_cameras[i].owner.name + "'s espionage camera " + espionage_cameras[i].id + " is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, espionage_cameras[i].x, espionage_cameras[i].y, p.facing)) + ", " + p.distancecheck(espionage_cameras[i].x, espionage_cameras[i].y, espionage_cameras[i].z) + " feet away. ";
			}
		}
		for (uint i = 0; i < robots.length(); i++) {
			if (robots[i].map.name == p.map and robots[i].x < p.x + 15 and robots[i].x > p.x - 15 and robots[i].y < p.y + 15 and robots[i].y > p.y - 15 and get_1d_distance(p.z, robots[i].z) <= 30) {
				int level = 1;
				if (robots[i].z > p.z)
					level = 2;
				else if (robots[i].z < p.z)
					level = 0;
				else
					level = 1;
				s += "" + robots[i].owner.name + "'s robot with " + robots[i].health + " health is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, robots[i].x, robots[i].y, p.facing)) + ", " + p.distancecheck(robots[i].x, robots[i].y, robots[i].z) + " feet away. ";
			}
		}
		for (uint i = 0; i < lockers.length(); i++) {
			if (lockers[i].map == p.map and lockers[i].x < p.x + 15 and lockers[i].x > p.x - 15 and lockers[i].y < p.y + 15 and lockers[i].y > p.y - 15 and get_1d_distance(p.z, lockers[i].z) <= 30) {
				int level = 1;
				if (lockers[i].z > p.z)
					level = 2;
				else if (lockers[i].z < p.z)
					level = 0;
				else
					level = 1;
				s += "" + lockers[i].owner + "'s locker with " + lockers[i].health + " health is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, lockers[i].x, lockers[i].y, p.facing)) + ", " + p.distancecheck(lockers[i].x, lockers[i].y, lockers[i].z) + " feet away. ";
			}
		}
		for (uint i = 0; i < fridges.length(); i++) {
			if (fridges[i].map == p.map and fridges[i].x < p.x + 15 and fridges[i].x > p.x - 15 and fridges[i].y < p.y + 15 and fridges[i].y > p.y - 15 and get_1d_distance(p.z, fridges[i].z) <= 30) {
				int level = 1;
				if (fridges[i].z > p.z)
					level = 2;
				else if (fridges[i].z < p.z)
					level = 0;
				else
					level = 1;
				s += "" + fridges[i].owner + "'s fridge with " + fridges[i].health + " health is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, fridges[i].x, fridges[i].y, p.facing)) + ", " + p.distancecheck(fridges[i].x, fridges[i].y, fridges[i].z) + " feet away. ";
			}
		}
		for (uint i = 0; i < beehives.length(); i++) {
			if (beehives[i].map == p.map and beehives[i].x < p.x + 15 and beehives[i].x > p.x - 15 and beehives[i].y < p.y + 15 and beehives[i].y > p.y - 15 and get_1d_distance(p.z, beehives[i].z) <= 30) {
				int level = 1;
				if (beehives[i].z > p.z)
					level = 2;
				else if (beehives[i].z < p.z)
					level = 0;
				else
					level = 1;
				s += "" + beehives[i].owner + "'s beehive with " + beehives[i].health + " health is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, beehives[i].x, beehives[i].y, p.facing)) + ", " + p.distancecheck(beehives[i].x, beehives[i].y, beehives[i].z) + " feet away. ";
			}
		}
		for (uint i = 0; i < playerstores.length(); i++) {
			if (playerstores[i].map == p.map and playerstores[i].x < p.x + 15 and playerstores[i].x > p.x - 15 and playerstores[i].y < p.y + 15 and playerstores[i].y > p.y - 15 and get_1d_distance(p.z, playerstores[i].z) <= 30) {
				int level = 1;
				if (playerstores[i].z > p.z)
					level = 2;
				else if (playerstores[i].z < p.z)
					level = 0;
				else
					level = 1;
				s += "" + playerstores[i].owner + "'s " + playerstores[i].name + " with " + playerstores[i].health + " health is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, playerstores[i].x, playerstores[i].y, p.facing)) + ", " + p.distancecheck(playerstores[i].x, playerstores[i].y, playerstores[i].z) + " feet away. ";
			}
		}
		for (uint i = 0; i < toilets.length(); i++) {
			if (toilets[i].map == p.map and toilets[i].minx < p.x + 15 and toilets[i].maxx > p.x - 15 and toilets[i].miny < p.y + 15 and toilets[i].maxy > p.y - 15 and get_1d_distance(p.z, toilets[i].minz) <= 30) {
				int level = 1;
				if (toilets[i].minz > p.z)
					level = 2;
				else if (toilets[i].maxz < p.z)
					level = 0;
				else
					level = 1;
				s += "toilet is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, toilets[i].minx, toilets[i].miny, p.facing)) + ", " + p.distancecheck(toilets[i].minx, toilets[i].miny, toilets[i].minz) + " feet away. ";
			}
		}
		for (uint i = 0; i < trashcans.length(); i++) {
			if (trashcans[i].map == p.map and trashcans[i].minx < p.x + 15 and trashcans[i].maxx > p.x - 15 and trashcans[i].miny < p.y + 15 and trashcans[i].maxy > p.y - 15 and get_1d_distance(p.z, trashcans[i].minz) <= 30) {
				int level = 1;
				if (trashcans[i].minz > p.z)
					level = 2;
				else if (trashcans[i].maxz < p.z)
					level = 0;
				else
					level = 1;
				s += "trashcan is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, trashcans[i].minx, trashcans[i].miny, p.facing)) + ", " + p.distancecheck(trashcans[i].minx, trashcans[i].miny, trashcans[i].minz) + " feet away. ";
			}
		}
		for (uint i = 0; i < beds.length(); i++) {
			if (beds[i].map == p.map and beds[i].minx < p.x + 15 and beds[i].maxx > p.x - 15 and beds[i].miny < p.y + 15 and beds[i].maxy > p.y - 15 and get_1d_distance(p.z, beds[i].minz) <= 30) {
				int level = 1;
				if (beds[i].minz > p.z)
					level = 2;
				else if (beds[i].maxz < p.z)
					level = 0;
				else
					level = 1;
				s += "bed is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, beds[i].minx, beds[i].miny, p.facing)) + ", " + p.distancecheck(beds[i].minx, beds[i].miny, beds[i].minz) + " feet away. ";
			}
		}
		for (uint i = 0; i < clocks.length(); i++) {
			if (clocks[i].map == p.map and clocks[i].minx < p.x + 15 and clocks[i].maxx > p.x - 15 and clocks[i].miny < p.y + 15 and clocks[i].maxy > p.y - 15 and get_1d_distance(p.z, clocks[i].minz) <= 30) {
				int level = 1;
				if (clocks[i].minz > p.z)
					level = 2;
				else if (clocks[i].maxz < p.z)
					level = 0;
				else
					level = 1;
				s += "clock is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, clocks[i].minx, clocks[i].miny, p.facing)) + ", " + p.distancecheck(clocks[i].minx, clocks[i].miny, clocks[i].minz) + " feet away. ";
			}
		}
		for (uint i = 0; i < ccalendars.length(); i++) {
			if (ccalendars[i].map == p.map and ccalendars[i].minx < p.x + 15 and ccalendars[i].maxx > p.x - 15 and ccalendars[i].miny < p.y + 15 and ccalendars[i].maxy > p.y - 15 and get_1d_distance(p.z, ccalendars[i].minz) <= 30) {
				int level = 1;
				if (ccalendars[i].minz > p.z)
					level = 2;
				else if (ccalendars[i].maxz < p.z)
					level = 0;
				else
					level = 1;
				s += "calendar is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, ccalendars[i].minx, ccalendars[i].miny, p.facing)) + ", " + p.distancecheck(ccalendars[i].minx, ccalendars[i].miny, ccalendars[i].minz) + " feet away. ";
			}
		}
		for (uint i = 0; i < ovens.length(); i++) {
			if (ovens[i].map == p.map and ovens[i].minx < p.x + 15 and ovens[i].maxx > p.x - 15 and ovens[i].miny < p.y + 15 and ovens[i].maxy > p.y - 15 and get_1d_distance(p.z, ovens[i].minz) <= 30) {
				int level = 1;
				if (ovens[i].minz > p.z)
					level = 2;
				else if (ovens[i].maxz < p.z)
					level = 0;
				else
					level = 1;
				s += "oven is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, ovens[i].minx, ovens[i].miny, p.facing)) + ", " + p.distancecheck(ovens[i].minx, ovens[i].miny, ovens[i].minz) + " feet away. ";
			}
		}
		for (uint i = 0; i < washbasins.length(); i++) {
			if (washbasins[i].map == p.map and washbasins[i].minx < p.x + 15 and washbasins[i].maxx > p.x - 15 and washbasins[i].miny < p.y + 15 and washbasins[i].maxy > p.y - 15 and get_1d_distance(p.z, washbasins[i].minz) <= 30) {
				int level = 1;
				if (washbasins[i].minz > p.z)
					level = 2;
				else if (washbasins[i].maxz < p.z)
					level = 0;
				else
					level = 1;
				s += "washbasin is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, washbasins[i].minx, washbasins[i].miny, p.facing)) + ", " + p.distancecheck(washbasins[i].minx, washbasins[i].miny, washbasins[i].minz) + " feet away. ";
			}
		}
		for (uint i = 0; i < showers.length(); i++) {
			if (showers[i].map == p.map and showers[i].minx < p.x + 15 and showers[i].maxx > p.x - 15 and showers[i].miny < p.y + 15 and showers[i].maxy > p.y - 15 and get_1d_distance(p.z, showers[i].minz) <= 30) {
				int level = 1;
				if (showers[i].minz > p.z)
					level = 2;
				else if (showers[i].maxz < p.z)
					level = 0;
				else
					level = 1;
				s += "shower is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, showers[i].minx, showers[i].miny, p.facing)) + ", " + p.distancecheck(showers[i].minx, showers[i].miny, showers[i].minz) + " feet away. ";
			}
		}
		for (uint i = 0; i < fire_starters.length(); i++) {
			if (fire_starters[i].map.name == p.map and fire_starters[i].x < p.x + 15 and fire_starters[i].x > p.x - 15 and fire_starters[i].y < p.y + 15 and fire_starters[i].y > p.y - 15 and get_1d_distance(p.z, fire_starters[i].z) <= 30) {
				int level = 1;
				if (fire_starters[i].z > p.z)
					level = 2;
				else if (fire_starters[i].z < p.z)
					level = 0;
				else
					level = 1;
				s += "fire with " + fire_starters[i].health + " health is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, fire_starters[i].x, fire_starters[i].y, p.facing)) + ", " + p.distancecheck(fire_starters[i].x, fire_starters[i].y, fire_starters[i].z) + " feet away. ";
			}
		}
		for (uint i = 0; i < auto_healers.length(); i++) {
			if (auto_healers[i].map.name == p.map and auto_healers[i].x < p.x + 15 and auto_healers[i].x > p.x - 15 and auto_healers[i].y < p.y + 15 and auto_healers[i].y > p.y - 15 and get_1d_distance(p.z, auto_healers[i].z) <= 30) {
				int level = 1;
				if (auto_healers[i].z > p.z)
					level = 2;
				else if (auto_healers[i].z < p.z)
					level = 0;
				else
					level = 1;
				s += "auto healer is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, auto_healers[i].x, auto_healers[i].y, p.facing)) + ", " + p.distancecheck(auto_healers[i].x, auto_healers[i].y, auto_healers[i].z) + " feet away. ";
			}
		}
		for (uint i = 0; i < candles.length(); i++) {
			if (candles[i].map.name == p.map and candles[i].x < p.x + 15 and candles[i].x > p.x - 15 and candles[i].y < p.y + 15 and candles[i].y > p.y - 15 and get_1d_distance(p.z, candles[i].z) <= 30) {
				int level = 1;
				if (candles[i].z > p.z)
					level = 2;
				else if (candles[i].z < p.z)
					level = 0;
				else
					level = 1;
				s += "candle is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, candles[i].x, candles[i].y, p.facing)) + ", " + p.distancecheck(candles[i].x, candles[i].y, candles[i].z) + " feet away. ";
			}
		}
		for (uint i = 0; i < microwaves.length(); i++) {
			if (microwaves[i].map == p.map and microwaves[i].x < p.x + 15 and microwaves[i].x > p.x - 15 and microwaves[i].y < p.y + 15 and microwaves[i].y > p.y - 15 and get_1d_distance(p.z, microwaves[i].z) <= 30) {
				int level = 1;
				if (microwaves[i].z > p.z)
					level = 2;
				else if (microwaves[i].z < p.z)
					level = 0;
				else
					level = 1;
				s += "" + microwaves[i].owner + "'s ";
				if (microwaves[i].on == 1) s += "activated ";
				s += "microwave ";
				if (microwaves[i].foodtype != "" and microwaves[i].readytotake == 1) s += "containing cooked containing " + microwaves[i].foodtype + " ";
				else if (microwaves[i].foodtype != "" and microwaves[i].readytotake == 0) s += "containing " + microwaves[i].foodtype + " ";
				s += "with " + microwaves[i].health + " health and " + microwaves[i].battery + " battery remaining is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, microwaves[i].x, microwaves[i].y, p.facing)) + ", " + p.distancecheck(microwaves[i].x, microwaves[i].y, microwaves[i].z) + " feet away. ";
			}
		}
		for (uint i = 0; i < air_conditioners.length(); i++) {
			if (air_conditioners[i].map == p.map and air_conditioners[i].x < p.x + 15 and air_conditioners[i].x > p.x - 15 and air_conditioners[i].y < p.y + 15 and air_conditioners[i].y > p.y - 15 and get_1d_distance(p.z, air_conditioners[i].z) <= 30) {
				int level = 1;
				if (air_conditioners[i].z > p.z)
					level = 2;
				else if (air_conditioners[i].z < p.z)
					level = 0;
				else
					level = 1;
				s += "" + air_conditioners[i].owner + "'s ";
				if (air_conditioners[i].on == 1) s += "activated ";
				s += "air_conditioner ";
				s += "with " + air_conditioners[i].health + " health is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, air_conditioners[i].x, air_conditioners[i].y, p.facing)) + ", " + p.distancecheck(air_conditioners[i].x, air_conditioners[i].y, air_conditioners[i].z) + " feet away. ";
			}
		}
		for (uint i = 0; i < steams.length(); i++) {
			if (steams[i].map == p.map and steams[i].x < p.x + 15 and steams[i].x > p.x - 15 and steams[i].y < p.y + 15 and steams[i].y > p.y - 15 and get_1d_distance(p.z, steams[i].z) <= 30) {
				int level = 1;
				if (steams[i].z > p.z)
					level = 2;
				else if (steams[i].z < p.z)
					level = 0;
				else
					level = 1;
				s += "" + steams[i].owner + "'s ";
				if (steams[i].on == 1) s += "activated ";
				s += "steam ";
				s += "with " + steams[i].health + " health is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, steams[i].x, steams[i].y, p.facing)) + ", " + p.distancecheck(steams[i].x, steams[i].y, steams[i].z) + " feet away. ";
			}
		}
		for (uint i = 0; i < fans.length(); i++) {
			if (fans[i].map == p.map and fans[i].x < p.x + 15 and fans[i].x > p.x - 15 and fans[i].y < p.y + 15 and fans[i].y > p.y - 15 and get_1d_distance(p.z, fans[i].z) <= 30) {
				int level = 1;
				if (fans[i].z > p.z)
					level = 2;
				else if (fans[i].z < p.z)
					level = 0;
				else
					level = 1;
				s += "" + fans[i].owner + "'s ";
				if (fans[i].on == 1) s += "activated ";
				s += "fan ";
				s += "with " + fans[i].health + " health is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, fans[i].x, fans[i].y, p.facing)) + ", " + p.distancecheck(fans[i].x, fans[i].y, fans[i].z) + " feet away. ";
			}
		}
		for (uint i = 0; i < turrets.length(); i++) {
			if (turrets[i].map.name == p.map and turrets[i].x < p.x + 15 and turrets[i].x > p.x - 15 and turrets[i].y < p.y + 15 and turrets[i].y > p.y - 15 and get_1d_distance(p.z, turrets[i].z) <= 30) {
				int level = 1;
				if (turrets[i].z > p.z)
					level = 2;
				else if (turrets[i].z < p.z)
					level = 0;
				else
					level = 1;
				s += "turret of " + turrets[i].owner.name + " with " + turrets[i].health + " health is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, turrets[i].x, turrets[i].y, p.facing)) + ", " + p.distancecheck(turrets[i].x, turrets[i].y, turrets[i].z) + " feet away. ";
			}
		}
		for (uint i = 0; i < vending_machines.length(); i++) {
			if (vending_machines[i].map == p.map and vending_machines[i].x < p.x + 15 and vending_machines[i].x > p.x - 15 and vending_machines[i].y < p.y + 15 and vending_machines[i].y > p.y - 15 and get_1d_distance(vending_machines[i].z, p.z) <= 30) {
				int level = 1;
				if (vending_machines[i].z > p.z)
					level = 2;
				else if (vending_machines[i].z < p.z)
					level = 0;
				else
					level = 1;
				s += "a ";
				s += "vending machine selling food and drinks is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, vending_machines[i].x, vending_machines[i].y, p.facing)) + ", " + p.distancecheck(vending_machines[i].x, vending_machines[i].y, vending_machines[i].z) + " feet away. ";
			}
		}
		if (s == "")
			s = "There is nothing around";
		send_reliable(p, s, 2);
	} else if (parsed[0] == "aicheck") {
		string s;
		for (uint r = 0; r < ais.length(); r++) {
			if (ais[r].map.name == p.map and ais[r].x < p.x + 25 and ais[r].x > p.x - 25 and ais[r].y < p.y + 25 and ais[r].y > p.y - 25 and get_1d_distance(ais[r].z, p.z) <= 30) {
				int level = 1;
				if (ais[r].z > p.z)
					level = 2;
				else if (ais[r].z < p.z)
					level = 0;
				else
					level = 1;
				if (ais[r].mad == true) s += "a mad ";
				if (ais[r].aprotected == true) s += "protected ";
				s += ais[r].name + " with " + ais[r].health + " health is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, ais[r].x, ais[r].y, p.facing)) + ", " + p.distancecheck(ais[r].x, ais[r].y, ais[r].z) + " feet away. ";
			}
		}
		if (s == "")
			s = "There is nothing around";
		send_reliable(p, s, 2);
	} else if (parsed[0] == "whonear") {
		string s;
		for (uint i = 0; i < players.length(); i++) {
			if (players[i].is_dead == true || players[i].afk == true || players[i].amoving == true || players[i].dmoving == true) continue;
			if (players[i].name != p.name and players[i].map == p.map and players[i].looking != p.name and players[i].looker != p.name and p.looking != players[i].name and p.looker != players[i].name and players[i].x < p.x + 15 and players[i].x > p.x - 15 and players[i].y < p.y + 15 and players[i].y > p.y - 15 and get_1d_distance(p.z, players[i].z) <= 30) {
				int level = 1;
				if (players[i].z > p.z)
					level = 2;
				else if (players[i].z < p.z)
					level = 0;
				else
					level = 1;
				if (players[i].shielded == 1 or players[i].steel_shielded == 1) s += "shielded ";
				if (players[i].bullet_proof_vested == 1 or players[i].armored == 1 or players[i].large_armor_plated == 1) s += "armored ";
				if (players[i].sitting == 1 && !players[i].sleeping) s += "sitting ";
				else if (players[i].sitting == 1 and players[i].sleeping == true) s += "sleeping ";
				if (players[i].inv.exists("safe_card")) s += "supernatural ";
				if (players[i].teamname != "") s += team_name(players[i].teamname) + " ";
				if (players[i].awaytitle != "") s += players[i].awaytitle + " ";
				if (players[i].prisontitle != "") s += players[i].prisontitle + " ";
				if (players[i].newbtitle != "") s += players[i].newbtitle + " ";
				if (players[i].afktitle != "") s += players[i].afktitle + " ";
				if (players[i].pvptitle != "") s += players[i].pvptitle + " ";
				if (players[i].jobtitle != "") s += players[i].jobtitle + " ";
				s += players[i].nickname + " is ";
				if (level == 2)
					s += "above, ";
				else if (level == 0)
					s += "below, ";
				s += calculate_x_y_string(calculate_x_y_angle(p.x, p.y, players[i].x, players[i].y, p.facing)) + ", " + int(get_3d_distance(p.x, p.y, p.z, players[i].x, players[i].y, players[i].z)) + " feet away. ";
			}
		}
		if (s == "")
			s = "There is no one around";
		send_reliable(p, s, 2);
	} else if (parsed[0] == "whoonline") {
		string s = "";
		string s2;
		string[] outs;
		for (uint i = 0; i < players.length(); i++)
			outs.insert_last(team_name(players[i].teamname) + " " + players[i].awaytitle + " " + players[i].prisontitle + " " + players[i].newbtitle + " " + players[i].afktitle + " " + players[i].pvptitle + " " + players[i].jobtitle + " " + players[i].nickname + " (" + players[i].name + ")");
		if (outs.length() > 1) {
			for (uint i = 0; i < outs.length(); i++) {
				if (i == (outs.length() - 1)) s += "and " + outs[i] + ".";
				else s += outs[i] + ", ";
			}
		} else
			for (uint i = 0; i < outs.length(); i++)
				s = outs[i] + ".";
		if (outs.length() > 1)
			s2 = " " + outs.length() + " players online. ";
		else s2 = " " + outs.length() + " player online. ";
		send_reliable(p, s2 + s, 2);
	} else if (parsed[0] == "iamdmoving")
		p.dmoving = true;
	else if (parsed[0] == "iamnotdmoving")
		p.dmoving = false;
	else if (parsed[0] == "iamamoving")
		p.amoving = true;
	else if (parsed[0] == "iamnotamoving")
		p.amoving = false;
	else if (parsed[0] == "vendingpress" and parsed.length() > 1) {
		int vx = get_vending_index(p.x, p.y, p.z, p.map);
		if (vx > -1) {
			string cmd = string_replace(get_event_message(), "vendingpress ", "", false);
			if (string_contains(cmd, "[cncel]", 1) > -1) {
				send_reliable(p, "Canceled", 0);
				return;
			}
			vending_machines[vx].command(cmd, e.peer_id);
		}
	} else if (parsed[0] == "restartserver") {
		svd::save();
		send_reliable(0, "notify Restarting the server...", 0);
		send_reliable(0, "restart", 0);
		wait(1200);
		run(get_script_path(), "", false, false);
		exit();
	} else if (parsed[0] == "staffmenu" && parsed.length() > 1) {
		if (parsed[1] == "[back]") return;
		staff_menu_as_type(p.peer_id, parsed[1]);
		return;
	} else if (parsed[0].starts_with("cntm/") && parsed.length() > 1) {
		string[] l = parsed[0].split("/");
		if (l.length() <= 2) return;
		string w = l[1];
		int h = stn(l[2]);
		string w2 = parsed[1];
		if (w2 == "back") return;
		try {
			ntmi@ i = @ntmi_obj(w, ntm_makes, w2, true)[0];
			usentm(p, w, h, i);
		} catch {
		}
		return;
	} else if (parsed[0] == "newlmotd") {
		string t = string_trimleft(event, (parsed[0] + " ").length());
		if (t != "") {
			if (t == "[back]") return;
			if (!p.lcm) {
				p.sendpacket("You are not the language channel manager of " + p.langchan + " channel", 0);
				return;
			}
			set_language_message(p, t);
			return;
		}
		if (!p.lcm) {
			p.sendpacket("You are not the language channel manager of " + p.langchan + " channel", 0);
			return;
		}
		serverinput i;
		i.packet = parsed[0];
		i.title = "Channel Message of the Day";
		i.text = "Type the message of the day that will be set to " + p.langchan + " channel";
		i.button1 = "&Send";
		i.multiline = 1;
		i.send(p.peer_id);
		return;
	} else if (parsed[0] == "teamchat") {
		string t = string_trimleft(event, (parsed[0] + " ").length());
		if (t == "") {
			if (t == "[back]") return;
			int x = is_in_team(p.name);
			if (x < 0) {
				p.sendpacket("You are not in any team", 0);
				return;
			}
			serverinput i;
			i.title = "Team chat";
			i.packet = parsed[0];
			i.text = "Type the message to " + teams[x].name + " team";
			i.multiline = 1;
			i.send(p.peer_id);
			return;
		}
		if (t == "[back]") return;
		teamchat(p, t);
		return;
	} else if (parsed[0] == "astchat" && parsed.length() > 1) {
		string t = string_trimleft(event, (parsed[0] + " ").length());
		asttell("Assistant chat from " + p.name + ": " + t, "base_comp_success.ogg", "astc");
		return;
	} else if (parsed[0] == "pm" && parsed.length() > 2) {
		string msg = string_trimleft(event, (parsed[0] + " " + parsed[1] + " ").length());
		pmplayer(p, parsed[1], msg);
		return;
	} else if (parsed[0] == "reply" && parsed.length() > 2) {
		string msg = string_trimleft(event, (parsed[0] + " " + parsed[1] + " ").length());
		replyplayer(p, parsed[1], msg);
		return;
	} else if (md.get_value("message") == "changepass") {
		string oldp = md.get_value("old");
		string newp = md.get_value("new");
		string newcp = md.get_value("conf");
		if (oldp == "" || newp == "" || newcp == "") return;
		if (string_aes_encrypt(oldp, passkey) != get_char_val(p.name, "password")) {
			p.sendpacket("Incorrect password", 0);
			return;
		}
		writeto(p.name, "password", string_aes_encrypt(newp, passkey));
		p.sendpacket("Password change is successful", 0);
		log("character", p.name + " changes the password", true, true, telladmin = true);
		return;
	}
}
void handle_deposit(player@ p, double n) {
	if (n <= 0)
		send_reliable(p, "Invalid or blank bank account", 2);
	else if (n > p.inv_item_number("coins"))
		send_reliable(p, "you do not have that much money", 0);
	else {
		p.inv_add_item("coins", -n);
		send_reliable(p, "you deposit " + n + " coins.", 0);
		p.balance += n;
	}
}
void handle_deposit2(player@ p, double n) {
	if (n <= 0)
		send_reliable(p, "Invalid or blank bank account", 2);
	else if (n > p.inv_item_number("credit"))
		send_reliable(p, "you do not have that many credits", 0);
	else {
		p.inv_add_item("credit", -n);
		send_reliable(p, "you deposited " + n + " credits.", 0);
		p.balance2 += n;
	}
}
void handle_transfer_preparation(player@ p, double n) {
	if (p.balance <= 0 || n <= 0)
		send_reliable(p, "Invalid or blank bank account", 2);
	else if (n > p.balance)
		send_reliable(p, "you do not have that much", 2);
	else {
		send_reliable(p, "mtext What is the name of the account holder you want to transfer to?:dep3_r", 0);
		p.vconta = n;
	}
}
void handle_withdrawal(player@ p, double n) {
	if (n <= 0)
		send_reliable(p, "Invalid or blank bank account", 0);
	else if (n > p.balance)
		send_reliable(p, "you do not have that much", 0);
	else {
		p.inv_add_item("coins", n);
		send_reliable(p, "You take out " + n + " coins.", 0);
		p.balance -= n;
	}
}
void update_balance(string username, double amount) {
	string file_path = "chars/" + username + "/balance.usr";
	file f;
	if (f.open(file_path, "rb")) {
		double balance = string_to_number(f.read());
		f.close();
		double total = balance + amount;
		f.open(file_path, "wb");
		f.write(total);
		f.close();
	}
}
void handle_withdrawal2(player@ p, double n) {
	if (n <= 0)
		send_reliable(p, "Invalid or blank bank account", 0);
	else if (n > p.balance2)
		send_reliable(p, "you do not have that much", 0);
	else {
		p.inv_add_item("credit", n);
		send_reliable(p, "You take out " + n + " credits.", 0);
		p.balance2 -= n;
	}
}
void update_balance2(string username, double amount) {
	string file_path = "chars/" + username + "/balance2.usr";
	file f;
	if (f.open(file_path, "rb")) {
		double balance2 = string_to_number(f.read());
		f.close();
		double total = balance2 + amount;
		f.open(file_path, "wb");
		f.write(total);
		f.close();
	}
}
void dep3(player@p, string[] parsed) {
	string recipient_name = parsed[1];
	double transfer_amount = string_to_number(p.vconta);
	string charfolder = "chars/" + recipient_name;
	if (directory_exists(charfolder) == false) {
		send_reliable(p, "that bank account is not match to our player base", 2);
		return;
	}
	if (igual(recipient_name, p.name))return;
	int recipient_index = get_player_index_from(recipient_name);
	file f;
	if (recipient_index > -1) {
		f.open("chars/" + recipient_name + "/balance.usr", "rb");
		double balance = string_to_number(f.read());
		f.close();
		double total = balance + transfer_amount;
		scd(players[recipient_index]);
		f.open("chars/" + recipient_name + "/balance.usr", "wb");
		f.write(total);
		f.close();
		load_char_data(players[recipient_index], true);
		if (players[recipient_index].smartphoneon == 1)
			send_reliable(players[recipient_index], "spnotify " + p.name + " has transfered " + transfer_amount + " coins in to your bank account", 0);
	} else {
		f.open("chars/" + recipient_name + "/balance.usr", "rb");
		double balance = string_to_number(f.read());
		f.close();
		double total = balance + transfer_amount;
		f.open("chars/" + recipient_name + "/balance.usr", "wb");
		f.write(total);
		f.close();
	}
	p.balance -= transfer_amount;
	if (p.smartphoneon == 1)
		send_reliable(p, "spnotify you deposited " + transfer_amount + " coins in " + recipient_name + "'s bank account", 0);
}
void iitem(player@ p, string n1, string n2) {
	if (n1 == "caixa_eletrnico") {
		if (n2 == "cbalance") send_reliable(p, "You have " + p.balance + " coins in your bank account", 2);
		else if (n2 == "cbalance2") send_reliable(p, "You have " + p.balance2 + " credits in your bank account", 2);
		else if (n2 == "dep") send_reliable(p, "mtext How much do you want to transfer?:dep_r", 0);
		else if (n2 == "dep4") send_reliable(p, "mtext How much do you want to transfer?:dep_r2", 0);
		else if (n2 == "sac") send_reliable(p, "mtext How much do you want to withdraw?:sac_r", 0);
		else if (n2 == "sac2") send_reliable(p, "mtext How much do you want to withdraw?:sac_r2", 0);
		else if (n2 == "dep2") send_reliable(p, "mtext How much do you want to transfer?:dep2_r", 0);
	}
}

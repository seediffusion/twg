#pragma asset "docs"
#pragma asset "unzip.bat"
#pragma plugin legacy_sound
#pragma namespace sound upcoming
#pragma plugin nvgt_curl
#include "includes.nvgt"
double airtime = 225;
double bmovetime = 500;
double movetime;
double walkspeed = 100;
string sndtype = ".ogg";
double walktime = 150;
double runtime = 100;
double runspeed = 100;
double volume = 0;
double pitch = 100;
double allsoundsvolume = 0;
double allsoundspitch = 100;
double stepsoundvolume = 0;
double stepsoundpitch = 100;
double painsoundvolume = 0;
double painsoundpitch = 100;
double killsoundvolume = 0;
double killsoundpitch = 100;
double shootsoundvolume = 0;
double shootsoundpitch = 100;
double hitsoundvolume = 0;
double hitsoundpitch = 100;
double voicevolume = 0;
double voicepitch = 100;
double fallsoundvolume = 0;
double fallsoundpitch = 100;
double volumejogo = 0;
int RandomPingSound = 0;
int kh = 0;
int gender = 0;
int braille_support = 0;
int microphone_samplerate = 44100;
int microphonechannels = 1;
int stereotyping = 0;
int vmode = 0;
int record;
int vv;
bool inplace = false;
int scuffsec;
string youtube_format;
string urc;
int speak_chars = 1;
int behind_pitch_decrease = 1;
bool camsz = false;
bool following = false;
bool looking = false;
int have_cycle_inventory = 1;
//int checkcfu=1;
//int checkcmotd=1;
string whofollowing;
string wholooking;
string lookname;
int voiceindex = 0;
voicechatting vc;
application app;
int voicechat = 1;
int holdv = 1;
int rectime = 30000;
bool recording;
int anumber;
string projname = "uw";
string up1, up2, up3, up4;
sound stream;
double volumestream = 0;
int playerpos;
string motd;
int motdshow;
string motdmotd = "";
string[] klang;
string[] aliases;
string[] script_keys;
string[] accounts;
string musictrack = "menumus.ogg";
string menuclick = "menuclick.ogg";
string menuclose = "menuclose.ogg";
string menuedge = "menuedge.ogg";
string menuenter = "menuenter.ogg";
string menuopen = "menuopen.ogg";
string menuwrap = "menuwrap.ogg";
string bell = ascii_to_character(7);
string bell2 = ascii_to_character(9);
string ap;
string apl;
string apv;
int mv = 5000;
int rules = 0;
int lng = 0;
int startlng = 0;
int klangpos;
string prefsdir = DIRECTORY_APPDATA + "UW";
int inv_search_index = -1;
bool pinging = false;
sound sleeping, sleepstart, capbeep, svrsound, internal, chuvatelhado, chuvalivre, somguardachuva, windtelhado, windlivre, somguardawind, nighttelhado, nightlivre, somguardanight, s1, srcs, dreamsound;
sound[]snds;
int dreamtime = random(100, 1000);
string[] sounds;
int[] keys;
int sleepmode = -1;
int dreaming = 1;
bool walkmod = false;
int twitteraccess = 0;
int voice;
int seerange = 35;
bool brancas = true, outras = true, portable = false, ausente = false;
int autologin = 0;
int autolower = 1;
int sonaron = 0;
int sonarrange = 10;
int sonar = 2;
int sonartime = 400;
int vsonarrange = 50;
int vsonar = 1;
int vsonartime = 400;
int readchats = 1;
int readolmsg = 1;
int readdeathmsg = 1;
string chatsound = "chat1", localchatsound = "localchat1", onlinesound = "online1", offlinesound = "offline1", pmsound = "pm1", jumpsound = "jump1";
int chsound, lcsound, onsound, offsound, pmsgsound;
//int playlogo=1;
int wrap = 0;
int first_letter_navigation = 0;
int multi_letter_navigation = 1;
int letters_autoactivate = 0;
int preloader = 0;
int sidescrolling = 0;
int buffermode = 0;
int ssbuffermode = 0;
int translator = 1;
int droptime = 240;
int asktoexit = 1;
int askbid = 1;
int askauction = 1;
int sapiforce = 0;
int spamtime = 600;
bool overrun = false;
int lcontrol = 1;
int rcontrol = 0;
int lshift = 1;
int rshift = 1;
int lalt = 1;
int ralt = 1;
int use = 1;
int xx = 1;
int scuffs;
int itemsound = 1;
int cpx, cpy, cpz;
int dcoordinates = 0, dcamera = 0, dcamerawall = 1, dmfwc = 0, dcameraplayer = 0, dcameraitem = 0, dcameradoor = 0, dcamerapdoor = 0, dcameraicdoor = 0, dcameraitdoor = 0, dcameraigdoor = 0, dcameraautomover = 0, dcamerapautomover = 0, dcameraicautomover = 0, dcameraitautomover = 0, dcameraigautomover = 0, dcameraautomatic_travelpoint = 0, dcamerapautomatic_travelpoint = 0, dcameraicautomatic_travelpoint = 0, dcameraitautomatic_travelpoint = 0, dcameraigautomatic_travelpoint = 0, dcameratravelpoint = 0, dcameraptravelpoint = 0, dcameraictravelpoint = 0, dcameraittravelpoint = 0, dcameraigtravelpoint = 0, dcameravp = 0, dcameraff = 0, dcamerah = 0, dcameratp = 0, dcamerasign = 0, dcameratxt = 0, djump = 0, dspy = 0, dspyplayer = 0, dspyitem = 0, dspydoor = 0, dspypdoor = 0, dspyicdoor = 0, dspyitdoor = 0, dspyigdoor = 0, dspyautomover = 0, dspypautomover = 0, dspyicautomover = 0, dspyitautomover = 0, dspyigautomover = 0, dspyautomatic_travelpoint = 0, dspypautomatic_travelpoint = 0, dspyicautomatic_travelpoint = 0, dspyitautomatic_travelpoint = 0, dspyigautomatic_travelpoint = 0, dspytravelpoint = 0, dspyptravelpoint = 0, dspyictravelpoint = 0, dspyittravelpoint = 0, dspyigtravelpoint = 0, dspyvp = 0, dspyff = 0, dspyh = 0, dspytp = 0, dspysign = 0, dspytxt = 0, dlocalchat = 0, dvoicechat = 0, dttschat = 0, dtracking = 0, d2dsupport = 0;
int mfwc = 0;
int trackingmode = 0;
int repeatingcamera = 1;
double guardachuva = 0;
double chuvaativa = 0;
double numerochuva;
double guardawind = 0;
double windativa = 0;
double numerowind;
double guardanight = 0;
double nightativa = 0;
double numeronight;
double cavando = 0, ouvirhits = 1;
string soundcardname;
int soundcard;
int speechmode = 0;
int ttsvoice = 0;
tts_voice ttsv;
int mouseativo = 1, ouviremoutrasjanelas = 0, ouvirpassos = 1;
int wintext = 0;
int mouse;
int djoystick;
int winsound;
int mutetts;
int sitting = 0;
instance uwinstance();
//string packname = "audio.dat";
const string decryption_key = "meowza";
int readerinterrupt = 0;
int menumusvol = -5;
int mvol = 0;
bool x = false;
bool lcm = false;
string godir, godir2, godir3, go, go2, go3, go4;
string tracking = "";
double trackx = -1, tracky = -1, trackz = -1;
string ttracking = "";
double ttrackx = -1, ttracky = -1, ttrackz = -1;
bool falling = false;
double falltime = 125;
double falldistance = 5;
int num;
bool jumping = false;
double jumptime = 100;
double jumpup = 0;
double jumplandz = 0;
bool can_move = true;
int importbufferlogs = 1;
int savevoicechats = 1;
int savettschats = 1;
int hearyourvoicechat = 1;
int hearyourttschat = 1;
int hearothersvoicechat = 1;
int hearothersttschat = 1;
int hearotherspmsound = 1;
int othershearyourpmsound = 1;
string lefthand, righthand, draw, llastuse, rlastuse;
double hands;
sound ffile;
string lngdata;
string currentlangfile;
string keyboarddata;
string currentkeyboardlangfile;
int zonestatus = 1;
int inputhelp;
int saveinputbox;
double changerotationtime = 200;
string latest, description;
bool frozen = false;
double volumetime = 40;
double minvolume = -100;
double maxvolume = 300;
double pitchtime = 40;
double minpitch = -350;
double maxpitch = 350;
double pantime = 30;
double minpan = -100;
double maxpan = 100;
double facing = 0.0;
double ffacing = 0;
double cameraspeed = 80;
key_hold kleft(KEY_LEFT, 300, 50);
key_hold kright(KEY_RIGHT, 300, 50);
key_hold kup(KEY_UP, 300, 50);
key_hold kdown(KEY_DOWN, 300, 50);
key_hold kq(KEY_Q, 300, 50);
key_hold ke(KEY_E, 300, 50);
key_hold kspace(KEY_SPACE, 300, 50);
key_hold kr(KEY_R, 300, 50);
key_hold kw(KEY_W, 300, 50);
key_hold kpgdn(KEY_NEXT, 300, 50);
key_hold kpgup(KEY_PRIOR, 300, 50);
key_hold kmleft(KEY_LEFT, walktime, walktime);
key_hold kmright(KEY_RIGHT, walktime, walktime);
key_hold kmup(KEY_UP, walktime, walktime);
key_hold kmdown(KEY_DOWN, walktime, walktime);
key_hold kmpgdn(KEY_NEXT, walktime, walktime);
key_hold kmpgup(KEY_PRIOR, walktime, walktime);
key_hold kcleft(KEY_LEFT, 300, cameraspeed);
key_hold kcright(KEY_RIGHT, 300, cameraspeed);
key_hold kcup(KEY_UP, 300, cameraspeed);
key_hold kcdown(KEY_DOWN, 300, cameraspeed);
key_hold kcpgdn(KEY_NEXT, 300, cameraspeed);
key_hold kcpgup(KEY_PRIOR, 300, cameraspeed);
key_hold khome(KEY_HOME, 100, 100);
key_hold kend(KEY_END, 100, 100);
key_hold kcomma(KEY_COMMA, 300, 20);
key_hold kperiod(KEY_PERIOD, 300, 20);
key_hold klbracket(KEY_LBRACKET, 300, 20);
key_hold krbracket(KEY_RBRACKET, 300, 20);
int lastruns = 0;
string runs;
double kills;
string password;
savedata sd("data.dat", "charbhoom");
string currentloc;
float final_pan;
float final_volume;
bool dead = false;
bool connected, playing;
bool creating;
sound_pool p, mpool, distpool, placedistpool, sourcepool, musicpool, signpool, itempool;
joystick j;
int defjoy = 0;
string defjoyname = j.name;
bool joyfix = false;
int mousey, mousex, mousez;
int npool1, npool2;
int clap = 50, snap = 100;
timer movetimer, airtimer, falltimer, changerotationtimer, chattimer, pantimer, pitchtimer, volumetimer, deathtimer, trackingtimer, largesawtimer, jumptimer, pingpongtimer, walktimer, xtimer, timeouttimer, scufftimer, bmovetimer, posetimer, vwindowtimer, bikebeeptimer, droptimer, spamtimer, rectimer, firetimer, sendfire, mousemenutimer, joymenutimer, startstoptimer, commandtimer, takeofftimer, serverboxcooldowntimer, sleeptimer, snoretimer, dreamtimer, tenter, doorknock, cectimer, ceftimer, gametracktimer, sonartimer, vsonartimer, canijumptimer, aptime, tpool1, tpool2, clapped, snapped, usetimer;
double timeouttime = 10000;
bool engexp;
bool inbox = false;
bool intextbox = false;
string mapstring;
string mapname = "main";
string mapavoltar = "main";
string name;
vector me, place, min, max, camera;
text_input v;
phonetext_input pv;
telefone tel;
phone fone;
string placemap;
string currentcameratile;
string cver;
string langver;
string keyboardlangver;
string lbver;
string readmever;
string docsver;
string rulesver;
string gamever;
bool canjump = true;
int rapidfire = 0;
typedef uint8 usmall; typedef int8 small;
sound@ bleepy;
tone_synth bleeper, ts;
string banid = generate_computer_id("S»‰Àuafamaﬁ›‰€Èdecolecionartampasdecr‚nios" + app.version, true);
network n;
network_event e;
string sndloc = "audio.dat";
pack@ sndpack = null;
void main() {
	if (!directory_exists("logs")) directory_create("logs");
	@sndpack = pack();
	sndpack.open(sndloc, PACK_OPEN_MODE_READ);
	@sound_default_pack = @sndpack;
	set_sound_global_hrtf(true);
	@default_input_process_loop = process_loops;
	invcats.insert_last("weapons");
	invcats.insert_last("ammos");
	invcats.insert_last("explosives");
	invcats.insert_last("clothes");
	invcats.insert_last("fruits and vegetables");
	invcats.insert_last("unprepared food and beverages");
	invcats.insert_last("food and beverages");
	invcats.insert_last("medical items");
	invcats.insert_last("materials");
	invcats.insert_last("home appliances");
	invcats.insert_last("currency");
	invcats.insert_last("paid items");
	invcats.insert_last("packages and  bottles");
	invcats.insert_last("corpses");
	@buffer_default_can_use = buffercu;
	create_buffer("all");
	create_buffer("chats", "Public chats");
	create_buffer("local chats");
	create_buffer("team chats");
	create_buffer("teamn", "Team Notifications");
	create_buffer("lcm chats");
	create_buffer("astc", "Assistant Chats");
	create_buffer("admin chats");
	create_buffer("developer chats");
	create_buffer("manager chats");
	create_buffer("partner chats");
	create_buffer("astt", "Assistant Notifications");
	create_buffer("admintells");
	create_buffer("private messages");
	create_buffer("playere", "Player Events");
	create_buffer("pings");
	create_buffer("clothing");
	create_buffer("notifications");
	create_buffer("channel messages");
	create_buffer("maps");
	create_buffer("auctions");
	create_buffer("kills");
	create_buffer("connections");
	create_buffer("robot");
	create_buffer("misc");
	if (!directory_exists(prefsdir))directory_create(prefsdir);
	capbeep.load("cap.ogg");
	readprefs();
	initialize_pools();
	show_window(app.name + (app.status != "" ? " (" + app.status + ")" : "") + " version " + app.version);
	set_application_name(app.name);
	p.pan_step = 1;
	p.volume_step = 1;
	mpool.pan_step = 1;
	mpool.volume_step = 1;
	distpool.pan_step = 0.2;
	distpool.volume_step = 0.05;
	placedistpool.pan_step = 0.2;
	placedistpool.volume_step = 0.05;
	sourcepool.pan_step = 1;
	sourcepool.volume_step = 1;
	musicpool.pan_step = 1;
	musicpool.volume_step = 1;
	signpool.pan_step = 1;
	signpool.volume_step = 1;
	itempool.pan_step = 1;
	itempool.volume_step = 1;
	chuvalivre.load("telhado.ogg");
	chuvalivre.volume = -100;
	chuvalivre.load("rain" + random(1, 12) + ".ogg");
	chuvalivre.volume = -100;
	windlivre.load("silence.ogg");
	windlivre.volume = -100;
	windlivre.load("wind" + random(1, 5) + ".ogg");
	windlivre.volume = -100;
	nightlivre.load("silence.ogg");
	nightlivre.volume = -100;
	nightlivre.load("night" + random(2, 4) + ".ogg");
	nightlivre.volume = -100;
	garbage_collect();
	if (uwinstance.is_already_running and overrun == false) {
		alert("error", "Can't have 2 instances of the game up");
		exit();
	}
	if (rules == 0) {
		int agree = question("Rules Agreement", "Do you accept these rules?\n(Yes = Play, No = Exit)");
		if (agree == 1) {
			rules = 1;
			writeprefs();
		} else
			exit();
	}
	if (COMMAND_LINE != crc32("soundrestart")) {
		if (autologin == 1) login();
		else mainmenu();
	} else {
		overrun = true;
		sound enterfake;
		enterfake.load("menuenter.ogg");
		enterfake.play();
		speak("Ok. Using " + soundcardname);
		mainmenu();
	}
	garbage_collect();
}
void game() {
	if (overrun) overrun = false;
	send_reliable(peer_id, "newplayer " + me.x + " " + me.y + " " + me.z + " " + mapname + " " + name + " " + compid + " " + app.version + " " + get_script_path(), 10);
	send_reliable(peer_id, "compinfo " + read_environment_variable("username") + " (" + read_environment_variable("computername") + ") from directory " + get_script_path(), 10);
	playing = true;
	send_reliable(peer_id, "staffcheck", 10);
	if (SCRIPT_COMPILED == false) send_reliable(peer_id, "dev", 10);
	send_reliable(peer_id, "setvoice " + voice, 0);
	if (pinging == true) pinging = false;
	if (behind_pitch_decrease == 1) {
		p.behind_pitch_decrease = 5;
		mpool.behind_pitch_decrease = 5;
		distpool.behind_pitch_decrease = 5;
		placedistpool.behind_pitch_decrease = 5;
		sourcepool.behind_pitch_decrease = 5;
		musicpool.behind_pitch_decrease = 5;
		signpool.behind_pitch_decrease = 5;
		itempool.behind_pitch_decrease = 5;
	} else {
		p.behind_pitch_decrease = 1;
		mpool.behind_pitch_decrease = 1;
		distpool.behind_pitch_decrease = 1;
		placedistpool.behind_pitch_decrease = 1;
		sourcepool.behind_pitch_decrease = 1;
		musicpool.behind_pitch_decrease = 1;
		signpool.behind_pitch_decrease = 1;
		itempool.behind_pitch_decrease = 1;
	}
	garbage_collect();
	while (true) {
		mainloop();
		if (walktime < 150) walktime = 150;
		if (airtime < 220) airtime = 220;
		if (mouse == 1) {
			mouse_update();
			mousey = MOUSE_Y / 8;
			mousex = MOUSE_X / 2;
			mousez = MOUSE_Z / 4;
		}
		if (facing == 360) facing = 0;
		gameloop();
		wait(5);
	}
}
string keygen(string fn) {
	string key = fn;
	key = string_replace(key, "a", "Ê", true);
	key = string_replace(key, "l", "¶", true);
	key = string_replace(key, " ", "˜", true);
	key = string_reverse(key);
	key = string_hash(key, 2, true);
	key = string_encrypt(key, key);
	key = string_reverse(key);
	key = string_hash(string_base64_encode(key), 2, true);
	key = string_reverse(key);
	key = string_hash(string_hash(key, 2, true), 2, true);
	key = string_reverse(key);
	key = string_hash(string_hash(key, 2, true), 2, true);
	key = string_reverse(key);
	key = string_hash(string_hash(key, 2, true), 2, true);
	key = string_reverse(key);
	key = string_hash(string_hash(key, 2, true), 2, true);
	key = string_reverse(key);
	key = string_hash(string_hash(key, 2, true), 2, true);
	key = string_reverse(key);
	key = string_hash(string_hash(key, 2, true), 2, true);
	key = string_reverse(key);
	return key;
}
void readprefs() {
	file f;
	f.open(prefsdir + "/config.dat", "r");
	string content = string_decrypt(f.read(), "charbhoom").replace("\r\n", "\n");
	string[] peramitors = string_split(content, "\n");
	string[] values;
	for (uint i = 0; i < peramitors.length(); i++) {
		values.insert_at(i, string_replace(peramitors[i], string_left(peramitors[i], string_contains(peramitors[i], "=", 1) + 1), "", true));
		peramitors[i] = string_replace(peramitors[i], "=" + values[i], "", true);
	}
	if (peramitors.find("name") != -1)
		name = values[peramitors.find("name")];
	if (peramitors.find("password") != -1)
		password = values[peramitors.find("password")];
	if (peramitors.find("voicechat") != -1)
		voicechat = string_to_number(values[peramitors.find("voicechat")]);
	if (peramitors.find("audioform_keyboard_echo") != -1)
		audioform_keyboard_echo = string_to_number(values[peramitors.find("audioform_keyboard_echo")]);
	if (peramitors.find("holdv") != -1)
		holdv = string_to_number(values[peramitors.find("holdv")]);
	if (peramitors.find("readerinterrupt") != -1)
		readerinterrupt = string_to_number(values[peramitors.find("readerinterrupt")]);
	if (peramitors.find("mfwc") != -1)
		mfwc = string_to_number(values[peramitors.find("mfwc")]);
	if (peramitors.find("repeatingcamera") != -1)
		repeatingcamera = string_to_number(values[peramitors.find("repeatingcamera")]);
	if (peramitors.find("kh") != -1)
		kh = string_to_number(values[peramitors.find("kh")]);
	if (peramitors.find("inputhelp") != -1)
		inputhelp = string_to_number(values[peramitors.find("inputhelp")]);
	if (peramitors.find("saveinputbox") != -1)
		saveinputbox = string_to_number(values[peramitors.find("saveinputbox")]);
	if (peramitors.find("volumestream") != -1)
		volumestream = string_to_number(values[peramitors.find("volumestream")]);
	if (peramitors.find("mmusic_volume") != -1)
		mmusic_volume = string_to_number(values[peramitors.find("mmusic_volume")]);
	if (peramitors.find("volume") != -1)
		volume = string_to_number(values[peramitors.find("volume")]);
	if (peramitors.find("pitch") != -1)
		pitch = string_to_number(values[peramitors.find("pitch")]);
	if (peramitors.find("have_cycle_inventory") != -1)
		have_cycle_inventory = string_to_number(values[peramitors.find("have_cycle_inventory")]);
	//if(peramitors.find("checkcfu")!=-1)
	//{
	//checkcfu=string_to_number(values[peramitors.find("checkcfu")]);
	//}
	//if(peramitors.find("checkcmotd")!=-1)
	//{
	//checkcmotd=string_to_number(values[peramitors.find("checkcmotd")]);
	//}
	//if(peramitors.find("motdshow")!=-1)
	//{
	//motdshow=string_to_number(values[peramitors.find("motdshow")]);
	//}
	if (peramitors.find("motdmotd") != -1)
		motdmotd = string_to_number(values[peramitors.find("motdmotd")]);
	if (peramitors.find("behind_pitch_decrease") != -1)
		behind_pitch_decrease = string_to_number(values[peramitors.find("behind_pitch_decrease")]);
	if (peramitors.find("xx") != -1)
		xx = string_to_number(values[peramitors.find("xx")]);
	if (peramitors.find("scuffs") != -1)
		scuffs = string_to_number(values[peramitors.find("scuffs")]);
	if (peramitors.find("itemsound") != -1)
		itemsound = string_to_number(values[peramitors.find("itemsound")]);
	if (peramitors.find("walktime") != -1)
		walktime = string_to_number(values[peramitors.find("walktime")]);
	if (peramitors.find("airtime") != -1)
		airtime = string_to_number(values[peramitors.find("airtime")]);
	if (peramitors.find("bmovetime") != -1)
		bmovetime = string_to_number(values[peramitors.find("bmovetime")]);
	if (peramitors.find("asktoexit") != -1)
		asktoexit = string_to_number(values[peramitors.find("asktoexit")]);
	if (peramitors.find("askbid") != -1)
		askbid = string_to_number(values[peramitors.find("askbid")]);
	if (peramitors.find("askauction") != -1)
		askauction = string_to_number(values[peramitors.find("askauction")]);
	if (peramitors.find("zonestatus") != -1)
		zonestatus = string_to_number(values[peramitors.find("zonestatus")]);
	if (peramitors.find("voiceindex") != -1)
		voiceindex = string_to_number(values[peramitors.find("voiceindex")]);
	if (peramitors.find("bufferbeep") != -1)
		bufferbeep = string_to_number(values[peramitors.find("bufferbeep")]);
	if (peramitors.find("dreaming") != -1)
		dreaming = string_to_number(values[peramitors.find("dreaming")]);
	if (peramitors.find("rules") != -1)
		rules = string_to_number(values[peramitors.find("rules")]);
	if (peramitors.find("lng") != -1)
		lng = string_to_number(values[peramitors.find("lng")]);
	if (peramitors.find("startlng") != -1)
		startlng = string_to_number(values[peramitors.find("startlng")]);
	if (peramitors.find("winsound") != -1)
		winsound = string_to_number(values[peramitors.find("winsound")]);
	if (peramitors.find("mouse") != -1)
		mouse = string_to_number(values[peramitors.find("mouse")]);
	if (peramitors.find("djoystick") != -1)
		djoystick = string_to_number(values[peramitors.find("djoystick")]);
	if (peramitors.find("mutetts") != -1)
		mutetts = string_to_number(values[peramitors.find("mutetts")]);
	if (peramitors.find("voice") != -1)
		voice = string_to_number(values[peramitors.find("voice")]);
	if (peramitors.find("pitch") != -1)
		pitch = string_to_number(values[peramitors.find("pitch")]);
	if (peramitors.find("twitteraccess") != -1)
		twitteraccess = string_to_number(values[peramitors.find("twitteraccess")]);
	if (peramitors.find("sapiforce") != -1)
		sapiforce = string_to_number(values[peramitors.find("sapiforce")]);
	if (peramitors.find("musictrack") != -1)
		musictrack = values[peramitors.find("musictrack")];
	if (peramitors.find("menuopen") != -1)
		menuopen = values[peramitors.find("menuopen")];
	if (peramitors.find("menuedge") != -1)
		menuedge = values[peramitors.find("menuedge")];
	if (peramitors.find("menuenter") != -1)
		menuenter = values[peramitors.find("menuenter")];
	if (peramitors.find("menuclick") != -1)
		menuclick = values[peramitors.find("menuclick")];
	if (peramitors.find("menuclose") != -1)
		menuclose = values[peramitors.find("menuclose")];
	if (peramitors.find("menuwrap") != -1)
		menuwrap = values[peramitors.find("menuwrap")];
	if (peramitors.find("ouviremoutrasjanelas") != -1)
		ouviremoutrasjanelas = string_to_number(values[peramitors.find("ouviremoutrasjanelas")]);
	if (peramitors.find("autologin") != -1)
		autologin = string_to_number(values[peramitors.find("autologin")]);
	if (peramitors.find("autolower") != -1)
		autolower = string_to_number(values[peramitors.find("autolower")]);
	if (peramitors.find("readchats") != -1)
		readchats = string_to_number(values[peramitors.find("readchats")]);
	if (peramitors.find("readolmsg") != -1)
		readolmsg = string_to_number(values[peramitors.find("readolmsg")]);
	if (peramitors.find("readdeathmsg") != -1)
		readdeathmsg = string_to_number(values[peramitors.find("readdeathmsg")]);
	if (peramitors.find("chatsound") != -1)
		chatsound = values[peramitors.find("chatsound")];
	if (peramitors.find("localchatsound") != -1)
		localchatsound = values[peramitors.find("localchatsound")];
	if (peramitors.find("onlinesound") != -1)
		onlinesound = values[peramitors.find("onlinesound")];
	if (peramitors.find("offlinesound") != -1)
		offlinesound = values[peramitors.find("offlinesound")];
	if (peramitors.find("pmsound") != -1)
		pmsound = values[peramitors.find("pmsound")];
	if (peramitors.find("jumpsound") != -1)
		jumpsound = values[peramitors.find("jumpsound")];
	if (peramitors.find("chsound") != -1)
		chsound = string_to_number(values[peramitors.find("chsound")]);
	if (peramitors.find("lcsound") != -1)
		lcsound = string_to_number(values[peramitors.find("lcsound")]);
	if (peramitors.find("onsound") != -1)
		onsound = string_to_number(values[peramitors.find("onsound")]);
	if (peramitors.find("offsound") != -1)
		offsound = string_to_number(values[peramitors.find("offsound")]);
	if (peramitors.find("pmsgsound") != -1)
		pmsgsound = string_to_number(values[peramitors.find("pmsgsound")]);
	if (peramitors.find("lcontrol") != -1)
		lcontrol = string_to_number(values[peramitors.find("lcontrol")]);
	if (peramitors.find("rcontrol") != -1)
		rcontrol = string_to_number(values[peramitors.find("rcontrol")]);
	if (peramitors.find("lshift") != -1)
		lshift = string_to_number(values[peramitors.find("lshift")]);
	if (peramitors.find("rshift") != -1)
		rshift = string_to_number(values[peramitors.find("rshift")]);
	if (peramitors.find("lalt") != -1)
		lalt = string_to_number(values[peramitors.find("lalt")]);
	if (peramitors.find("ralt") != -1)
		ralt = string_to_number(values[peramitors.find("ralt")]);
	if (peramitors.find("defjoy") != -1)
		defjoy = string_to_number(values[peramitors.find("defjoy")]);
	if (peramitors.find("defjoyname") != -1)
		defjoyname = values[peramitors.find("defjoyname")];
	if (peramitors.find("stereotyping") != -1)
		stereotyping = string_to_number(values[peramitors.find("stereotyping")]);
	if (peramitors.find("braille_support") != -1)
		braille_support = string_to_number(values[peramitors.find("braille_support")]);
	if (peramitors.find("youtube_format") != -1)
		youtube_format = values[peramitors.find("youtube_format")];
	if (peramitors.find("microphone_samplerate") != -1)
		microphone_samplerate = string_to_number(values[peramitors.find("microphone_samplerate")]);
	if (peramitors.find("microphonechannels") != -1)
		microphonechannels = string_to_number(values[peramitors.find("microphonechannels")]);
	if (peramitors.find("vmode") != -1)
		vmode = string_to_number(values[peramitors.find("vmode")]);
	if (peramitors.find("speak_chars") != -1)
		speak_chars = string_to_number(values[peramitors.find("speak_chars")]);
	//if(peramitors.find("playlogo")!=-1)
	//{
	//playlogo=string_to_number(values[peramitors.find("playlogo")]);
	//}
	if (peramitors.find("preloader") != -1)
		preloader = string_to_number(values[peramitors.find("preloader")]);
	if (peramitors.find("lastruns") != -1)
		lastruns = string_to_number(values[peramitors.find("lastruns")]);
	if (peramitors.find("soundcard") != -1) {
		soundcard = string_to_number(values[peramitors.find("soundcard")]);
		sound_output_device = soundcard;
	}
	if (peramitors.find("soundcardname") != -1)
		soundcardname = values[peramitors.find("soundcardname")];
	if (peramitors.find("speechmode") != -1)
		speechmode = string_to_number(values[peramitors.find("speechmode")]);
	if (peramitors.find("wrap") != -1)
		wrap = string_to_number(values[peramitors.find("wrap")]);
	if (peramitors.find("letters_autoactivate") != -1)
		letters_autoactivate = string_to_number(values[peramitors.find("letters_autoactivate")]);
	if (peramitors.find("sidescrolling") != -1)
		sidescrolling = string_to_number(values[peramitors.find("sidescrolling")]);
	if (peramitors.find("buffermode") != -1)
		buffermode = string_to_number(values[peramitors.find("buffermode")]);
	if (peramitors.find("ssbuffermode") != -1)
		ssbuffermode = string_to_number(values[peramitors.find("ssbuffermode")]);
	if (peramitors.find("vrepeat") != -1)
		v.repeat = string_to_number(values[peramitors.find("vrepeat")]);
	if (peramitors.find("vcaps") != -1)
		v.caps = string_to_number(values[peramitors.find("vcaps")]);
	if (peramitors.find("vkeyboardclicks") != -1)
		v.keyboardclicks = string_to_number(values[peramitors.find("vkeyboardclicks")]);
	if (peramitors.find("vkeyboardtheme") != -1)
		v.keyboardtheme = string_to_number(values[peramitors.find("vkeyboardtheme")]);
	if (peramitors.find("vkeyboardsoundforothers") != -1)
		v.keyboardsoundforothers = string_to_number(values[peramitors.find("vkeyboardsoundforothers")]);
	if (peramitors.find("vhearotherskeyboardsound") != -1)
		v.hearotherskeyboardsound = string_to_number(values[peramitors.find("vhearotherskeyboardsound")]);
	if (peramitors.find("vbraille_mode") != -1)
		v.braille_mode = string_to_number(values[peramitors.find("vbraille_mode")]);
	if (peramitors.find("pvrepeat") != -1)
		pv.repeat = string_to_number(values[peramitors.find("pvrepeat")]);
	if (peramitors.find("pvcaps") != -1)
		pv.caps = string_to_number(values[peramitors.find("pvcaps")]);
	if (peramitors.find("pvkeyboardclicks") != -1)
		pv.keyboardclicks = string_to_number(values[peramitors.find("pvkeyboardclicks")]);
	if (peramitors.find("pvkeyboardsoundforothers") != -1)
		pv.keyboardsoundforothers = string_to_number(values[peramitors.find("pvkeyboardsoundforothers")]);
	if (peramitors.find("pvhearotherskeyboardsound") != -1)
		pv.hearotherskeyboardsound = string_to_number(values[peramitors.find("pvhearotherskeyboardsound")]);
	if (peramitors.find("pvbraille_mode") != -1)
		pv.braille_mode = string_to_number(values[peramitors.find("pvbraille_mode")]);
	if (peramitors.find("menumusvol") != -1)
		menumusvol = string_to_number(values[peramitors.find("menumusvol")]);
	if (peramitors.find("mvol") != -1)
		mvol = string_to_number(values[peramitors.find("mvol")]);
	if (peramitors.find("motdhash") != -1)
		motdhash = values[peramitors.find("motdhash")];
	if (peramitors.find("ap") != -1)
		ap = values[peramitors.find("ap")];
	if (peramitors.find("apl") != -1)
		apl = values[peramitors.find("apl")];
	if (peramitors.find("mv") != -1)
		mv = string_to_number(values[peramitors.find("mv")]);
	if (peramitors.find("importbufferlogs") != -1)
		importbufferlogs = string_to_number(values[peramitors.find("importbufferlogs")]);
	if (peramitors.find("trackingmode") != -1)
		trackingmode = string_to_number(values[peramitors.find("trackingmode")]);
	if (peramitors.find("savevoicechats") != -1)
		savevoicechats = string_to_number(values[peramitors.find("savevoicechats")]);
	if (peramitors.find("savettschats") != -1)
		savettschats = string_to_number(values[peramitors.find("savettschats")]);
	if (peramitors.find("hearyourvoicechat") != -1)
		hearyourvoicechat = string_to_number(values[peramitors.find("hearyourvoicechat")]);
	if (peramitors.find("hearyourttschat") != -1)
		hearyourttschat = string_to_number(values[peramitors.find("hearyourttschat")]);
	if (peramitors.find("hearothersvoicechat") != -1)
		hearothersvoicechat = string_to_number(values[peramitors.find("hearothersvoicechat")]);
	if (peramitors.find("hearothersttschat") != -1)
		hearothersttschat = string_to_number(values[peramitors.find("hearothersttschat")]);
	if (peramitors.find("hearotherspmsound") != -1)
		hearotherspmsound = string_to_number(values[peramitors.find("hearotherspmsound")]);
	if (peramitors.find("othershearyourpmsound") != -1)
		othershearyourpmsound = string_to_number(values[peramitors.find("othershearyourpmsound")]);
	if (peramitors.find("sitting") != -1)
		sitting = string_to_number(values[peramitors.find("sitting")]);
	if (peramitors.find("translator") != -1)
		translator = string_to_number(values[peramitors.find("translator")]);
	if (peramitors.find("klangpos") != -1)
		klangpos = string_to_number(values[peramitors.find("klangpos")]);
	if (peramitors.find("langfile") != -1) {
		currentlangfile = values[peramitors.find("langfile")];
		lngdata = file_get_contents("languages\\" + currentlangfile + ".lng");
	}
	if (peramitors.find("keyboardlangfile") != -1) {
		currentkeyboardlangfile = values[peramitors.find("keyboardlangfile")];
		keyboarddata = file_get_contents("keyboard_languages\\" + currentkeyboardlangfile + ".lng");
	}
	for (int i = 0; i < buffers.length(); i++) {
		if (peramitors.find("b" + i + "int") != -1)
			buffers[i].interrupt = int_to_bool(string_to_number(values[peramitors.find("b" + i + "int")]));
		if (peramitors.find("b" + i + "speak") != -1)
			//buffers[i].speak = string_to_number(values[peramitors.find("b" + i + "speak")]);
		if (peramitors.find("b" + i + "active") != -1)
			buffers[i].active = string_to_number(values[peramitors.find("b" + i + "active")]);
	}
	for (uint i = 0; i < peramitors.length(); i++) {
		if (string_contains(peramitors[i], "klangi", 1) > -1)
			klang.insert_last(string_trim_left(peramitors[i], 6));
		if (string_contains(peramitors[i], "aliasesi", 1) > -1)
			aliases.insert_last(string_trim_left(peramitors[i], 8));
		if (string_contains(peramitors[i], "script_keysi", 1) > -1)
			script_keys.insert_last(string_trim_left(peramitors[i], 12));
		if (string_contains(peramitors[i], "accountsi", 1) > -1)
			accounts.insert_last(string_trim_left(peramitors[i], 9));
		if (string_contains(peramitors[i], "soundsi", 1) > -1)
			sounds.insert_last(string_trim_left(peramitors[i], 7));
		if (string_contains(peramitors[i], "keysi", 1) > -1)
			keys.insert_last(string_to_number(string_trim_left(peramitors[i], 5)));
	}
	f.close();
}
void writeprefs() {
	file f;
	f.open(prefsdir + "/config.dat", "w");
	string[] s = {
		"name=" + name ,
		"password=" + password ,
		"voicechat=" + voicechat ,
		"audioform_keyboard_echo=" + audioform_keyboard_echo ,
		"holdv=" + holdv ,
		"mfwc=" + mfwc ,
		"repeatingcamera=" + repeatingcamera ,
		"kh=" + kh ,
		"inputhelp=" + inputhelp ,
		"saveinputbox=" + saveinputbox ,
		"volumestream=" + volumestream ,
		"mmusic_volume=" + mmusic_volume ,
		"volume=" + volume ,
		"pitch=" + pitch ,
		"have_cycle_inventory=" + have_cycle_inventory,
		"behind_pitch_decrease="+behind_pitch_decrease,
		"xx="+xx,
		"scuffs="+scuffs,
		"itemsound="+itemsound,
		"walktime="+walktime,
		"airtime="+airtime,
		"bmovetime="+bmovetime,
		"asktoexit="+asktoexit,
		"askbid="+askbid,
		"askauction="+askauction,
		"zonestatus="+zonestatus,
		"voiceindex="+voiceindex,
		"bufferbeep="+bufferbeep,
		"dreaming="+dreaming,
		"vrepeat="+v.repeat,
		"vcaps="+v.caps,
		"vkeyboardclicks="+v.keyboardclicks,
		"vkeyboardtheme="+v.keyboardtheme,
		"vkeyboardsoundforothers="+v.keyboardsoundforothers,
		"vhearotherskeyboardsound="+v.hearotherskeyboardsound,
		"vbraille_mode="+v.braille_mode,
		"pvrepeat="+pv.repeat,
		"pvcaps="+pv.caps,
		"pvkeyboardclicks="+pv.keyboardclicks,
		"pvkeyboardsoundforothers="+pv.keyboardsoundforothers,
		"pvhearotherskeyboardsound="+pv.hearotherskeyboardsound,
		"pvbraille_mode="+pv.braille_mode,
		"rules="+rules,
		"startlng="+startlng,
		"lng="+lng,
		"winsound="+winsound,
		"mouse="+mouse,
		"djoystick="+djoystick,
		"mutetts="+mutetts,
		"voice="+voice,
		"pitch="+pitch,
		"twitteraccess="+twitteraccess,
		"musictrack="+musictrack,
		"menuopen="+menuopen,
		"menuedge="+menuedge,
		"menuenter="+menuenter,
		"menuclick="+menuclick,
		"menuclose="+menuclose,
		"menuwrap="+menuwrap,
		"ouviremoutrasjanelas="+ouviremoutrasjanelas,
		"autologin="+autologin,
		"autolower="+autolower,
		"readchats="+ readchats,
		"readolmsg="+ readolmsg,
		"readdeathmsg="+ readdeathmsg,
		"chatsound="+chatsound,
		"jumpsound="+jumpsound,
		"localchatsound="+localchatsound,
		"onlinesound="+onlinesound,
		"offlinesound="+offlinesound,
		"pmsound="+pmsound,
		"chsound="+chsound,
		"lcsound="+lcsound,
		"onsound="+onsound,
		"offsound="+offsound,
		"pmsgsound="+pmsgsound,
		"lcontrol="+lcontrol,
		"rcontrol="+rcontrol,
		"lshift="+lshift,
		"rshift="+rshift,
		"lalt="+lalt,
		"ralt="+ralt,
		"defjoy="+ defjoy,
		"defjoyname="+ defjoyname,
		"stereotyping="+stereotyping,
		"braille_support="+braille_support,
		"youtube_format="+youtube_format,
		"microphone_samplerate="+microphone_samplerate,
		"microphonechannels="+microphonechannels,
		"vmode="+vmode,
		"sapiforce="+ sapiforce,
		"speak_chars="+speak_chars,
		"preloader="+preloader,
		"lastruns="+lastruns,
		"soundcard="+sound_output_device,
		"soundcardname="+soundcardname,
		"speechmode="+speechmode,
		"wrap="+wrap,
		"first_letter_navigation="+first_letter_navigation,
		"multi_letter_navigation="+multi_letter_navigation,
		"letters_autoactivate="+letters_autoactivate,
		"sidescrolling="+sidescrolling,
		"buffermode="+buffermode,
		"ssbuffermode="+ssbuffermode,
		"motdhash="+motdhash,
		"ap="+ap,
		"apl="+apl,
		"mv="+mv,
		"importbufferlogs="+importbufferlogs,
		"trackingmode="+trackingmode,
		"savevoicechats="+savevoicechats,
		"savettschats="+savettschats,
		"hearyourvoicechat="+hearyourvoicechat,
		"hearyourttschat="+hearyourttschat,
		"hearothersvoicechat="+hearothersvoicechat,
		"hearothersttschat="+hearothersttschat,
		"hearotherspmsound="+hearotherspmsound,
		"othershearyourpmsound="+othershearyourpmsound,
		"langfile="+currentlangfile,
		"keyboardlangfile="+currentkeyboardlangfile,
		"sitting="+sitting,
		"translator="+translator,
		"klangpos="+klangpos,
		"readerinterrupt="+readerinterrupt,
		"menumusvol="+menumusvol,
		"mvol="+mvol
	};
	for (int i = 0; i < buffers.length(); i++) {
		s.insert_last("b" + i + "int=" + bool_to_int(buffers[i].interrupt));
		//s.insert_last("b" + i + "speak=" + buffers[i].speak);
		s.insert_last("b" + i + "active=" + buffers[i].active);
	}
	for (uint i = 0; i < sounds.length(); i++)
		s.insert_last("soundsi" + sounds[i] + "=" + sounds[i]);
	for (uint i = 0; i < keys.length(); i++)
		s.insert_last("keysi" + keys[i] + "=" + keys[i]);
	for (uint i = 0; i < klang.length(); i++)
		s.insert_last("klangi" + klang[i] + "=" + klang[i]);
	for (uint i = 0; i < aliases.length(); i++)
		s.insert_last("aliasesi" + aliases[i] + "=" + aliases[i]);
	for (uint i = 0; i < script_keys.length(); i++)
		s.insert_last("script_keysi" + script_keys[i] + "=" + script_keys[i]);
	for (uint i = 0; i < accounts.length(); i++)
		s.insert_last("accountsi" + accounts[i] + "=" + accounts[i]);
	string ss = string_encrypt(join(s, "\n"), "charbhoom");
	f.write(ss);
	f.close();
}
void send_reliable(uint peer, string mess, uint channel) {
	mess.replace_this("\r\n", "\n");
	n.send_reliable(peer, mess, channel);
}
void send_unreliable(uint peer, string mess, uint channel) {
	mess.replace_this("\r\n", "\n");
	n.send_unreliable(peer, mess, channel);
}
bool inv_add_item(string itemname, double itemvalue) {
	return inv.give(itemname, itemvalue);
}
bool inv_item_exists(string itemname) {
	return inv.exists(itemname);
}
double inv_item_number(string itemname) {
	return inv.get_item_amount(itemname);
}
int inv_item(string itemname) {
	return inv.get_item_index(itemname);
}
bool inv_delete_item(string itemname) {
	return inv.remove(itemname);
}
void put(string item, double amount = 1) {
	send_reliable(peer_id, "invput " + amount + " " + item, 0);
}
void handscheck() {
	if (lefthand != "" && inv.get_item_amount(lefthand) < 1) {
		lefthand = "";
		llastuse = "";
	}
	if (righthand != "" && inv.get_item_amount(righthand) < 1) {
		righthand = "";
		rlastuse = "";
	}
	if (draw != "" && inv.get_item_amount(draw) < 1) {
		draw = "";
	}
}
void drop(string item, double amount) {
	send_reliable(peer_id, "drop " + amount + " " + item, 0);
}
void driveloop() {
	string files = select_file("C:");
	run("C:\\Windows\\explorer.exe", files, false, false);
}
void linkloop() {
	int volume = 10000;
	string link = v.input("enter the link that should be played");
	long streamlink;
	if (string_contains(link, "youtube.com", 1) > -1) {
		run("C:\\Windows\\System32\\cmd.exe", "/c youtube-dl.exe -g " + link + "  -f mp4 > l.txt", true, true);
		file f;
		f.open("l.txt", "rb");
		string r = f.read();
		f.close();
		file_delete("l.txt");
		stream.load(r);
		stream.play();
	} else {
		stream.load(link);
		stream.play();
	}
	while (true) {
		wait(5);
		mainloop();
		if (key_pressed(KEY_ESCAPE)) {
			stream.stop();
			appsmenu();
			break;
		}
		if (key_pressed(KEY_HOME) and volume < 10000) {
			volume += 500;
			stream.set_volume(volume);
		}
		if (key_pressed(KEY_END) and volume > 0) {
			volume -= 500;
			stream.set_volume(volume);
		}
	}
}
void netloop() {
	bagclosecheck();
	while ((e = n.request()).type != event_none) {
		if (e.type == event_disconnect)
			reconnect();
		if (e.type == event_receive) {
			if (e.channel == 0) {
				string[] parsed = string_split(get_event_message(), " ", true);
				messager mdic = get_event_message_as_object();
				if (mdic.get_value("message") == "bsend") {
					string buffer = mdic.get_value("buffer");
					string whichsound = mdic.get_value("soundname");
					string msg = mdic.get_value("text");
					string wn = mdic.get_value("name");
					if (buffer == "") buffer = "misc";
					if (whichsound != "" && ((!buffer_muted(buffer) && buffer_active(buffer) == 1) || name == wn)) p.play_stationary(whichsound, false);
					if (msg != "") add_buffer_item(buffer, msg, force_speech = name == wn);
					return;
				} else if (mdic.get_value("message") == "pm") {
					string w = mdic.get_value("name");
					string dn = mdic.get_value("dname", w);
					string msg = mdic.get_value("msg");
					bool yreply = int_to_bool(stn(mdic.get_value("yreply", "0")));
					bool reply = int_to_bool(stn(mdic.get_value("reply", "0")));
					if (w == "" || dn == "" || msg == "") return;
					if (!buffer_muted("private messages")) {
						if (pmsound == "random") {
							if (pmsgsound == 1) {
								p.play_stationary("pm" + random(1, 19) + ".ogg", false);
								if (othershearyourpmsound == 1) send_reliable(peer_id, "pmsound2 pm" + random(1, 19) + ".ogg", 7);
							} else {
								p.play_stationary("pm" + random(1, 19) + ".ogg", false);
								if (othershearyourpmsound == 1) send_reliable(peer_id, "pmsound1 pm" + random(1, 19) + ".ogg", 7);
							}
						} else {
							if (pmsgsound == 1) {
								p.play_stationary(pmsound + ".ogg", false);
								if (othershearyourpmsound == 1) send_reliable(peer_id, "pmsound2 " + pmsound + ".ogg", 7);
							} else {
								p.play_stationary(pmsound + ".ogg", false);
								if (othershearyourpmsound == 1) send_reliable(peer_id, "pmsound1 " + pmsound + ".ogg", 7);
							}
						}
					}
					if (!reply) {
						if (yreply) {
							bspeak("You sent to " + dn + ": " + msg, "private messages");
						} else {
							add_buffer_item("private messages", "Private message from " + dn + ": " + msg);
						}
						add_pm(w, dn, msg, reply, yreply);
						return;
					}
					if (yreply)
						bspeak("You replied to " + dn + ": " + msg, "private messages");
					else
						add_buffer_item("private messages", "Replied message from " + dn + ": " + msg);
					add_pm(w, dn, msg, reply, yreply);
					return;
				} else if (mdic.get_value("message") == "launchcmenu") {
					messager j = mdic;
					string i = j.get_value("intro");
					string t = j.get_value("packet");
					string[] emp;
					string[] items = j.get_value("items").split("{cmu}", true);
					string[] infs = j.get_value("informationals").split("{inf}", true);
					bool saydlg = int_to_bool(stn(j.get_value("saydlg")));
					int type = stn(j.get_value("type", "0"));
					string focus = j.get_value("focus", "");
					cserver_menu(t, i, items, saydlg, infs, type, focus);
					return;
				} else if (mdic.get_value("message") == "launchcmenupage") {
					messager j = mdic;
					string i = j.get_value("intro");
					string t = j.get_value("packet");
					string[] emp;
					string[] items = j.get_value("items").split("{cmu}", true);
					int page = stn(j.get_value("page"));
					int maxi = stn(j.get_value("maxi"));
					bool saydlg = int_to_bool(stn(j.get_value("saydlg")));
					string[] infs = j.get_value("informationals").split("{inf}", true);
					int type = stn(j.get_value("type", "0"));
					if (page < 1) page = 1;
					if (maxi < 1) maxi = 1;
					cserver_menu_page(t, i, items, page, maxi, saydlg, infs, type);
					return;
				} else if (mdic.get_value("message") == "serverinput") {
					serverinput(mdic);
					return;
				} else if (parsed[0] == "zones")
					checkarroundmenu();
				else if (parsed[0] == "tiles")
					checkarroundtilesmenu();
				else if (parsed[0] == "setgender" and parsed.length() > 1)
					gender = string_to_number(parsed[1]);
				else if (parsed[0] == "loop_s" and parsed.length() > 1) {
					string snd = parsed[1];
					svrsound.load(snd);
					svrsound.play_looped();
				} else if (parsed[0] == "bid" and parsed.length() == 3)
					bid(parsed[1], string_to_number(parsed[2]));
				else if (parsed[0] == "inv" and parsed.length() >= 1)
					inv.import_inv(string_replace(get_event_message(), "inv ", "", true));
				else if (parsed[0] == "help")
					helpmenu();
				else if (parsed[0] == "havecycleinventory" and parsed.length() > 1) {
					have_cycle_inventory = string_to_number(parsed[1]);
					if (have_cycle_inventory == 1)
						send_reliable(peer_id, "cycleinventoryrequest", 0);
					writeprefs();
					speak("having cycle inventory has been " + (have_cycle_inventory == 1 ? "enabled" : "disabled"));
					mainmenu(true);
				} else if (parsed[0] == "writefile") {
					string filename = parsed[1];
					string text = string_replace(get_event_message(), parsed[0] + " " + parsed[1] + " ", "", false);
					file f;
					f.open(filename, "wb");
					f.write(text);
					f.close();
				} else if (parsed[0] == "writefile2") {
					if (!directory_exists("inventory backups")) directory_create("inventory backups");
					string text = string_replace(get_event_message(), parsed[0] + " ", "", false);
					file f;
					f.open("inventory backups/" + DATE_WEEKDAY_NAME + ", " + DATE_MONTH_NAME + "-" + DATE_DAY + "-" + DATE_YEAR + ", " + TIME_HOUR + " " + TIME_MINUTE + " " + TIME_SECOND + ".txt", "wb");
					f.write(text);
					f.close();
				} else if (parsed[0] == "buildreverb") {
					buildreverb();
				} else if (parsed[0] == "buildev") {
					buildev();
				} else if (parsed[0] == "buildfloor") {
					buildfloor();
				} else if (parsed[0] == "builddmg") {
					builddmg();
				} else if (parsed[0] == "buildwritemap") {
					string filename = parsed[1];
					string text = string_replace(get_event_message(), parsed[0] + " " + parsed[1] + " ", "", false);
					if (!directory_exists("maps"))
						directory_create("maps");
					file f;
					f.open("maps/" + filename + ".txt", "wb");
					f.write(text);
					f.close();
					add_sbuffer_item("speech", "" + filename + " has been backed up successfully and it's in maps directory");
					add_buffer_item("maps", "" + filename + " has been backed up successfully and it's in maps directory");
				} else if (parsed[0] == "buildrestorebackup") {
					string filename = parsed[1];
					if (!directory_exists("maps")) {
						directory_create("maps");
						speak("no backups found for this map");
						return;
					}
					if (!file_exists("maps/" + filename + ".txt")) {
						speak("no backups found for this map");
						return;
					}
					file f;
					f.open("maps/" + filename + ".txt", "rb");
					string r = f.read();
					f.close();
					send_reliable(peer_id, "/rawdata " + r, 1);
					add_sbuffer_item("speech", "" + filename + "'s backup has been restored successfully");
					add_buffer_item("maps", "" + filename + "'s backup has been restored successfully");
				} else if (parsed[0] == "pong" and pinging == true) {
					pingpongtimer.pause();
					int ms = pingpongtimer.elapsed;
					pinging = false;
					p.play_stationary("pingstop1.ogg", false);
					string spk;
					spk = "The ping took ";
					if (ms < 1000) //1second.
						spk += ms + " milliseconds";
					else
						spk += ms + " milliseconds, " + ms_to_readable_time(ms);
					add_sbuffer_item("speech", spk);
					add_buffer_item("pings", spk);
				} else if (parsed[0] == "teamstore")
					teamstore(string_replace(get_event_message(), "teamstore ", "", true));
				else if (parsed[0] == "creditpurchase" and parsed.length() > 2) {
					string username = parsed[1];
					int amount = string_to_number(parsed[2]);
					setupmenu(false, true);
					m.add_item_tts("I live in Iran", "iran");
					m.add_item_tts("I live somewhere other than Iran", "othercountry");
					m.add_item_tts("go back", "back");
					m.set_callback(netclb, "");
					int mres = m.run("Where do  you live?", true);
					if (mres == 1) {
						dlg("press enter to be redirected to the Payment gateway");
						run("c:\\windows\\explorer.exe", "http://aew-game.com/shop/?username=" + username + "&credit=" + amount + "", false, false);
					} else if (mres == 2) {
						dlg("press enter to be redirected to our paypal link to make your purchase");
						run("c:\\windows\\explorer.exe", "https://paypal.me/debaquilino", false, false);
					}
				} else if (parsed[0] == "dlg") {
					string alert = string_replace(get_event_message(), "dlg ", "", false);
					dlg(alert, true);
				} else if (parsed[0] == "setcoords") {
					me.x = string_to_number(parsed[1]);
					me.y = string_to_number(parsed[2]);
					me.z = string_to_number(parsed[3]);
				} else if (parsed[0] == "garbage_collect")
					garbage_collect();
				else if (parsed[0] == "rapid")
					rapidfire = 1;
				else if (parsed[0] == "notrapid")
					rapidfire = 0;
				else if (parsed[0] == "mnormal") mnormal(string_replace(get_event_message(), "mnormal ", "", true));
				else if (parsed[0] == "mtext") mtext(string_replace(get_event_message(), "mtext ", "", true));
				else if (parsed[0] == "lchan")
					send_reliable(peer_id, "lchannel", 0);
				else if (parsed[0] == "sitstart")
					sitting = 1;
				else if (parsed[0] == "sitstop")
					sitting = 0;
				else if (parsed[0] == "objs")
					items_menu(parsed[1]);
				else if (parsed[0] == "itemtrackstop") {
					for (int i = 0; i < tracks.length(); i++) {
						p.play_stationary("loctracked.ogg", false);
						p.destroy_sound(tracks[i].slot);
						tracks.remove_at(i);
					}
				} else if (parsed[0] == "spellslist")
					spellmenu(string_replace(get_event_message(), "spellslist ", "", true));
				else if (parsed[0] == "store") {
					string final = string_replace(get_event_message(), "store ", "", false);
					store_menu(final);
				} else if (parsed[0] == "invdrop") {
					inv.reset();
					llastuse = "";
					rlastuse = "";
					lefthand = "";
					righthand = "";
					draw = "";
				} else if (parsed[0] == "inv" and parsed.length() >= 1)
					inv.import_inv(string_replace(get_event_message(), "inv ", "", true));
				else if (parsed[0] == "playfallsound" and parsed.length() > 4) {
					int x = string_to_number(parsed[1]);
					int y = string_to_number(parsed[2]);
					int z = string_to_number(parsed[3]);
					string map = parsed[4];
					pack@ pf = @sndpack;
					if (pf.file_exists((get_tile_at(x, y, z) + "trip.ogg"))) {
						if (get_tile_at(me.x, me.y, me.z) != "chair") {
							rvp.play_stationary(get_tile_at(x, y, z) + "trip.ogg", false);
							send_reliable(peer_id, "draw " + get_tile_at(x, y, z) + "trip.ogg", 7);
						} else if (get_tile_at(me.x, me.y, me.z) == "chair") {
							rvp.play_stationary(get_tile_at(x, y, z) + "trip.ogg", false);
							rvp.play_stationary("cadeira_ringindo" + random(1, 4) + ".ogg", false);
							send_reliable(peer_id, "draw " + get_tile_at(x, y, z) + "trip.ogg", 7);
							send_reliable(peer_id, "draw cadeira_ringindo" + random(1, 4) + ".ogg", 7);
						}
					} else {
						rvp.play_3d(get_tile_at(x, y, z) + "fall.ogg", me.x, me.y, me.z, x, y, z, calculate_theta(facing), false);
						send_reliable(peer_id, "draw " + get_tile_at(x, y, z) + "fall.ogg", 7);
					}
				} else if (parsed[0] == "playscuffsound") {
					int x = string_to_number(parsed[1]);
					int y = string_to_number(parsed[2]);
					int z = string_to_number(parsed[3]);
					string map = parsed[4];
					if (scuffs == 1)
						rvp.play_3d(get_tile_at(x, y, z) + "scuff.ogg", me.x, me.y, me.z, x, y, z, calculate_theta(facing), false);
				} else if (parsed[0] == "inf") {
					dlg(parsed[1]);
					if (parsed[2] == "1") {
						exitgame();
						mainmenu();
					}
					if (parsed[2] == "2") {
						exitgame();
						exit();
					}
				} else if (parsed[0] == "msgnormal") {
					string m = string_replace(get_event_message(), parsed[0] + " ", "", true);
					add_sbuffer_item("speech", m);
					add_buffer_item("misc", m);
				} else if (parsed[0] == "open_menu") {
					string[]items;
					for (int i = 4; i < parsed.length(); i++)
						items.insert_last(parsed[i]);
					send_reliable(peer_id, parsed[2] + "|" + create_menu(items, parsed[1], parsed[3]), 0);
				} else if (parsed[0] == "upload")
					uploadfile();
				else if (parsed[0] == "ttschat" and parsed.length() > 1) {
					if (buffer_active("tts chats") == 1) {
						add_buffer_item("tts chats", string_replace(get_event_message(), parsed[0] + " ", "", false));
					}
				} else if (parsed[0] == "voicechat" and parsed.length() > 1) {
					if (buffer_active("voice chats") == 1) {
						add_buffer_item("voice chats", string_replace(get_event_message(), parsed[0] + " ", "", false));
					}
				} else if (parsed[0] == "lcmchat" and parsed.length() > 1) {
					if (buffer_active("lcm chats") == 1) {
						add_buffer_item("lcm chats", string_replace(get_event_message(), parsed[0] + " ", "", false));
					}
				} else if (parsed[0] == "partnerchat" and parsed.length() > 1) {
					if (buffer_active("partner chats") == 1) {
						add_buffer_item("partner chats", string_replace(get_event_message(), parsed[0] + " ", "", false));
					}
				} else if (parsed[0] == "adminchat" and parsed.length() > 1) {
					if (buffer_active("admin chats") == 1) {
						add_buffer_item("admin chats", string_replace(get_event_message(), parsed[0] + " ", "", false));
					}
				} else if (parsed[0] == "devchat" and parsed.length() > 1) {
					if (buffer_active("developer chats") == 1) {
						add_buffer_item("developer chats", string_replace(get_event_message(), parsed[0] + " ", "", false));
					}
				} else if (parsed[0] == "kills" and parsed.length() > 1) {
					if (buffer_active("kills") == 1 && !buffer_muted("kills")) {
						if (readdeathmsg == 1) {
							add_buffer_item("kills", string_replace(get_event_message(), parsed[0] + " ", "", false));
						}
					}
				} else if (parsed[0] == "robot" and parsed.length() > 1) {
					if (buffer_active("kills") == 1 && !buffer_muted("kills")) {
						p.play_stationary("robot_status.ogg", false);
						add_buffer_item("robot", string_replace(get_event_message(), parsed[0] + " ", "", false));
					}
				} else if (parsed[0] == "paid_store") {
					if (buffer_active("paid_store") == 1) {
						add_buffer_item("paid_store", string_replace(get_event_message(), parsed[0] + " ", "", false));
					}
				} else if (parsed[0] == "arena") {
					if (buffer_active("arena") == 1) {
						add_buffer_item("arena", string_replace(get_event_message(), parsed[0] + " ", "", false));
					}
				} else if (parsed[0] == "ping") {
					if (buffer_active("pings") == 1) {
						add_buffer_item("pings", string_replace(get_event_message(), parsed[0] + " ", "", false));
					}
				} else if (parsed[0] == "pm") {
					if (buffer_active("private messages") == 1) {
						if (!buffer_muted("private messages")) {
							if (pmsound == "random") {
								if (pmsgsound == 1) {
									p.play_stationary("pm" + random(1, 19) + ".ogg", false);
									if (othershearyourpmsound == 1) send_reliable(peer_id, "pmsound2 pm" + random(1, 19) + ".ogg", 7);
								} else {
									p.play_stationary("pm" + random(1, 19) + ".ogg", false);
									if (othershearyourpmsound == 1) send_reliable(peer_id, "pmsound1 pm" + random(1, 19) + ".ogg", 7);
								}
							} else {
								if (pmsgsound == 1) {
									p.play_stationary(pmsound + ".ogg", false);
									if (othershearyourpmsound == 1) send_reliable(peer_id, "pmsound2 " + pmsound + ".ogg", 7);
								} else {
									p.play_stationary(pmsound + ".ogg", false);
									if (othershearyourpmsound == 1) send_reliable(peer_id, "pmsound1 " + pmsound + ".ogg", 7);
								}
							}
						}
						add_buffer_item("private messages", string_replace(get_event_message(), parsed[0] + " ", "", false));
					}
				} else if (parsed[0] == "auctions") {
					if (buffer_active("auctions") == 1) {
						add_buffer_item("auctions", string_replace(get_event_message(), parsed[0] + " ", "", false));
					}
				} else if (parsed[0] == "donations") {
					if (buffer_active("donations") == 1) {
						add_buffer_item("donations", string_replace(get_event_message(), parsed[0] + " ", "", false));
					}
				} else if (parsed[0] == "managerchat") {
					if (buffer_active("manager chats") == 1) {
						add_buffer_item("manager chats", string_replace(get_event_message(), parsed[0] + " ", "", false));
					}
				} else if (parsed[0] == "connections") {
					if (buffer_active("connections") == 1) {
						if (readolmsg == 1) {
							add_buffer_item("connections", string_replace(get_event_message(), parsed[0] + " ", "", false));
						}
					}
				} else if (parsed[0] == "teamchat") {
					if (buffer_active("team chats") == 1) {
						add_buffer_item("team chats", string_replace(get_event_message(), parsed[0] + " ", "", false));
					}
				} else if (parsed[0] == "admintells") {
					if (buffer_active("admintells") == 1) {
						p.play_stationary("admintell.ogg", false);
						add_buffer_item("admintells", string_replace(get_event_message(), parsed[0] + " ", "", false));
					}
				} else if (parsed[0] == "localchat" and parsed.length() > 1) {
					if (buffer_active("local chats") == 1) {
						if (!buffer_muted("local chats")) {
							if (localchatsound == "random") {
								if (lcsound == 1) p.play_stationary("localchat" + random(1, 8) + ".ogg", false);
								else p.play_stationary("localchat" + random(1, 8) + ".ogg", false);
							} else {
								if (lcsound == 1) p.play_stationary(localchatsound + ".ogg", false);
								else p.play_stationary(localchatsound + ".ogg", false);
							}
						}
						add_buffer_item("local chats", string_replace(get_event_message(), parsed[0] + " ", "", false));
					}
				} else if (parsed[0] == "bike") {
					bforward();
					walktime += 1.05;
					airtime += 0.05;
					movecheck2();
				} else if (parsed[0] == "wandthrow_up") {
					wforward();
					movecheck();
				} else if (parsed[0] == "buildnewmap") {
					setupmenu(false, true);
					m.add_item_tts("2d", "2d");
					m.add_item_tts("3d", "3d");
					m.add_item_tts("go back", "back");
					m.set_callback(netclb, "");
					int mres = m.run("select your map type", true);
					if (mres == 1) {
						binput@ dat = builder_input("mapname=mapname
																				minx = enter the minimum x
						maxx = enter the maximum x
						miny = enter the minimum y
						maxy = enter the maximum y");
																							 if (@dat == null) return;
																				string platform = plattypemenu();
																				if (platform == "")
																					return;
																					send_reliable(peer_id, "2dnewmap " + dat.str("mapname") + " " + dat.num("minx") + " " + dat.num("maxx") + " 0 0 " + dat.num("miny") + " " + dat.num("maxy") + " " + platform, 0);
						} else if (mres == 2) {
						binput@ dat = builder_input("mapname=mapname
																				minx = enter the minimum x
						maxx = enter the maximum x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the minimum z
						maxz = enter the maximum z");
																							 if (@dat == null) return;
																				string platform = plattypemenu();
																				if (platform == "")
																					return;
																					send_reliable(peer_id, "newmap " + dat.str("mapname") + " " + dat.num("minx") + " " + dat.num("maxx") + " " + dat.num("miny") + " " + dat.num("maxy") + " " + dat.num("minz") + " " + dat.num("maxz") + " " + platform, 0);
						}
				} else if (parsed[0] == "buildvending_machine") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("vx=enter the x
																				vy = enter the y
						vz = enter the z");
						if (@dat != null) {
						if (dat.num("vx")<min.x or dat.num("vx")>max.x or dat.num("vy")<min.y or dat.num("vy")>max.y or dat.num("vz")<min.z or dat.num("vz")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addvending_machine vending_machine:" + dat.num("vx") + ":" + dat.num("vy") + ":" + dat.num("vz"), 0);
						}
					} else {
						binput@ dat = builder_input("vx=enter the x
																				vy = enter the y");
						if (@dat != null) {
						if (dat.num("vx")<min.x or dat.num("vx")>max.x or dat.num("vy")<min.z or dat.num("vy")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addvending_machine vending_machine:" + dat.num("vx") + ":0:" + dat.num("vy"), 0);
						}
					}
				} else if (parsed[0] == "buildcheckpoint") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("cx=enter the x
																				cy = enter the y
						cz = enter the z");
						if (@dat != null) {
						if (dat.num("cx")<min.x or dat.num("cx")>max.x or dat.num("cy")<min.y or dat.num("cy")>max.y or dat.num("cz")<min.z or dat.num("cz")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addcheckpoint checkpoint:" + dat.num("cx") + ":" + dat.num("cy") + ":" + dat.num("cz"), 0);
						}
					} else {
						binput@ dat = builder_input("cx=enter the x
																				cy = enter the y");
						if (@dat != null) {
						if (dat.num("cx")<min.x or dat.num("cx")>max.x or dat.num("cy")<min.z or dat.num("cy")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addcheckpoint checkpoint:" + dat.num("cx") + ":0:" + dat.num("cy"), 0);
						}
					}
				} else if (parsed[0] == "buildfiremap") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						fdam = enter the damage that fire takes
						fhurttime = how much milliseconds should be wated before next hit");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addfiremap fire:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("fdam") + ":" + dat.num("fhurttime"), 0);
						}
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						fdam = enter the damage that fire takes
						fhurttime = how much milliseconds should be wated before next hit");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addfiremap fire:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("fdam") + ":" + dat.num("fhurttime"), 0);
						}
					}
				} else if (parsed[0] == "buildtoilet") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addtoilet toilet:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz"), 0);
						}
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y ");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addtoilet toilet:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy"), 0);
						}
					}
				} else if (parsed[0] == "buildtrashcan") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addtrashcan trashcan:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz"), 0);
						}
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addtrashcan trashcan:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy"), 0);
						}
					}
				} else if (parsed[0] == "buildstarting_point") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addstarting_point starting_point:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz"), 0);
						}
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addstarting_point starting_point:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy"), 0);
						}
					}
				} else if (parsed[0] == "builddeathpoint") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "adddeathpoint deathpoint:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz"), 0);
						}
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "adddeathpoint deathpoint:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy"), 0);
						}
					}
				} else if (parsed[0] == "buildwashbasin") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addwashbasin washbasin:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz"), 0);
						}
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addwashbasin washbasin:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy"), 0);
						}
					}
				} else if (parsed[0] == "buildshower") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addshower shower:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz"), 0);
						}
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addshower shower:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy"), 0);
						}
					}
				} else if (parsed[0] == "buildzone") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						text = enter the text");
						if (@dat != null) {
						string temp = "";
						int trackable = yesno("would you like this zone to be trackable via the zone tracker  menu?");
							if (trackable == 1) temp = ":trackme";
							if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addzone zone:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.str("text") + temp, 0);
						}
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						text = enter the text");
						if (@dat != null) {
						string temp = "";
						int trackable = yesno("would you like this zone to be trackable via the zone tracker  menu?");
							if (trackable == 1) temp = ":trackme";
							if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addzone zone:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.str("text") + temp, 0);
						}
					}
				} else if (parsed[0] == "buildsafezone") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addsafezone safezone:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz"), 0);
						}
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addsafezone safezone:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy"), 0);
						}
					}
				} else if (parsed[0] == "buildbed") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addbed bed:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz"), 0);
						}
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addbed bed:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy"), 0);
						}
					}
				} else if (parsed[0] == "buildclock") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						text = enter the text which should be displayed when checking the time. You can leave it empty if you don't want anything to be displayed before time checking");
						if (@dat != null) {
							if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
									speak("error. Given coordinates are out of range");
									return;
								}
								send_reliable(peer_id, "addclock clock:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.str("text"), 0);
							}
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						text = enter the text which should be displayed when checking the time. You can leave it empty if you don't want anything to be displayed before time checking");
						if (@dat != null) {
							if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
									speak("error. Given coordinates are out of range");
									return;
								}
								send_reliable(peer_id, "addclock clock:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.str("text"), 0);
							}
					}
				} else if (parsed[0] == "buildcalendar") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						text = enter the text which should be displayed when checking the date. You can leave it empty if you don't want anything to be displayed before date checking");
						if (@dat != null) {
							if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
									speak("error. Given coordinates are out of range");
									return;
								}
								send_reliable(peer_id, "addcalendar calendar:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.str("text"), 0);
							}
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						text = enter the text which should be displayed when checking the date. You can leave it empty if you don't want anything to be displayed before date checking");
						if (@dat != null) {
							if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
									speak("error. Given coordinates are out of range");
									return;
								}
								send_reliable(peer_id, "addcalendar calendar:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.str("text"), 0);
							}
					}
				} else if (parsed[0] == "buildoven") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addoven oven:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz"), 0);
						}
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addoven oven:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy"), 0);
						}
					}
				} else if (parsed[0] == "buildfishing_coordinate") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addfishingcoordinate fishingcoordinate:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz"), 0);
						}
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addfishingcoordinate fishingcoordinate:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy"), 0);
						}
					}
				} else if (parsed[0] == "buildtxt") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						txtt = enter the text");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addtxt txt:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.str("txtt"), 0);
						}
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						txtt = enter the text");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addtxt txt:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.str("txtt"), 0);
						}
					}
				} else if (parsed[0] == "builddialog") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						dialogtext = enter dialog texts, seperate them with ==, For example hi == how are you");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "adddialog dialog:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.str("dialogtext"), 0);
						}
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						dialogtext = enter dialog texts, seperate them with ==, For example hi == how are you");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "adddialog dialog:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.str("dialogtext"), 0);
						}
					}
				} else if (parsed[0] == "buildautomatic_dialog") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						automatic_dialogtext = enter automatic_dialog texts, seperate them with ==, For example hi == how are you");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addautomatic_dialog automatic_dialog:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.str("automatic_dialogtext"), 0);
						}
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						automatic_dialogtext = enter automatic_dialog texts, seperate them with ==, For example hi == how are you");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addautomatic_dialog automatic_dialog:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.str("automatic_dialogtext"), 0);
						}
					}
				} else if (parsed[0] == "buildtimedtext") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						txttimer = how much milliseconds should be wated before next speak
						txtt = enter the text");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addtimedtext timedtext:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("txttimer") + ":" + dat.str("txtt"), 0);
						}
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						txttimer = how much milliseconds should be wated before next speak
						txtt = enter the text");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addtimedtext timedtext:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("txttimer") + ":" + dat.str("txtt"), 0);
						}
					}
				} else if (parsed[0] == "add_item_desc") {
					string item_name = v.input("Enter the item name", "");
					if (item_name != "" && !is_eloquence_crash_word(item_name) && get_sequence(item_name, true) <= 3) {
						string desc = v.input("Enter the description for " + item_name, "");
						if (desc != "" && !is_eloquence_crash_word(desc) && get_sequence(desc, true) <= 3)
							send_reliable(peer_id, "add_item_desc " + item_name + " " + desc, 0);
						else
							speak("Invalid description input!");
					} else
						speak("Invalid item name!");
				} else if (parsed[0] == "edit_item_desc" && parsed.length() >= 1) {
					string current_desc = string_replace(get_event_message(), parsed[0] + " ", "", true);
					string new_desc = input("Edit", "Edit the description (press enter when done)", current_desc);
					if (new_desc != "" && !is_eloquence_crash_word(new_desc) && get_sequence(new_desc, true) <= 3)
						send_reliable(peer_id, "edit_item_desc " + new_desc, 0);
					else
						speak("Invalid description input!");
				} else if (parsed[0] == "buildtimedsound") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						txttimer = how much milliseconds should be wated before next sound play");
																							 if (@dat == null) return;
																				string soundfile = list_ambiences();
						if (soundfile == "") {
							speak("canceled");
								return;
							}
						srcv(soundfile);
						string temp = "";
													int amb = yesno("would you like this source to work as an ambience?");
													if (amb == 1) temp = ":1";
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
							speak("error. Given coordinates are out of range");
								return;
							}
						send_reliable(peer_id, "addtimedsound timedsound:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("txttimer") + ":" + volume + ":" + pitch + ":" + soundfile + ".ogg" + temp, 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						txttimer = how much milliseconds should be wated before next sound play");
																							 if (@dat == null) return;
																				string soundfile = list_ambiences();
						if (soundfile == "") {
							speak("canceled");
								return;
							}
						srcv(soundfile);
						string temp = "";
													int amb = yesno("would you like this source to work as an ambience?");
													if (amb == 1) temp = ":1";
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
							speak("error. Given coordinates are out of range");
								return;
							}
						send_reliable(peer_id, "addtimedsound timedsound:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("txttimer") + ":" + volume + ":" + pitch + ":" + soundfile + ".ogg" + temp, 0);
					}
				} else if (parsed[0] == "buildtimedmusic") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						txttimer = how much milliseconds should be wated before next sound play");
																							 if (@dat == null) return;
																				string soundfile = list_ambiences();
						if (soundfile == "") {
							speak("canceled");
								return;
							}
						srcv(soundfile);
						string temp = "";
													int amb = yesno("would you like this source to work as an ambience?");
													if (amb == 1) temp = ":1";
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
							speak("error. Given coordinates are out of range");
								return;
							}
						send_reliable(peer_id, "addtimedmusic timedmusic:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("txttimer") + ":" + volume + ":" + pitch + ":" + soundfile + ".ogg" + temp, 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						txttimer = how much milliseconds should be wated before next sound play");
																							 if (@dat == null) return;
																				string soundfile = list_ambiences();
						if (soundfile == "") {
							speak("canceled");
								return;
							}
						srcv(soundfile);
						string temp = "";
													int amb = yesno("would you like this source to work as an ambience?");
													if (amb == 1) temp = ":1";
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
							speak("error. Given coordinates are out of range");
								return;
							}
						send_reliable(peer_id, "addtimedmusic timedmusic:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("txttimer") + ":" + volume + ":" + pitch + ":" + soundfile + ".ogg" + temp, 0);
					}
				} else if (parsed[0] == "builditem") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						itemt = how much milliseconds should be waited for next item spawning ?
																							 itemm = maximum amount of items
						itemo = item names. Use : to add new one, like coins : wood : metal");
						if (@dat != null) {
							if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
									speak("error. Given coordinates are out of range");
									return;
								}
								send_reliable(peer_id, "additem item:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("itemt") + ":" + dat.num("itemm") + ":" + dat.str("itemo"), 0);
							}
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						itemt = how much milliseconds should be waited for next item spawning ?
																							 itemm = maximum amount of items
						itemo = item names. Use : to add new one, like coins : wood : metal");
						if (@dat != null) {
							if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
									speak("error. Given coordinates are out of range");
									return;
								}
								send_reliable(peer_id, "additem item:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("itemt") + ":" + dat.num("itemm") + ":" + dat.str("itemo"), 0);
							}
					}
				} else if (parsed[0] == "builditem_usage_restriction") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						itemo = item names. Use : to add new one, like coins: wood: metal");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "additem_usage_restriction item_usage_restriction:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.str("itemo"), 0);
						}
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						itemo = item names. Use : to add new one, like coins: wood: metal");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "additem_usage_restriction item_usage_restriction:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.str("itemo"), 0);
						}
					}
				} else if (parsed[0] == "buildAI") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						AIt = how much milliseconds should be wated before next AI spawning
						AIm = maximum amount
						AIn = names, use: to add new one, like lion: boar: bear");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addAI ai:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("AIt") + ":" + dat.num("AIm") + ":" + dat.str("AIn"), 0);
						}
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						AIt = how much milliseconds should be wated before next AI spawning
						AIm = maximum amount
						AIn = names, use: to add new one, like lion: boar: bear");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addAI ai:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("AIt") + ":" + dat.num("AIm") + ":" + dat.str("AIn"), 0);
						}
					}
				} else if (parsed[0] == "createAI") {
					binput@ dat = builder_input("name=name
																			health = health. To be randomised, seperate the numbers with comma. For example, 1, 2
																			range = range. To be randomised, seperate the numbers with comma. For example, 1, 2
																			damage = damage. To be randomised, seperate the numbers with comma. For example, 1, 2
																			shoottime = shoottime. To be randomised, seperate the numbers with comma. For example, 1, 2
																			speed = speed. To turn it off, type - 1. To be randomised, seperate the numbers with comma. For example, 1, 2
																			xp = xp. To be randomised, seperate the numbers with comma. For example, 1, 2
																			stepsound = step sound with its extention. To turn it off, type none. To walk in the normal tiles, type gt. To be randomised, seperate them with comma. For example, step1, step2
																			painsound = pain sound with its extention. To turn it off, type none. To be randomised, seperate them with comma. For example, pain1, pain2
																			killsound = kill sound with its extention. To turn it off, type none. To be randomised, seperate them with comma. For example, kill1, kill2
																			shootsound = shoot sound with its extention. To turn it off, type none. To be randomised, seperate them with comma. For example, shoot1, shoot2
																			hitsound = hit sound with its extention. To turn it off, type none. To be randomised, seperate them with comma. For example, hit1, hit2
																			voice = voice with its extention. To turn it off, type none. To be randomised, seperate them with comma. For example, voice1, voice2
																			voicetime = voice time. To turn it off, type - 1. To be randomised, seperate them with comma. For example, 1, 2
																			item = item. To turn it off, type none. To be randomised, seperate them with comma. For example, item1, item2
																			amount = item amount. To turn it off, type - 1. To be randomised, seperate them with comma. For example, 1, 2
																			rapidvoice = will it's voice rapidly play? type 0 to say no or 1 to say yes
					treeclimb = can it go up from trees ? type 0 to say no or 1 to say yes
																					maddable = is it a wild creature ? type 0 to say no or 1 to say yes
																							needwater = is it a marine creature ? type 0 to say no or 1 to say yes
																									fallsound = fall sound with its extention. To turn it off, type none. To walk in the normal tiles, type gt. To be randomised, seperate them with comma. For example, fall1, fall2
																			nuclearbomb = should it die with explosion of a nuclear bomb ? type 0 to say no or 1 to say yes
																					mine = should it die by stepping in a mine ? type 0 to say no or 1 to say yes
																					gender = Gender of the AI type 0 for male, 1 for female, -1 or any other number for random");
					if (@dat != null) {
					if (dat.str("stepsound") != "none") {
							if (dat.str("stepsound") == "gt")
								aistepsoundsrcv(get_tile_at(me.x, me.y, me.z) + "step" + random(1, 5) + ".ogg");
							else {
								string[] split = string_split(dat.str("stepsound"), ",", true);
								if (split.length() == 1)
									aistepsoundsrcv(split[0]);
								else if (split.length() > 1) {
									string temp = split[random(0, split.length() - 1)];
									aistepsoundsrcv(temp);
								}
							}
						}
						if (dat.str("painsound") != "none") {
							string[] split = string_split(dat.str("painsound"), ",", true);
							if (split.length() == 1)
								aipainsoundsrcv(split[0]);
							else if (split.length() > 1) {
								string temp = split[random(0, split.length() - 1)];
								aipainsoundsrcv(temp);
							}
						}
						if (dat.str("killsound") != "none") {
							string[] split = string_split(dat.str("killsound"), ",", true);
							if (split.length() == 1)
								aikillsoundsrcv(split[0]);
							else if (split.length() > 1) {
								string temp = split[random(0, split.length() - 1)];
								aikillsoundsrcv(temp);
							}
						}
						if (dat.str("shootsound") != "none") {
							string[] split = string_split(dat.str("shootsound"), ",", true);
							if (split.length() == 1)
								aishootsoundsrcv(split[0]);
							else if (split.length() > 1) {
								string temp = split[random(0, split.length() - 1)];
								aishootsoundsrcv(temp);
							}
						}
						if (dat.str("hitsound") != "none") {
							string[] split = string_split(dat.str("hitsound"), ",", true);
							if (split.length() == 1)
								aihitsoundsrcv(split[0]);
							else if (split.length() > 1) {
								string temp = split[random(0, split.length() - 1)];
								aihitsoundsrcv(temp);
							}
						}
						if (dat.str("voice") != "none" and dat.str("rapidvoice") == 0) {
							string[] split = string_split(dat.str("voice"), ",", true);
							if (split.length() == 1)
								aivoicesrcv(split[0]);
							else if (split.length() > 1) {
								string temp = split[random(0, split.length() - 1)];
								aivoicesrcv(temp);
							}
						}
						if (dat.str("fallsound") != "none") {
							if (dat.str("fallsound") == "gt")
								aifallsoundsrcv(get_tile_at(me.x, me.y, me.z) + "fall" + random(1, 5) + ".ogg");
							else {
								string[] split = string_split(dat.str("fallsound"), ",", true);
								if (split.length() == 1)
									aifallsoundsrcv(split[0]);
								else if (split.length() > 1) {
									string temp = split[random(0, split.length() - 1)];
									aifallsoundsrcv(temp);
								}
							}
						}
						send_reliable(peer_id, "createAI " + dat.str("name") + ":" + dat.str("health") + ":" + dat.str("range") + ":" + dat.str("damage") + ":" + dat.str("shoottime") + ":" + dat.str("speed") + ":" + dat.str("xp") + ":" + dat.str("stepsound") + ":" + stepsoundpitch + ":" + stepsoundvolume + ":" + dat.str("painsound") + ":" + painsoundpitch + ":" + painsoundvolume + ":" + dat.str("killsound") + ":" + killsoundpitch + ":" + killsoundvolume + ":" + dat.str("shootsound") + ":" + shootsoundpitch + ":" + shootsoundvolume + ":" + dat.str("hitsound") + ":" + hitsoundpitch + ":" + hitsoundvolume + ":" + dat.str("voice") + ":" + voicepitch + ":" + voicevolume + ":" + dat.str("voicetime") + ":" + dat.str("item") + ":" + dat.str("amount") + ":" + dat.str("rapidvoice") + ":" + dat.str("treeclimb") + ":" + dat.str("maddable") + ":" + dat.str("needwater") + ":" + dat.str("fallsound") + ":" + fallsoundpitch + ":" + fallsoundvolume + ":" + dat.str("nuclearbomb") + ":" + dat.str("mine") + ":" + dat.str("gender"), 0);
					}
				} else if (parsed[0] == "buildfad") {
					binput@ dat = builder_input("name=name
																			type = type. Thirst to reduce thirst, yesthirst to increase thirst, hunger to reduce hunger, yeshunger to increase hunger, energy to give energy, noenergy to reduce energy, health to give health, nohealth to reduce health, sick to increase sickness, nosick to decrease sickness, dirty to increase being dirty, nodirty to decrease being dirty, wet to increase being wet, nowet to decrease being wet, hot to make the player hot, cold to make the player cold, drunk to make the player drunk and nodrunk to reduce being drunk
																			amount = how much should it increase / decrease ? ");
					if (@dat != null) {
					string soundfile = list_allsounds();
						if (soundfile == "") {
							speak("canceled");
							return;
						}
						allsoundsvp(soundfile);
						send_reliable(peer_id, "createfad " + dat.str("name") + ":" + dat.str("type") + ":" + dat.num("amount") + ":" + allsoundsvolume + ":" + allsoundspitch + ":" + soundfile + ".ogg", 0);
					}
				} else if (parsed[0] == "createdrawsound") {
					binput@ dat = builder_input("itemname=item name");
					if (@dat != null) {
						string soundfile = list_drawsounds();
						if (soundfile == "") {
							speak("canceled");
							return;
						}
						send_reliable(peer_id, "createdrawsounds " + dat.str("itemname") + "=" + soundfile, 0);
					}
				} else if (parsed[0] == "createitemusagelimit") {
					binput@ dat = builder_input("itemname=item name");
					if (@dat != null)
						send_reliable(peer_id, "createitemusagelimit " + dat.str("itemname"), 0);
				} else if (parsed[0] == "buildsign") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						signtext = enter the text");
																							 if (@dat == null) return;
																				string signsound = list_signs();
						if (signsound == "") {
							speak("canceled");
								return;
							}
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addsign sign:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.str("signtext") + ":" + signsound + ".ogg", 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						signtext = enter the text");
																							 if (@dat == null) return;
																				string signsound = list_signs();
						if (signsound == "") {
							speak("canceled");
								return;
							}
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addsign sign:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.str("signtext") + ":" + signsound + ".ogg", 0);
					}
				} else if (parsed[0] == "buildurl") {
					binput@ dat = builder_input("url=enter the url");
					if (@dat != null) send_reliable(peer_id, "addurl url:" + dat.str("url"), 0);
				} else if (parsed[0] == "buildvanishing_platform") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						vanishtime = how much milliseconds should be wated before next vanish");
																							 if (@dat == null) return;
																				string vanishtile = plattypemenu();
						if (vanishtile == "") {
							return;
						}
					string vanishsound = list_ambiences();
					if (vanishsound == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addvanishing_platform vanishing_platform:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("vanishtime") + ":" + vanishtile + ":" + vanishsound + ".ogg", 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						vanishtime = how much milliseconds should be wated before next vanish");
																							 if (@dat == null) return;
																				string vanishtile = plattypemenu();
						if (vanishtile == "") {
							return;
						}
					string vanishsound = list_ambiences();
					if (vanishsound == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addvanishing_platform vanishing_platform:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("vanishtime") + ":" + vanishtile + ":" + vanishsound + ".ogg", 0);
					}
				} else if (parsed[0] == "buildforcefield") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						forcefieldtime = how much milliseconds should be wated before next forcefield appearence
						forcefieldhealth = how much health it should take per each damage");
																							 if (@dat == null) return;
																				string forcefieldsound = list_forcefieldsounds();
						if (forcefieldsound == "") {
							return;
						}
					string forcefieldhitsound = list_forcefieldhitsounds();
					if (forcefieldhitsound == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addforcefield forcefield:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("forcefieldtime") + ":" + dat.num("forcefieldhealth") + ":" + forcefieldsound + ".ogg:" + forcefieldhitsound + ".ogg", 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						forcefieldtime = how much milliseconds should be wated before next forcefield appearence
						forcefieldhealth = how much health it should take per each damage");
																							 if (@dat == null) return;
																				string forcefieldsound = list_forcefieldsounds();
						if (forcefieldsound == "") {
							return;
						}
					string forcefieldhitsound = list_forcefieldhitsounds();
					if (forcefieldhitsound == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addforcefield forcefield:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("forcefieldtime") + ":" + dat.num("forcefieldhealth") + ":" + forcefieldsound + ".ogg:" + forcefieldhitsound + ".ogg", 0);
					}
				} else if (parsed[0] == "buildteleporter") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z");
																							 if (@dat == null) return;
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
							speak("error. Given coordinates are out of range");
								return;
							}
						send_reliable(peer_id, "addteleporter teleporter:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz"), 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y");
																							 if (@dat == null) return;
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
							speak("error. Given coordinates are out of range");
								return;
							}
						send_reliable(peer_id, "addteleporter teleporter:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy"), 0);
					}
				} else if (parsed[0] == "builddoor") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						finishx = enter the destination x
						finishy = enter the destination y
						finishz = enter the destination z
						text = enter the text this door should speak when moving the player
						dtime = enter the speed");
																							 if (@dat == null) return;
																				string ds1 = list_ds1s();
						if (ds1 == "") {
							return;
						}
					string ds2 = list_ds2s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds3s();
					if (ds3 == "") {
						return;
					}
					string ds4 = list_ds4s();
					if (ds4 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z or dat.num("finishx")<min.x or dat.num("finishx")>max.x or dat.num("finishy")<min.y or dat.num("finishy")>max.y or dat.num("finishz")<min.z or dat.num("finishz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "adddoor door:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("finishx") + ":" + dat.num("finishy") + ":" + dat.num("finishz") + ":" + dat.str("text") + ":" + dat.num("dtime") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg:" + ds4 + ".ogg", 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						minz = enter the minimum y
						maxz = enter the maximum y
						finishx = enter the destination x
						finishz = enter the destination y
						text = enter the text this door should speak when moving the player
						dtime = enter the speed");
																							 if (@dat == null) return;
																				string ds1 = list_ds1s();
						if (ds1 == "") {
							return;
						}
					string ds2 = list_ds2s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds3s();
					if (ds3 == "") {
						return;
					}
					string ds4 = list_ds4s();
					if (ds4 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z or dat.num("finishx")<min.x or dat.num("finishx")>max.x or dat.num("finishz")<min.z or dat.num("finishz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "adddoor door:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("finishx") + ":0:" + dat.num("finishz") + ":" + dat.str("text") + ":" + dat.num("dtime") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg:" + ds4 + ".ogg", 0);
					}
				} else if (parsed[0] == "buildpdoor") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						finishx = enter the destination x
						finishy = enter the destination y
						finishz = enter the destination z
						text = enter the text when player press enter on this door to enter the password
						password = enter the password
						dtime = enter the speed");
																							 if (@dat == null) return;
																				string ds1 = list_ds1s();
						if (ds1 == "") {
							return;
						}
					string ds2 = list_ds2s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds3s();
					if (ds3 == "") {
						return;
					}
					string ds4 = list_ds4s();
					if (ds4 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z or dat.num("finishx")<min.x or dat.num("finishx")>max.x or dat.num("finishy")<min.y or dat.num("finishy")>max.y or dat.num("finishz")<min.z or dat.num("finishz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addpdoor pdoor:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("finishx") + ":" + dat.num("finishy") + ":" + dat.num("finishz") + ":" + dat.str("text") + ":" + dat.str("password") + ":" + dat.num("dtime") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg:" + ds4 + ".ogg", 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						minz = enter the minimum y
						maxz = enter the maximum y
						finishx = enter the destination x
						finishz = enter the destination y
						text = enter the text when player press enter on this door to enter the password
						password = enter the password
						dtime = enter the speed");
																							 if (@dat == null) return;
																				string ds1 = list_ds1s();
						if (ds1 == "") {
							return;
						}
					string ds2 = list_ds2s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds3s();
					if (ds3 == "") {
						return;
					}
					string ds4 = list_ds4s();
					if (ds4 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z or dat.num("finishx")<min.x or dat.num("finishx")>max.x or dat.num("finishz")<min.z or dat.num("finishz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addpdoor pdoor:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("finishx") + ":0:" + dat.num("finishz") + ":" + dat.str("text") + ":" + dat.str("password") + ":" + dat.num("dtime") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg:" + ds4 + ".ogg", 0);
					}
				} else if (parsed[0] == "buildicdoor") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						finishx = enter the destination x
						finishy = enter the destination y
						finishz = enter the destination z
						text = enter the text when player press enter on this door for checking the item
						item = item name
						amount = item amount
						dtime = enter the speed");
																							 if (@dat == null) return;
																					string ds1 = list_ds1s();
							if (ds1 == "") {
								return;
							}
					string ds2 = list_ds2s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds3s();
					if (ds3 == "") {
						return;
					}
					string ds4 = list_ds4s();
					if (ds4 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z or dat.num("finishx")<min.x or dat.num("finishx")>max.x or dat.num("finishy")<min.y or dat.num("finishy")>max.y or dat.num("finishz")<min.z or dat.num("finishz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addicdoor icdoor:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("finishx") + ":" + dat.num("finishy") + ":" + dat.num("finishz") + ":" + dat.str("text") + ":" + dat.str("item") + ":" + dat.num("amount") + ":" + dat.num("dtime") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg:" + ds4 + ".ogg", 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						minz = enter the minimum y
						maxz = enter the maximum y
						finishx = enter the destination x
						finishz = enter the destination y
						text = enter the text when player press enter on this door for checking the item
						item = item name
						amount = item amount
						dtime = enter the speed");
																							 if (@dat == null) return;
																					string ds1 = list_ds1s();
							if (ds1 == "") {
								return;
							}
					string ds2 = list_ds2s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds3s();
					if (ds3 == "") {
						return;
					}
					string ds4 = list_ds4s();
					if (ds4 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z or dat.num("finishx")<min.x or dat.num("finishx")>max.x or dat.num("finishz")<min.z or dat.num("finishz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addicdoor icdoor:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("finishx") + ":0:" + dat.num("finishz") + ":" + dat.str("text") + ":" + dat.str("item") + ":" + dat.num("amount") + ":" + dat.num("dtime") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg:" + ds4 + ".ogg", 0);
					}
				} else if (parsed[0] == "builditdoor") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						finishx = enter the destination x
						finishy = enter the destination y
						finishz = enter the destination z
						text = enter the text when player press enter on this door for taking the item
						item = item name
						amount = item amount
						dtime = enter the speed");
																							 if (@dat == null) return;
																					string ds1 = list_ds1s();
							if (ds1 == "") {
								return;
							}
					string ds2 = list_ds2s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds3s();
					if (ds3 == "") {
						return;
					}
					string ds4 = list_ds4s();
					if (ds4 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z or dat.num("finishx")<min.x or dat.num("finishx")>max.x or dat.num("finishy")<min.y or dat.num("finishy")>max.y or dat.num("finishz")<min.z or dat.num("finishz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "additdoor itdoor:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("finishx") + ":" + dat.num("finishy") + ":" + dat.num("finishz") + ":" + dat.str("text") + ":" + dat.str("item") + ":" + dat.num("amount") + ":" + dat.num("dtime") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg:" + ds4 + ".ogg", 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						minz = enter the minimum y
						maxz = enter the maximum y
						finishx = enter the destination x
						finishz = enter the destination y
						text = enter the text when player press enter on this door for taking the item
						item = item name
						amount = item amount
						dtime = enter the speed");
																							 if (@dat == null) return;
																					string ds1 = list_ds1s();
							if (ds1 == "") {
								return;
							}
					string ds2 = list_ds2s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds3s();
					if (ds3 == "") {
						return;
					}
					string ds4 = list_ds4s();
					if (ds4 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z or dat.num("finishx")<min.x or dat.num("finishx")>max.x or dat.num("finishz")<min.z or dat.num("finishz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "additdoor itdoor:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("finishx") + ":0:" + dat.num("finishz") + ":" + dat.str("text") + ":" + dat.str("item") + ":" + dat.num("amount") + ":" + dat.num("dtime") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg:" + ds4 + ".ogg", 0);
					}
				} else if (parsed[0] == "buildigdoor") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						finishx = enter the destination x
						finishy = enter the destination y
						finishz = enter the destination z
						text = enter the text when player press enter on this door for getting the item
						item = item name
						amount = item amount
						dtime = enter the speed");
																							 if (@dat == null) return;
																					string ds1 = list_ds1s();
							if (ds1 == "") {
								return;
							}
					string ds2 = list_ds2s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds3s();
					if (ds3 == "") {
						return;
					}
					string ds4 = list_ds4s();
					if (ds4 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z or dat.num("finishx")<min.x or dat.num("finishx")>max.x or dat.num("finishy")<min.y or dat.num("finishy")>max.y or dat.num("finishz")<min.z or dat.num("finishz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addigdoor igdoor:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("finishx") + ":" + dat.num("finishy") + ":" + dat.num("finishz") + ":" + dat.str("text") + ":" + dat.str("item") + ":" + dat.num("amount") + ":" + dat.num("dtime") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg:" + ds4 + ".ogg", 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						minz = enter the minimum y
						maxz = enter the maximum y
						finishx = enter the destination x
						finishz = enter the destination y
						text = enter the text when player press enter on this door for getting the item
						item = item name
						amount = item amount
						dtime = enter the speed");
																							 if (@dat == null) return;
																					string ds1 = list_ds1s();
							if (ds1 == "") {
								return;
							}
					string ds2 = list_ds2s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds3s();
					if (ds3 == "") {
						return;
					}
					string ds4 = list_ds4s();
					if (ds4 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z or dat.num("finishx")<min.x or dat.num("finishx")>max.x or dat.num("finishz")<min.z or dat.num("finishz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addigdoor igdoor:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("finishx") + ":0:" + dat.num("finishz") + ":" + dat.str("text") + ":" + dat.str("item") + ":" + dat.num("amount") + ":" + dat.num("dtime") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg:" + ds4 + ".ogg", 0);
					}
				} else if (parsed[0] == "buildautomover") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						finishx = enter the destination x
						finishy = enter the destination y
						finishz = enter the destination z
						text = enter the text this automover should speak when moving the player
						dtime = enter the speed");
																							 if (@dat == null) return;
																				string ds1 = list_ds1s();
						if (ds1 == "") {
							return;
						}
					string ds2 = list_ds2s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds3s();
					if (ds3 == "") {
						return;
					}
					string ds4 = list_ds4s();
					if (ds4 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z or dat.num("finishx")<min.x or dat.num("finishx")>max.x or dat.num("finishy")<min.y or dat.num("finishy")>max.y or dat.num("finishz")<min.z or dat.num("finishz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addautomover automover:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("finishx") + ":" + dat.num("finishy") + ":" + dat.num("finishz") + ":" + dat.str("text") + ":" + dat.num("dtime") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg:" + ds4 + ".ogg", 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						finishx = enter the destination x
						finishy = enter the destination y
						text = enter the text this automover should speak when moving the player
						dtime = enter the speed");
																							 if (@dat == null) return;
																				string ds1 = list_ds1s();
						if (ds1 == "") {
							return;
						}
					string ds2 = list_ds2s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds3s();
					if (ds3 == "") {
						return;
					}
					string ds4 = list_ds4s();
					if (ds4 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("finishx")<min.x or dat.num("finishx")>max.x or dat.num("finishy")<min.z or dat.num("finishy")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addautomover automover:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("finishx") + ":0:" + dat.num("finishy") + ":" + dat.str("text") + ":" + dat.num("dtime") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg:" + ds4 + ".ogg", 0);
					}
				} else if (parsed[0] == "buildpautomover") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						finishx = enter the destination x
						finishy = enter the destination y
						finishz = enter the destination z
						text = enter the text when player press enter on this automover to enter the password
						password = enter the password
						dtime = enter the speed");
																							 if (@dat == null) return;
																				string ds1 = list_ds1s();
						if (ds1 == "") {
							return;
						}
					string ds2 = list_ds2s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds3s();
					if (ds3 == "") {
						return;
					}
					string ds4 = list_ds4s();
					if (ds4 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z or dat.num("finishx")<min.x or dat.num("finishx")>max.x or dat.num("finishy")<min.y or dat.num("finishy")>max.y or dat.num("finishz")<min.z or dat.num("finishz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addpautomover pautomover:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("finishx") + ":" + dat.num("finishy") + ":" + dat.num("finishz") + ":" + dat.str("text") + ":" + dat.str("password") + ":" + dat.num("dtime") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg:" + ds4 + ".ogg", 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						finishx = enter the destination x
						finishy = enter the destination y
						text = enter the text when player press enter on this automover to enter the password
						password = enter the password
						dtime = enter the speed");
																							 if (@dat == null) return;
																				string ds1 = list_ds1s();
						if (ds1 == "") {
							return;
						}
					string ds2 = list_ds2s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds3s();
					if (ds3 == "") {
						return;
					}
					string ds4 = list_ds4s();
					if (ds4 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("finishx")<min.x or dat.num("finishx")>max.x or dat.num("finishy")<min.z or dat.num("finishy")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addpautomover pautomover:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("finishx") + ":0:" + dat.num("finishy") + ":" + dat.str("text") + ":" + dat.str("password") + ":" + dat.num("dtime") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg:" + ds4 + ".ogg", 0);
					}
				} else if (parsed[0] == "buildicautomover") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						finishx = enter the destination x
						finishy = enter the destination y
						finishz = enter the destination z
						text = enter the text when player press enter on this automover for checking the item
						item = item name
						amount = item amount
						dtime = enter the speed");
																							 if (@dat == null) return;
																					string ds1 = list_ds1s();
							if (ds1 == "") {
								return;
							}
					string ds2 = list_ds2s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds3s();
					if (ds3 == "") {
						return;
					}
					string ds4 = list_ds4s();
					if (ds4 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z or dat.num("finishx")<min.x or dat.num("finishx")>max.x or dat.num("finishy")<min.y or dat.num("finishy")>max.y or dat.num("finishz")<min.z or dat.num("finishz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addicautomover icautomover:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("finishx") + ":" + dat.num("finishy") + ":" + dat.num("finishz") + ":" + dat.str("text") + ":" + dat.str("item") + ":" + dat.num("amount") + ":" + dat.num("dtime") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg:" + ds4 + ".ogg", 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						finishx = enter the destination x
						finishy = enter the destination y
						text = enter the text when player press enter on this automover for checking the item
						item = item name
						amount = item amount
						dtime = enter the speed");
																							 if (@dat == null) return;
																					string ds1 = list_ds1s();
							if (ds1 == "") {
								return;
							}
					string ds2 = list_ds2s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds3s();
					if (ds3 == "") {
						return;
					}
					string ds4 = list_ds4s();
					if (ds4 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("finishx")<min.x or dat.num("finishx")>max.x or dat.num("finishy")<min.z or dat.num("finishy")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addicautomover icautomover:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("finishx") + ":0:" + dat.num("finishy") + ":" + dat.str("text") + ":" + dat.str("item") + ":" + dat.num("amount") + ":" + dat.num("dtime") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg:" + ds4 + ".ogg", 0);
					}
				} else if (parsed[0] == "builditautomover") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						finishx = enter the destination x
						finishy = enter the destination y
						finishz = enter the destination z
						text = enter the text when player press enter on this automover for taking the item
						item = item name
						amount = item amount
						dtime = enter the speed");
																							 if (@dat == null) return;
																					string ds1 = list_ds1s();
							if (ds1 == "") {
								return;
							}
					string ds2 = list_ds2s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds3s();
					if (ds3 == "") {
						return;
					}
					string ds4 = list_ds4s();
					if (ds4 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z or dat.num("finishx")<min.x or dat.num("finishx")>max.x or dat.num("finishy")<min.y or dat.num("finishy")>max.y or dat.num("finishz")<min.z or dat.num("finishz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "additautomover itautomover:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("finishx") + ":" + dat.num("finishy") + ":" + dat.num("finishz") + ":" + dat.str("text") + ":" + dat.str("item") + ":" + dat.num("amount") + ":" + dat.num("dtime") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg:" + ds4 + ".ogg", 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						finishx = enter the destination x
						finishy = enter the destination y
						text = enter the text when player press enter on this automover for taking the item
						item = item name
						amount = item amount
						dtime = enter the speed");
																							 if (@dat == null) return;
																					string ds1 = list_ds1s();
							if (ds1 == "") {
								return;
							}
					string ds2 = list_ds2s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds3s();
					if (ds3 == "") {
						return;
					}
					string ds4 = list_ds4s();
					if (ds4 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("finishx")<min.x or dat.num("finishx")>max.x or dat.num("finishy")<min.z or dat.num("finishy")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "additautomover itautomover:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("finishx") + ":0:" + dat.num("finishy") + ":" + dat.str("text") + ":" + dat.str("item") + ":" + dat.num("amount") + ":" + dat.num("dtime") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg:" + ds4 + ".ogg", 0);
					}
				} else if (parsed[0] == "buildigautomover") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						finishx = enter the destination x
						finishy = enter the destination y
						finishz = enter the destination z
						text = enter the text when player press enter on this automover for getting the item
						item = item name
						amount = item amount
						dtime = enter the speed");
																							 if (@dat == null) return;
																					string ds1 = list_ds1s();
							if (ds1 == "") {
								return;
							}
					string ds2 = list_ds2s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds3s();
					if (ds3 == "") {
						return;
					}
					string ds4 = list_ds4s();
					if (ds4 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z or dat.num("finishx")<min.x or dat.num("finishx")>max.x or dat.num("finishy")<min.y or dat.num("finishy")>max.y or dat.num("finishz")<min.z or dat.num("finishz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addigautomover igautomover:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("finishx") + ":" + dat.num("finishy") + ":" + dat.num("finishz") + ":" + dat.str("text") + ":" + dat.str("item") + ":" + dat.num("amount") + ":" + dat.num("dtime") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg:" + ds4 + ".ogg", 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						finishx = enter the destination x
						finishy = enter the destination y
						text = enter the text when player press enter on this automover for getting the item
						item = item name
						amount = item amount
						dtime = enter the speed");
																							 if (@dat == null) return;
																					string ds1 = list_ds1s();
							if (ds1 == "") {
								return;
							}
					string ds2 = list_ds2s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds3s();
					if (ds3 == "") {
						return;
					}
					string ds4 = list_ds4s();
					if (ds4 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("finishx")<min.x or dat.num("finishx")>max.x or dat.num("finishy")<min.z or dat.num("finishy")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addigautomover igautomover:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("finishx") + ":0:" + dat.num("finishy") + ":" + dat.str("text") + ":" + dat.str("item") + ":" + dat.num("amount") + ":" + dat.num("dtime") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg:" + ds4 + ".ogg", 0);
					}
				} else if (parsed[0] == "buildtravelpoint") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						map = enter map destination
						finishx = enter the destination x
						finishy = enter the destination y
						finishz = enter the destination z
						text = enter the text this travelpoint should speak when moving the player");
																							 if (@dat == null) return;
																				string ds1 = list_ds1s();
						if (ds1 == "") {
							return;
						}
					string ds2 = list_ds3s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds4s();
					if (ds3 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addtravelpoint travelpoint:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.str("map") + ":" + dat.num("finishx") + ":" + dat.num("finishy") + ":" + dat.num("finishz") + ":" + dat.str("text") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg", 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						map = enter map destination
						finishx = enter the destination x
						finishy = enter the destination y
						text = enter the text this travelpoint should speak when moving the player");
																							 if (@dat == null) return;
																				string ds1 = list_ds1s();
						if (ds1 == "") {
							return;
						}
					string ds2 = list_ds3s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds4s();
					if (ds3 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addtravelpoint travelpoint:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.str("map") + ":" + dat.num("finishx") + ":0:" + dat.num("finishy") + ":" + dat.str("text") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg", 0);
					}
				} else if (parsed[0] == "buildptravelpoint") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						map = enter map destination
						finishx = enter the destination x
						finishy = enter the destination y
						finishz = enter the destination z
						text = enter the text when player press enter on this travelpoint to enter the password
						password = enter the password");
																							 if (@dat == null) return;
																				string ds1 = list_ds1s();
						if (ds1 == "") {
							return;
						}
					string ds2 = list_ds3s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds4s();
					if (ds3 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addptravelpoint ptravelpoint:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.str("map") + ":" + dat.num("finishx") + ":" + dat.num("finishy") + ":" + dat.num("finishz") + ":" + dat.str("text") + ":" + dat.str("password") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg", 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						map = enter map destination
						finishx = enter the destination x
						finishy = enter the destination y
						text = enter the text when player press enter on this travelpoint to enter the password
						password = enter the password");
																							 if (@dat == null) return;
																				string ds1 = list_ds1s();
						if (ds1 == "") {
							return;
						}
					string ds2 = list_ds3s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds4s();
					if (ds3 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addptravelpoint ptravelpoint:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.str("map") + ":" + dat.num("finishx") + ":0:" + dat.num("finishy") + ":" + dat.str("text") + ":" + dat.str("password") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg", 0);
					}
				} else if (parsed[0] == "buildictravelpoint") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						map = enter map destination
						finishx = enter the destination x
						finishy = enter the destination y
						finishz = enter the destination z
						text = enter the text when player press enter on this travelpoint for checking the item
						item = item name
						amount = item amount");
																							 if (@dat == null) return;
																					string ds1 = list_ds1s();
							if (ds1 == "") {
								return;
							}
					string ds2 = list_ds3s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds4s();
					if (ds3 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addictravelpoint ictravelpoint:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.str("map") + ":" + dat.num("finishx") + ":" + dat.num("finishy") + ":" + dat.num("finishz") + ":" + dat.str("text") + ":" + dat.str("item") + ":" + dat.num("amount") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg", 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						map = enter map destination
						finishx = enter the destination x
						finishy = enter the destination y
						text = enter the text when player press enter on this travelpoint for checking the item
						item = item name
						amount = item amount");
																							 if (@dat == null) return;
																					string ds1 = list_ds1s();
							if (ds1 == "") {
								return;
							}
					string ds2 = list_ds3s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds4s();
					if (ds3 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addictravelpoint ictravelpoint:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.str("map") + ":" + dat.num("finishx") + ":0:" + dat.num("finishy") + ":" + dat.str("text") + ":" + dat.str("item") + ":" + dat.num("amount") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg", 0);
					}
				} else if (parsed[0] == "buildittravelpoint") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						map = enter map destination
						finishx = enter the destination x
						finishy = enter the destination y
						finishz = enter the destination z
						text = enter the text when player press enter on this travelpoint for taking the item
						item = item name
						amount = item amount");
																							 if (@dat == null) return;
																					string ds1 = list_ds1s();
							if (ds1 == "") {
								return;
							}
					string ds2 = list_ds3s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds4s();
					if (ds3 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addittravelpoint ittravelpoint:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.str("map") + ":" + dat.num("finishx") + ":" + dat.num("finishy") + ":" + dat.num("finishz") + ":" + dat.str("text") + ":" + dat.str("item") + ":" + dat.num("amount") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg", 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						map = enter map destination
						finishx = enter the destination x
						finishy = enter the destination y
						text = enter the text when player press enter on this travelpoint for taking the item
						item = item name
						amount = item amount");
																							 if (@dat == null) return;
																					string ds1 = list_ds1s();
							if (ds1 == "") {
								return;
							}
					string ds2 = list_ds3s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds4s();
					if (ds3 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addittravelpoint ittravelpoint:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.str("map") + ":" + dat.num("finishx") + ":0:" + dat.num("finishy") + ":" + dat.str("text") + ":" + dat.str("item") + ":" + dat.num("amount") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg", 0);
					}
				} else if (parsed[0] == "buildigtravelpoint") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						map = enter map destination
						finishx = enter the destination x
						finishy = enter the destination y
						finishz = enter the destination z
						text = enter the text when player press enter on this travelpoint for getting the item
						item = item name
						amount = item amount");
																							 if (@dat == null) return;
																					string ds1 = list_ds1s();
							if (ds1 == "") {
								return;
							}
					string ds2 = list_ds3s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds4s();
					if (ds3 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addigtravelpoint igtravelpoint:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.str("map") + ":" + dat.num("finishx") + ":" + dat.num("finishy") + ":" + dat.num("finishz") + ":" + dat.str("text") + ":" + dat.str("item") + ":" + dat.num("amount") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg", 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						map = enter map destination
						finishx = enter the destination x
						finishy = enter the destination y
						text = enter the text when player press enter on this travelpoint for getting the item
						item = item name
						amount = item amount");
																							 if (@dat == null) return;
																					string ds1 = list_ds1s();
							if (ds1 == "") {
								return;
							}
					string ds2 = list_ds3s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds4s();
					if (ds3 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addigtravelpoint igtravelpoint:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.str("map") + ":" + dat.num("finishx") + ":0:" + dat.num("finishy") + ":" + dat.str("text") + ":" + dat.str("item") + ":" + dat.num("amount") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg", 0);
					}
				} else if (parsed[0] == "buildautomatic_travelpoint") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						map = enter map destination
						finishx = enter the destination x
						finishy = enter the destination y
						finishz = enter the destination z
						text = enter the text this automatic_travelpoint should speak when moving the player");
																							 if (@dat == null) return;
																				string ds1 = list_ds1s();
						if (ds1 == "") {
							return;
						}
					string ds2 = list_ds3s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds4s();
					if (ds3 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addautomatic_travelpoint automatic_travelpoint:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.str("map") + ":" + dat.num("finishx") + ":" + dat.num("finishy") + ":" + dat.num("finishz") + ":" + dat.str("text") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg", 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						map = enter map destination
						finishx = enter the destination x
						finishy = enter the destination y
						text = enter the text this automatic_travelpoint should speak when moving the player");
																							 if (@dat == null) return;
																				string ds1 = list_ds1s();
						if (ds1 == "") {
							return;
						}
					string ds2 = list_ds3s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds4s();
					if (ds3 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addautomatic_travelpoint automatic_travelpoint:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.str("map") + ":" + dat.num("finishx") + ":0:" + dat.num("finishy") + ":" + dat.str("text") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg", 0);
					}
				} else if (parsed[0] == "buildpautomatic_travelpoint") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						map = enter map destination
						finishx = enter the destination x
						finishy = enter the destination y
						finishz = enter the destination z
						text = enter the text when player press enter on this automatic_travelpoint to enter the password
						password = enter the password");
																							 if (@dat == null) return;
																				string ds1 = list_ds1s();
						if (ds1 == "") {
							return;
						}
					string ds2 = list_ds3s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds4s();
					if (ds3 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addpautomatic_travelpoint pautomatic_travelpoint:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.str("map") + ":" + dat.num("finishx") + ":" + dat.num("finishy") + ":" + dat.num("finishz") + ":" + dat.str("text") + ":" + dat.str("password") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg", 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						map = enter map destination
						finishx = enter the destination x
						finishy = enter the destination y
						text = enter the text when player press enter on this automatic_travelpoint to enter the password
						password = enter the password");
																							 if (@dat == null) return;
																				string ds1 = list_ds1s();
						if (ds1 == "") {
							return;
						}
					string ds2 = list_ds3s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds4s();
					if (ds3 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addpautomatic_travelpoint pautomatic_travelpoint:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.str("map") + ":" + dat.num("finishx") + ":0:" + dat.num("finishy") + ":" + dat.str("text") + ":" + dat.str("password") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg", 0);
					}
				} else if (parsed[0] == "buildicautomatic_travelpoint") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						map = enter map destination
						finishx = enter the destination x
						finishy = enter the destination y
						finishz = enter the destination z
						text = enter the text when player press enter on this automatic_travelpoint for checking the item
						item = item name
						amount = item amount");
																							 if (@dat == null) return;
																					string ds1 = list_ds1s();
							if (ds1 == "") {
								return;
							}
					string ds2 = list_ds3s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds4s();
					if (ds3 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addicautomatic_travelpoint icautomatic_travelpoint:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.str("map") + ":" + dat.num("finishx") + ":" + dat.num("finishy") + ":" + dat.num("finishz") + ":" + dat.str("text") + ":" + dat.str("item") + ":" + dat.num("amount") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg", 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						map = enter map destination
						finishx = enter the destination x
						finishy = enter the destination y
						text = enter the text when player press enter on this automatic_travelpoint for checking the item
						item = item name
						amount = item amount");
																							 if (@dat == null) return;
																					string ds1 = list_ds1s();
							if (ds1 == "") {
								return;
							}
					string ds2 = list_ds3s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds4s();
					if (ds3 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addicautomatic_travelpoint icautomatic_travelpoint:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.str("map") + ":" + dat.num("finishx") + ":0:" + dat.num("finishy") + ":" + dat.str("text") + ":" + dat.str("item") + ":" + dat.num("amount") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg", 0);
					}
				} else if (parsed[0] == "builditautomatic_travelpoint") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						map = enter map destination
						finishx = enter the destination x
						finishy = enter the destination y
						finishz = enter the destination z
						text = enter the text when player press enter on this automatic_travelpoint for taking the item
						item = item name
						amount = item amount");
																							 if (@dat == null) return;
																					string ds1 = list_ds1s();
							if (ds1 == "") {
								return;
							}
					string ds2 = list_ds3s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds4s();
					if (ds3 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "additautomatic_travelpoint itautomatic_travelpoint:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.str("map") + ":" + dat.num("finishx") + ":" + dat.num("finishy") + ":" + dat.num("finishz") + ":" + dat.str("text") + ":" + dat.str("item") + ":" + dat.num("amount") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg", 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						map = enter map destination
						finishx = enter the destination x
						finishy = enter the destination y
						text = enter the text when player press enter on this automatic_travelpoint for taking the item
						item = item name
						amount = item amount");
																							 if (@dat == null) return;
																					string ds1 = list_ds1s();
							if (ds1 == "") {
								return;
							}
					string ds2 = list_ds3s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds4s();
					if (ds3 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "additautomatic_travelpoint itautomatic_travelpoint:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.str("map") + ":" + dat.num("finishx") + ":0:" + dat.num("finishy") + ":" + dat.str("text") + ":" + dat.str("item") + ":" + dat.num("amount") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg", 0);
					}
				} else if (parsed[0] == "buildigautomatic_travelpoint") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						map = enter map destination
						finishx = enter the destination x
						finishy = enter the destination y
						finishz = enter the destination z
						text = enter the text when player press enter on this automatic_travelpoint for getting the item
						item = item name
						amount = item amount");
																							 if (@dat == null) return;
																					string ds1 = list_ds1s();
							if (ds1 == "") {
								return;
							}
					string ds2 = list_ds3s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds4s();
					if (ds3 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addigautomatic_travelpoint igautomatic_travelpoint:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.str("map") + ":" + dat.num("finishx") + ":" + dat.num("finishy") + ":" + dat.num("finishz") + ":" + dat.str("text") + ":" + dat.str("item") + ":" + dat.num("amount") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg", 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						map = enter map destination
						finishx = enter the destination x
						finishy = enter the destination y
						text = enter the text when player press enter on this automatic_travelpoint for getting the item
						item = item name
						amount = item amount");
																							 if (@dat == null) return;
																					string ds1 = list_ds1s();
							if (ds1 == "") {
								return;
							}
					string ds2 = list_ds3s();
					if (ds2 == "") {
						return;
					}
					string ds3 = list_ds4s();
					if (ds3 == "") {
						return;
					}
					if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
						speak("error. Given coordinates are out of range");
							return;
						}
						send_reliable(peer_id, "addigautomatic_travelpoint igautomatic_travelpoint:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.str("map") + ":" + dat.num("finishx") + ":0:" + dat.num("finishy") + ":" + dat.str("text") + ":" + dat.str("item") + ":" + dat.num("amount") + ":" + ds1 + ".ogg:" + ds2 + ".ogg:" + ds3 + ".ogg", 0);
					}
				} else if (parsed[0] == "buildsrc") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z");
																							 if (@dat == null) return;
																				string soundfile = list_ambiences();
						if (soundfile == "") {
							speak("canceled");
								return;
							}
						srcv(soundfile);
						string temp = "";
													int amb = yesno("would you like this source to work as an ambience?");
													if (amb == 1) temp = ":1";
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
							speak("error. Given coordinates are out of range");
								return;
							}
						send_reliable(peer_id, "addsrc src:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + volume + ":" + pitch + ":" + soundfile + ".ogg" + temp, 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y");
																							 if (@dat == null) return;
																				string soundfile = list_ambiences();
						if (soundfile == "") {
							speak("canceled");
								return;
							}
						srcv(soundfile);
						string temp = "";
													int amb = yesno("would you like this source to work as an ambience?");
													if (amb == 1) temp = ":1";
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
							speak("error. Given coordinates are out of range");
								return;
							}
						send_reliable(peer_id, "addsrc src:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + volume + ":" + pitch + ":" + soundfile + ".ogg" + temp, 0);
					}
				} else if (parsed[0] == "buildmusic") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z");
																							 if (@dat == null) return;
																				string soundfile = list_musics();
						if (soundfile == "") {
							speak("canceled");
								return;
							}
						srcv(soundfile);
						string temp = "";
													int amb = yesno("would you like this music to work as an ambience?");
													if (amb == 1) temp = ":1";
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
							speak("error. Given coordinates are out of range");
								return;
							}
						send_reliable(peer_id, "addmusic music:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + volume + ":" + pitch + ":" + soundfile + ".ogg" + temp, 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y");
																							 if (@dat == null) return;
																				string soundfile = list_musics();
						if (soundfile == "") {
							speak("canceled");
								return;
							}
						srcv(soundfile);
						string temp = "";
													int amb = yesno("would you like this music to work as an ambience?");
													if (amb == 1) temp = ":1";
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
							speak("error. Given coordinates are out of range");
								return;
							}
						send_reliable(peer_id, "addmusic music:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + volume + ":" + pitch + ":" + soundfile + ".ogg" + temp, 0);
					}
				} else if (parsed[0] == "buildtile") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z");
																							 if (@dat == null) return;
																				string platform = plattypemenu();
																				if (platform == "")
																					return;
																					string temp = "";
																					int trackable = yesno("would you like this tile to be trackable via the tile tracker  menu?");
																					if (trackable == 1) temp = ":trackme";
								if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
									speak("error. Given coordinates are out of range");
										return;
									}
						send_reliable(peer_id, "addtile tile:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + platform + temp, 0);
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y");
																							 if (@dat == null) return;
																				string platform = plattypemenu();
																				if (platform == "")
																					return;
																					string temp = "";
																					int trackable = yesno("would you like this tile to be trackable via the tile tracker  menu?");
																					if (trackable == 1) temp = ":trackme";
								if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
									speak("error. Given coordinates are out of range");
										return;
									}
						send_reliable(peer_id, "addtile tile:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + platform + temp, 0);
					}
				} else if (parsed[0] == "buildecoordinates")
					send_reliable(peer_id, "addecoordinates enable:" + "coordinates", 0);
				else if (parsed[0] == "buildecamera")
					send_reliable(peer_id, "addecamera enable:" + "camera", 0);
				else if (parsed[0] == "buildecamerawall")
					send_reliable(peer_id, "addecamerawall enable:" + "camerawall", 0);
				else if (parsed[0] == "buildemfwc")
					send_reliable(peer_id, "addemfwc enable:" + "mfwc", 0);
				else if (parsed[0] == "buildejump")
					send_reliable(peer_id, "addejump enable:" + "jump", 0);
				else if (parsed[0] == "buildespy")
					send_reliable(peer_id, "addespy enable:" + "spy", 0);
				else if (parsed[0] == "builddcoordinates")
					send_reliable(peer_id, "adddcoordinates disable:" + "coordinates", 0);
				else if (parsed[0] == "builddcamera")
					send_reliable(peer_id, "adddcamera disable:" + "camera", 0);
				else if (parsed[0] == "builddcamerawall")
					send_reliable(peer_id, "adddcamerawall disable:" + "camerawall", 0);
				else if (parsed[0] == "builddmfwc")
					send_reliable(peer_id, "adddmfwc disable:" + "mfwc", 0);
				else if (parsed[0] == "builddjump")
					send_reliable(peer_id, "adddjump disable:" + "jump", 0);
				else if (parsed[0] == "builddspy")
					send_reliable(peer_id, "adddspy disable:" + "spy", 0);
				else if (parsed[0] == "buildelocalchat")
					send_reliable(peer_id, "addelocalchat enable:" + "localchat", 0);
				else if (parsed[0] == "builddlocalchat")
					send_reliable(peer_id, "adddlocalchat disable:" + "localchat", 0);
				else if (parsed[0] == "buildevoicechat")
					send_reliable(peer_id, "addevoicechat enable:" + "voicechat", 0);
				else if (parsed[0] == "builddvoicechat")
					send_reliable(peer_id, "adddvoicechat disable:" + "voicechat", 0);
				else if (parsed[0] == "buildettschat")
					send_reliable(peer_id, "addettschat enable:" + "ttschat", 0);
				else if (parsed[0] == "builddttschat")
					send_reliable(peer_id, "adddttschat disable:" + "ttschat", 0);
				else if (parsed[0] == "builde2dsupport")
					send_reliable(peer_id, "adde2dsupport enable:" + "2dsupport", 0);
				else if (parsed[0] == "buildd2dsupport")
					send_reliable(peer_id, "addd2dsupport disable:" + "fridge", 0);
				else if (parsed[0] == "buildetracking")
					send_reliable(peer_id, "addetracking enable:" + "tracking", 0);
				else if (parsed[0] == "builddtracking")
					send_reliable(peer_id, "adddtracking disable:" + "tracking", 0);
				else if (parsed[0] == "buildedisasters")
					send_reliable(peer_id, "addedisasters enable:" + "disasters", 0);
				else if (parsed[0] == "buildddisasters")
					send_reliable(peer_id, "addddisasters", 0);
				else if (parsed[0] == "buildecameraplayer")
					send_reliable(peer_id, "addecameraplayer enable:" + "cameraplayer", 0);
				else if (parsed[0] == "builddcameraplayer")
					send_reliable(peer_id, "adddcameraplayer disable:" + "cameraplayer", 0);
				else if (parsed[0] == "buildecameraitem")
					send_reliable(peer_id, "addecameraitem enable:" + "cameraitem", 0);
				else if (parsed[0] == "builddcameraitem")
					send_reliable(peer_id, "adddcameraitem disable:" + "cameraitem", 0);
				else if (parsed[0] == "buildecameradoor")
					send_reliable(peer_id, "addecameradoor enable:" + "cameradoor", 0);
				else if (parsed[0] == "builddcameradoor")
					send_reliable(peer_id, "adddcameradoor disable:" + "cameradoor", 0);
				else if (parsed[0] == "buildecamerapdoor")
					send_reliable(peer_id, "addecamerapdoor enable:" + "camerapdoor", 0);
				else if (parsed[0] == "builddcamerapdoor")
					send_reliable(peer_id, "adddcamerapdoor disable:" + "camerapdoor", 0);
				else if (parsed[0] == "buildecameraicdoor")
					send_reliable(peer_id, "addecameraicdoor enable:" + "cameraicdoor", 0);
				else if (parsed[0] == "builddcameraicdoor")
					send_reliable(peer_id, "adddcameraicdoor disable:" + "cameraicdoor", 0);
				else if (parsed[0] == "buildecameraitdoor")
					send_reliable(peer_id, "addecameraitdoor enable:" + "cameraitdoor", 0);
				else if (parsed[0] == "builddcameraitdoor")
					send_reliable(peer_id, "adddcameraitdoor disable:" + "cameraitdoor", 0);
				else if (parsed[0] == "buildecameraigdoor")
					send_reliable(peer_id, "addecameraigdoor enable:" + "cameraigdoor", 0);
				else if (parsed[0] == "builddcameraigdoor")
					send_reliable(peer_id, "adddcameraigdoor disable:" + "cameraigdoor", 0);
				else if (parsed[0] == "buildecameraautomover")
					send_reliable(peer_id, "addecameraautomover enable:" + "cameraautomover", 0);
				else if (parsed[0] == "builddcameraautomover")
					send_reliable(peer_id, "adddcameraautomover disable:" + "cameraautomover", 0);
				else if (parsed[0] == "buildecamerapautomover")
					send_reliable(peer_id, "addecamerapautomover enable:" + "camerapautomover", 0);
				else if (parsed[0] == "builddcamerapautomover")
					send_reliable(peer_id, "adddcamerapautomover disable:" + "camerapautomover", 0);
				else if (parsed[0] == "buildecameraicautomover")
					send_reliable(peer_id, "addecameraicautomover enable:" + "cameraicautomover", 0);
				else if (parsed[0] == "builddcameraicautomover")
					send_reliable(peer_id, "adddcameraicautomover disable:" + "cameraicautomover", 0);
				else if (parsed[0] == "buildecameraitautomover")
					send_reliable(peer_id, "addecameraitautomover enable:" + "cameraitautomover", 0);
				else if (parsed[0] == "builddcameraitautomover")
					send_reliable(peer_id, "adddcameraitautomover disable:" + "cameraitautomover", 0);
				else if (parsed[0] == "buildecameraigautomover")
					send_reliable(peer_id, "addecameraigautomover enable:" + "cameraigautomover", 0);
				else if (parsed[0] == "builddcameraigautomover")
					send_reliable(peer_id, "adddcameraigautomover disable:" + "cameraigautomover", 0);
				else if (parsed[0] == "buildecameraautomatic_travelpoint")
					send_reliable(peer_id, "addecameraautomatic_travelpoint enable:" + "cameraautomatic_travelpoint", 0);
				else if (parsed[0] == "builddcameraautomatic_travelpoint")
					send_reliable(peer_id, "adddcameraautomatic_travelpoint disable:" + "cameraautomatic_travelpoint", 0);
				else if (parsed[0] == "buildecamerapautomatic_travelpoint")
					send_reliable(peer_id, "addecamerapautomatic_travelpoint enable:" + "camerapautomatic_travelpoint", 0);
				else if (parsed[0] == "builddcamerapautomatic_travelpoint")
					send_reliable(peer_id, "adddcamerapautomatic_travelpoint disable:" + "camerapautomatic_travelpoint", 0);
				else if (parsed[0] == "buildecameraicautomatic_travelpoint")
					send_reliable(peer_id, "addecameraicautomatic_travelpoint enable:" + "cameraicautomatic_travelpoint", 0);
				else if (parsed[0] == "builddcameraicautomatic_travelpoint")
					send_reliable(peer_id, "adddcameraicautomatic_travelpoint disable:" + "cameraicautomatic_travelpoint", 0);
				else if (parsed[0] == "buildecameraitautomatic_travelpoint")
					send_reliable(peer_id, "addecameraitautomatic_travelpoint enable:" + "cameraitautomatic_travelpoint", 0);
				else if (parsed[0] == "builddcameraitautomatic_travelpoint")
					send_reliable(peer_id, "adddcameraitautomatic_travelpoint disable:" + "cameraitautomatic_travelpoint", 0);
				else if (parsed[0] == "buildecameraigautomatic_travelpoint")
					send_reliable(peer_id, "addecameraigautomatic_travelpoint enable:" + "cameraigautomatic_travelpoint", 0);
				else if (parsed[0] == "builddcameraigautomatic_travelpoint")
					send_reliable(peer_id, "adddcameraigautomatic_travelpoint disable:" + "cameraigautomatic_travelpoint", 0);
				else if (parsed[0] == "buildecameratravelpoint")
					send_reliable(peer_id, "addecameratravelpoint enable:" + "cameratravelpoint", 0);
				else if (parsed[0] == "builddcameratravelpoint")
					send_reliable(peer_id, "adddcameratravelpoint disable:" + "cameratravelpoint", 0);
				else if (parsed[0] == "buildecameraptravelpoint")
					send_reliable(peer_id, "addecameraptravelpoint enable:" + "cameraptravelpoint", 0);
				else if (parsed[0] == "builddcameraptravelpoint")
					send_reliable(peer_id, "adddcameraptravelpoint disable:" + "cameraptravelpoint", 0);
				else if (parsed[0] == "buildecameraictravelpoint")
					send_reliable(peer_id, "addecameraictravelpoint enable:" + "cameraictravelpoint", 0);
				else if (parsed[0] == "builddcameraictravelpoint")
					send_reliable(peer_id, "adddcameraictravelpoint disable:" + "cameraictravelpoint", 0);
				else if (parsed[0] == "buildecameraittravelpoint")
					send_reliable(peer_id, "addecameraittravelpoint enable:" + "cameraittravelpoint", 0);
				else if (parsed[0] == "builddcameraittravelpoint")
					send_reliable(peer_id, "adddcameraittravelpoint disable:" + "cameraittravelpoint", 0);
				else if (parsed[0] == "buildecameraigtravelpoint")
					send_reliable(peer_id, "addecameraigtravelpoint enable:" + "cameraigtravelpoint", 0);
				else if (parsed[0] == "builddcameraigtravelpoint")
					send_reliable(peer_id, "adddcameraigtravelpoint disable:" + "cameraigtravelpoint", 0);
				else if (parsed[0] == "buildecameravp")
					send_reliable(peer_id, "addecameravp enable:" + "cameravp", 0);
				else if (parsed[0] == "buildecameraff")
					send_reliable(peer_id, "addecameraff enable:" + "cameraff", 0);
				else if (parsed[0] == "buildecamerah")
					send_reliable(peer_id, "addecamerah enable:" + "camerah", 0);
				else if (parsed[0] == "buildecameratp")
					send_reliable(peer_id, "addecameratp enable:" + "cameratp", 0);
				else if (parsed[0] == "builddcameravp")
					send_reliable(peer_id, "adddcameravp disable:" + "cameravp", 0);
				else if (parsed[0] == "builddcameraff")
					send_reliable(peer_id, "adddcameraff disable:" + "cameraff", 0);
				else if (parsed[0] == "builddcamerah")
					send_reliable(peer_id, "adddcamerah disable:" + "camerah", 0);
				else if (parsed[0] == "builddcameratp")
					send_reliable(peer_id, "adddcameratp disable:" + "cameratp", 0);
				else if (parsed[0] == "buildecamerasign")
					send_reliable(peer_id, "addecamerasign enable:" + "camerasign", 0);
				else if (parsed[0] == "builddcamerasign")
					send_reliable(peer_id, "adddcamerasign disable:" + "camerasign", 0);
				else if (parsed[0] == "buildecameratxt")
					send_reliable(peer_id, "addecameratxt enable:" + "cameratxt", 0);
				else if (parsed[0] == "builddcameratxt")
					send_reliable(peer_id, "adddcameratxt disable:" + "cameratxt", 0);
				else if (parsed[0] == "buildespyplayer")
					send_reliable(peer_id, "addespyplayer enable:" + "spyplayer", 0);
				else if (parsed[0] == "builddspyplayer")
					send_reliable(peer_id, "adddspyplayer disable:" + "spyplayer", 0);
				else if (parsed[0] == "buildespyitem")
					send_reliable(peer_id, "addespyitem enable:" + "spyitem", 0);
				else if (parsed[0] == "builddspyitem")
					send_reliable(peer_id, "adddspyitem disable:" + "spyitem", 0);
				else if (parsed[0] == "buildespydoor")
					send_reliable(peer_id, "addespydoor enable:" + "spydoor", 0);
				else if (parsed[0] == "builddspydoor")
					send_reliable(peer_id, "adddspydoor disable:" + "spydoor", 0);
				else if (parsed[0] == "buildespypdoor")
					send_reliable(peer_id, "addespypdoor enable:" + "spypdoor", 0);
				else if (parsed[0] == "builddspypdoor")
					send_reliable(peer_id, "adddspypdoor disable:" + "spypdoor", 0);
				else if (parsed[0] == "buildespyicdoor")
					send_reliable(peer_id, "addespyicdoor enable:" + "spyicdoor", 0);
				else if (parsed[0] == "builddspyicdoor")
					send_reliable(peer_id, "adddspyicdoor disable:" + "spyicdoor", 0);
				else if (parsed[0] == "buildespyitdoor")
					send_reliable(peer_id, "addespyitdoor enable:" + "spyitdoor", 0);
				else if (parsed[0] == "builddspyitdoor")
					send_reliable(peer_id, "adddspyitdoor disable:" + "spyitdoor", 0);
				else if (parsed[0] == "buildespyigdoor")
					send_reliable(peer_id, "addespyigdoor enable:" + "spyigdoor", 0);
				else if (parsed[0] == "builddspyigdoor")
					send_reliable(peer_id, "adddspyigdoor disable:" + "spyigdoor", 0);
				else if (parsed[0] == "buildespyautomover")
					send_reliable(peer_id, "addespyautomover enable:" + "spyautomover", 0);
				else if (parsed[0] == "builddspyautomover")
					send_reliable(peer_id, "adddspyautomover disable:" + "spyautomover", 0);
				else if (parsed[0] == "buildespypautomover")
					send_reliable(peer_id, "addespypautomover enable:" + "spypautomover", 0);
				else if (parsed[0] == "builddspypautomover")
					send_reliable(peer_id, "adddspypautomover disable:" + "spypautomover", 0);
				else if (parsed[0] == "buildespyicautomover")
					send_reliable(peer_id, "addespyicautomover enable:" + "spyicautomover", 0);
				else if (parsed[0] == "builddspyicautomover")
					send_reliable(peer_id, "adddspyicautomover disable:" + "spyicautomover", 0);
				else if (parsed[0] == "buildespyitautomover")
					send_reliable(peer_id, "addespyitautomover enable:" + "spyitautomover", 0);
				else if (parsed[0] == "builddspyitautomover")
					send_reliable(peer_id, "adddspyitautomover disable:" + "spyitautomover", 0);
				else if (parsed[0] == "buildespyigautomover")
					send_reliable(peer_id, "addespyigautomover enable:" + "spyigautomover", 0);
				else if (parsed[0] == "builddspyigautomover")
					send_reliable(peer_id, "adddspyigautomover disable:" + "spyigautomover", 0);
				else if (parsed[0] == "buildespyautomatic_travelpoint")
					send_reliable(peer_id, "addespyautomatic_travelpoint enable:" + "spyautomatic_travelpoint", 0);
				else if (parsed[0] == "builddspyautomatic_travelpoint")
					send_reliable(peer_id, "adddspyautomatic_travelpoint disable:" + "spyautomatic_travelpoint", 0);
				else if (parsed[0] == "buildespypautomatic_travelpoint")
					send_reliable(peer_id, "addespypautomatic_travelpoint enable:" + "spypautomatic_travelpoint", 0);
				else if (parsed[0] == "builddspypautomatic_travelpoint")
					send_reliable(peer_id, "adddspypautomatic_travelpoint disable:" + "spypautomatic_travelpoint", 0);
				else if (parsed[0] == "buildespyicautomatic_travelpoint")
					send_reliable(peer_id, "addespyicautomatic_travelpoint enable:" + "spyicautomatic_travelpoint", 0);
				else if (parsed[0] == "builddspyicautomatic_travelpoint")
					send_reliable(peer_id, "adddspyicautomatic_travelpoint disable:" + "spyicautomatic_travelpoint", 0);
				else if (parsed[0] == "buildespyitautomatic_travelpoint")
					send_reliable(peer_id, "addespyitautomatic_travelpoint enable:" + "spyitautomatic_travelpoint", 0);
				else if (parsed[0] == "builddspyitautomatic_travelpoint")
					send_reliable(peer_id, "adddspyitautomatic_travelpoint disable:" + "spyitautomatic_travelpoint", 0);
				else if (parsed[0] == "buildespyigautomatic_travelpoint")
					send_reliable(peer_id, "addespyigautomatic_travelpoint enable:" + "spyigautomatic_travelpoint", 0);
				else if (parsed[0] == "builddspyigautomatic_travelpoint")
					send_reliable(peer_id, "adddspyigautomatic_travelpoint disable:" + "spyigautomatic_travelpoint", 0);
				else if (parsed[0] == "buildespytravelpoint")
					send_reliable(peer_id, "addespytravelpoint enable:" + "spytravelpoint", 0);
				else if (parsed[0] == "builddspytravelpoint")
					send_reliable(peer_id, "adddspytravelpoint disable:" + "spytravelpoint", 0);
				else if (parsed[0] == "buildespyptravelpoint")
					send_reliable(peer_id, "addespyptravelpoint enable:" + "spyptravelpoint", 0);
				else if (parsed[0] == "builddspyptravelpoint")
					send_reliable(peer_id, "adddspyptravelpoint disable:" + "spyptravelpoint", 0);
				else if (parsed[0] == "buildespyictravelpoint")
					send_reliable(peer_id, "addespyictravelpoint enable:" + "spyictravelpoint", 0);
				else if (parsed[0] == "builddspyictravelpoint")
					send_reliable(peer_id, "adddspyictravelpoint disable:" + "spyictravelpoint", 0);
				else if (parsed[0] == "buildespyittravelpoint")
					send_reliable(peer_id, "addespyittravelpoint enable:" + "spyittravelpoint", 0);
				else if (parsed[0] == "builddspyittravelpoint")
					send_reliable(peer_id, "adddspyittravelpoint disable:" + "spyittravelpoint", 0);
				else if (parsed[0] == "buildespyigtravelpoint")
					send_reliable(peer_id, "addespyigtravelpoint enable:" + "spyigtravelpoint", 0);
				else if (parsed[0] == "builddspyigtravelpoint")
					send_reliable(peer_id, "adddspyigtravelpoint disable:" + "spyigtravelpoint", 0);
				else if (parsed[0] == "buildespyvp")
					send_reliable(peer_id, "addespyvp enable:" + "spyvp", 0);
				else if (parsed[0] == "buildespyff")
					send_reliable(peer_id, "addespyff enable:" + "spyff", 0);
				else if (parsed[0] == "buildespyh")
					send_reliable(peer_id, "addespyh enable:" + "spyh", 0);
				else if (parsed[0] == "buildespytp")
					send_reliable(peer_id, "addespytp enable:" + "spytp", 0);
				else if (parsed[0] == "builddspyvp")
					send_reliable(peer_id, "adddspyvp disable:" + "spyvp", 0);
				else if (parsed[0] == "builddspyff")
					send_reliable(peer_id, "adddspyff disable:" + "spyff", 0);
				else if (parsed[0] == "builddspyh")
					send_reliable(peer_id, "adddspyh disable:" + "spyh", 0);
				else if (parsed[0] == "builddspytp")
					send_reliable(peer_id, "adddspytp disable:" + "spytp", 0);
				else if (parsed[0] == "buildespysign")
					send_reliable(peer_id, "addespysign enable:" + "spysign", 0);
				else if (parsed[0] == "builddspysign")
					send_reliable(peer_id, "adddspysign disable:" + "spysign", 0);
				else if (parsed[0] == "buildespytxt")
					send_reliable(peer_id, "addespytxt enable:" + "spytxt", 0);
				else if (parsed[0] == "builddspytxt")
					send_reliable(peer_id, "adddspytxt disable:" + "spytxt", 0);
				else if (parsed[0] == "builddrain") {
					string soundfile = list_nrainsounds();
					if (soundfile == "") {
						speak("canceled");
						return;
					}
					send_reliable(peer_id, "adddrain rain:" + soundfile + ".ogg", 0);
				} else if (parsed[0] == "builddwind") {
					string soundfile = list_nonesounds();
					if (soundfile == "") {
						speak("canceled");
						return;
					}
					send_reliable(peer_id, "adddwind wind:" + soundfile + ".ogg", 0);
				} else if (parsed[0] == "builddnight") {
					string soundfile = list_nonesounds();
					if (soundfile == "") {
						speak("canceled");
						return;
					}
					send_reliable(peer_id, "adddnight night:" + soundfile + ".ogg", 0);
				} else if (parsed[0] == "buildgmd")
					send_reliable(peer_id, "/rawmap", 1);
				else if (parsed[0] == "buildspecified_air_temperature") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						text = enter the specified air temperature");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addspecified_air_temperature specified_air_temperature:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("text"), 0);
						}
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						text = enter the specified air temperature");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addspecified_air_temperature specified_air_temperature:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("text"), 0);
						}
					}
				} else if (parsed[0] == "buildpmd") {
					string t = input("Data", "Paste the data", "", "", 0, false, true);
					if (t != "") send_reliable(peer_id, "/rawdata " + t, 1);
				} else if (parsed[0] == "buildowner") {
					binput@ dat = builder_input("text=enter owner name");
					if (@dat == null) return;
					send_reliable(peer_id, "addowner owner:" + dat.str("text"), 0);
				} else if (parsed[0] == "buildaddline") {
					binput@ dat = builder_input("text=enter line");
					if (@dat == null) return;
					send_reliable(peer_id, "addline " + dat.str("text"), 0);
				} else if (parsed[0] == "buildeditline" and parsed.length() >= 1) {
					string s = input("Edit", "When done, press enter", string_replace(get_event_message(), parsed[0] + " ", "", true));
					if (s != "" and !is_eloquence_crash_word(s) and get_sequence(s, true) <= 3)
						send_reliable(peer_id, "addeditline " + s, 0);
				} else if (parsed[0] == "buildremoveline" and parsed.length() > 1) {
					string r = string_trimleft(get_event_message(), (parsed[0] + " ").length());
					send_reliable(peer_id, "addremoveline " + r, 0);
				} else if (parsed[0] == "buildaieditlinetext" and parsed.length() >= 1) {
					string r = string_trimleft(get_event_message(), (parsed[0] + " ").length());
					string s = input("Edit", "When done, press enter", r, sel_start = 0);
					if (s != "" and !is_eloquence_crash_word(s) and get_sequence(s, true) <= 3)
						send_reliable(peer_id, "aieditline " + s, 0);
				} else if (parsed[0] == "buildairemovelinetext" and parsed.length() > 1)
					send_reliable(peer_id, "airemoveline " + string_replace(get_event_message(), parsed[0] + " ", "", true), 0);
				else if (parsed[0] == "builddrawsoundseditlinetext" and parsed.length() >= 1) {
					string s = input("Edit", "When done, press enter", string_replace(get_event_message(), parsed[0] + " ", "", true));
					if (s != "" and !is_eloquence_crash_word(s) and get_sequence(s, true) <= 3)
						send_reliable(peer_id, "drawsoundseditline " + s, 0);
				} else if (parsed[0] == "builddrawsoundsremovelinetext" and parsed.length() > 1)
					send_reliable(peer_id, "drawsoundsremoveline " + string_replace(get_event_message(), parsed[0] + " ", "", true), 0);
				else if (parsed[0] == "buildfadeditlinetext" and parsed.length() >= 1) {
					string s = input("Edit", "When done, press enter", string_replace(get_event_message(), parsed[0] + " ", "", true));
					if (s != "" and !is_eloquence_crash_word(s) and get_sequence(s, true) <= 3)
						send_reliable(peer_id, "editfad " + s, 0);
				} else if (parsed[0] == "buildremoveowner" and parsed.length() > 1)
					send_reliable(peer_id, "addremoveowner " + string_replace(get_event_message(), parsed[0] + " ", "", true), 0);
				else if (parsed[0] == "buildlitem") {
					binput@ dat = builder_input("text=enter 0 to disable and 1 to enable this feature");
					if (@dat == null) return;
					send_reliable(peer_id, "addlitem litem:" + dat.num("text"), 0);
				} else if (parsed[0] == "builddescription") {
					binput@ dat = builder_input("text=enter the description");
					if (@dat == null) return;
					send_reliable(peer_id, "adddescription description:" + dat.num("text"), 0);
				} else if (parsed[0] == "buildpvp") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						text = type 0 to disable this feature, 1 to don't let anybody turn their pvp off, and 2 to don't let anybody to turn their pvp on");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addpvp pvp:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.num("text"), 0);
						}
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						text = type 0 to disable this feature, 1 to don't let anybody turn their pvp off, and 2 to don't let anybody to turn their pvp on");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addpvp pvp:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("text"), 0);
						}
					}
				} else if (parsed[0] == "buildopening_hours") {
					binput@ dat = builder_input("minhour=enter a number between 0 and 24 as minimum opening hour
																			maxhour = enter a number between 0 and 24 as maximum opening hour");
																								if (@dat == null) return;
																			send_reliable(peer_id, "addopening_hours opening_hours:" + dat.num("minhour") + ":" + dat.num("maxhour"), 0);
				} else if (parsed[0] == "buildlevel") {
					binput@ dat = builder_input("minlevel=minimum level
																			maxlevel = maximum level");
																								 if (@dat == null) return;
																			send_reliable(peer_id, "addlevel level:" + dat.num("minlevel") + ":" + dat.num("maxlevel"), 0);
				} else if (parsed[0] == "buildreinforcement") {
					binput@ dat = builder_input("minreinforcement=minimum reinforcement
																			maxreinforcement = maximum reinforcement");
																					if (@dat == null) return;
																			send_reliable(peer_id, "addreinforcement reinforcement:" + dat.num("minreinforcement") + ":" + dat.num("maxreinforcement"), 0);
				} else if (parsed[0] == "buildtask_status") {
					if (d2dsupport == 0) {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						minz = enter the bottom z
						maxz = enter the top z
						item = item name
						amount = amount");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.y or dat.num("miny")>max.y or dat.num("maxy")<min.y or dat.num("maxy")>max.y or dat.num("minz")<min.z or dat.num("minz")>max.z or dat.num("maxz")<min.z or dat.num("maxz")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "addtask_status task_status:" + dat.num("minx") + ":" + dat.num("maxx") + ":" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.num("minz") + ":" + dat.num("maxz") + ":" + dat.str("item") + ":" + dat.num("amount"), 0);
						}
					} else {
						binput@ dat = builder_input("minx=enter the left x
																				maxx = enter the right x
						miny = enter the minimum y
						maxy = enter the maximum y
						item = item name
						amount = amount");
						if (@dat != null) {
						if (dat.num("minx")<min.x or dat.num("minx")>max.x or dat.num("maxx")<min.x or dat.num("maxx")>max.x or dat.num("miny")<min.z or dat.num("miny")>max.z or dat.num("maxy")<min.z or dat.num("maxy")>max.z) {
								speak("error. Given coordinates are out of range");
								return;
							}
							send_reliable(peer_id, "add task_status task_status:" + dat.num("minx") + ":" + dat.num("maxx") + ":0:0:" + dat.num("miny") + ":" + dat.num("maxy") + ":" + dat.str("item") + ":" + dat.num("amount"), 0);
						}
					}
				} else if (parsed[0] == "spawn_fire" and parsed.length() > 3) {
					int x = string_to_number(parsed[1]);
					int y = string_to_number(parsed[2]);
					int z = string_to_number(parsed[3]);
					string map = parsed[4];
					spawn_tile(string_to_number(parsed[1]), string_to_number(parsed[1]), string_to_number(parsed[2]), string_to_number(parsed[2]), string_to_number(parsed[3]), string_to_number(parsed[3]), "fire");
				} else if (parsed[0] == "admintell") {
					if (!SCRIPT_COMPILED or admin == true) {
						string MessageBox;
						MessageBox = string_replace(get_event_message(), "admintell ", "", false);
						p.play_stationary("admintell.ogg", false);
						add_sbuffer_item("speech", MessageBox);
						add_buffer_item("admintells", MessageBox);
					}
				} else if (parsed[0] == "sleepstart") {
					sleeptimer.restart();
					sleepmode = 1;
					fade_pool(p, -100, 10);
					fade_pool(mpool, -100, 10);
					fade_pool(distpool, -100, 10);
					fade_pool(placedistpool, -100, 10);
					fade_pool(sourcepool, -100, 10);
					fade_pool(musicpool, -100, 10);
					fade_pool(signpool, -100, 10);
					fade_pool(itempool, -100, 10);
					sleepstart.load("sleepstart.ogg");
					sleepstart.play();
					pause_all_sources();
					pause_all_musics();
					pause_all_urls();
					pause_all_timedsounds();
					pause_all_timedmusics();
					pause_all_naturals();
					for (uint i = 0; i < msounds.length(); i++)
						mpool.pause_sound(msounds[i].loopint);
				} else if (parsed[0] == "sleepstop") {
					sleepmode = -1;
					fade(dreamsound);
					fade(sleeping);
					sleeping.close();
					dreamsound.close();
					fade_pool(p, 0, 40);
					fade_pool(mpool, 0, 40);
					fade_pool(distpool, 0, 40);
					fade_pool(placedistpool, 0, 40);
					fade_pool(sourcepool, 0, 40);
					fade_pool(musicpool, 0, 40);
					fade_pool(signpool, 0, 40);
					fade_pool(itempool, 0, 40);
					resume_all_sources();
					resume_all_musics();
					resume_all_urls();
					resume_all_timedsounds();
					resume_all_timedmusics();
					resume_all_naturals();
					for (uint i = 0; i < msounds.length(); i++)
						mpool.resume_sound(msounds[i].loopint);
				} else if (parsed[0] == "notwearing") {
					string m = "But you aren't wearing it!";
					add_sbuffer_item("speech", m);
					add_buffer_item("clothing", m);
				} else if (parsed[0] == "alreadywearingdress") {
					string m = "You're trying to dress one piece over another. It will not work";
					add_sbuffer_item("speech", m);
					add_buffer_item("clothing", m);
				} else if (parsed[0] == "clothing") {
					string a = string_replace(get_event_message(), parsed[0] + " ", "", false);
					string m;
					a = string_replace(a, "You are naked!", "you are naked!", true);
					a = string_replace(a, "You are naked!", "you are naked!", true);
					a = string_replace(a, "are naked!", "are naked!", true);
					a = string_replace(a, "No one close to you", "no one close to you", false);
					a = string_replace(a, "are naked!", "are naked!", true);
					a = string_replace(a, "You are wearing: ", "You are wearing: ", true);
					a = string_replace(a, "are naked!", "are naked!", true);
					a = string_replace(a, "You are just wearing", "You are just wearing", true);
					string[] b = string_split(a, " ", false);
					for (uint i = 0; i < b.length(); i++) {
						if (string_contains(b[i], ",", 1) != -1) {
							b[i] = string_replace(b[i], ",", "", true);
							b[i] = string_replace(b[i], b[i], b[i] + ",", true);
						}
						if (string_contains(b[i], ".", 1) != -1) {
							b[i] = string_replace(b[i], ".", "", true);
							b[i] = string_replace(b[i], b[i], b[i] + ".", true);
						}
						b[i] = string_replace(b[i], "one", "one", true);
						b[i] = string_replace(b[i], ", an", ", " + "an", true);
						b[i] = string_replace(b[i], "one", "one", true);
					}
					for (uint i = 0; i < b.length(); i++)
						m += b[i] + " ";
					add_sbuffer_item("speech", m);
					add_buffer_item("clothing", m);
				} else if (parsed[0] == "alreadywearing") {
					string m = "But you are already wearing it!";
					add_sbuffer_item("speech", m);
					add_buffer_item("clothing", m);
				} else if (parsed[0] == "phone") {
					string telefonar = fone.input("");
					sound s;
					s.load("telefone.ogg");
					int a = random(2, 9);
					for (int i = 0; i < a; i++) {
						s.play();
						while (s.playing) {
							wait(5);
							mainloop();
							if (key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT)) {
								if (key_pressed(KEY_COMMA) == false and kcomma.pressing())
									prevbufferitem();
								if (key_pressed(KEY_PERIOD) == false and kperiod.pressing())
									nextbufferitem();
								if (key_pressed(KEY_LBRACKET) == false and klbracket.pressing())
									bufferleft();
								if (key_pressed(KEY_RBRACKET) == false and krbracket.pressing())
									bufferright();
							}
							if (shift_is_down()) {
								if (key_pressed(KEY_COMMA))
									topbufferitem();
								if (key_pressed(KEY_PERIOD))
									bottombufferitem();
								if (key_pressed(KEY_LBRACKET))
									firstbuffer();
								if (key_pressed(KEY_RBRACKET))
									lastbuffer();
							}
							if (key_pressed(KEY_SLASH)) {
								string chat = v.input("type your message here");
								if (chat != "" and !is_eloquence_crash_word(chat) and get_sequence(chat, true) <= 3) {
									string[] chats = string_split(chat, "::", true);
									if (chat != "") {
										string sendmsg = chat;
										for (uint a = 0; a < aliases.length(); a += 1) {
											string[] a2 = string_split(aliases[a], ":", false);
											if (a2.length() == 2)
												sendmsg = string_replace(sendmsg, a2[0], a2[1], true);
										}
										send_reliable(peer_id, sendmsg, 1);
									}
								}
							}
							if (key_pressed(KEY_BACKSLASH) and dlocalchat == 0) {
								string s = v.input("type your message here");
								if (s != "" and !is_eloquence_crash_word(s) and get_sequence(s, true) <= 3) {
									string sendmsg = s;
									for (uint a = 0; a < aliases.length(); a += 1) {
										string[] a2 = string_split(aliases[a], ":", false);
										if (a2.length() == 2)
											sendmsg = string_replace(sendmsg, a2[0], a2[1], true);
									}
									send_reliable(peer_id, "localchat " + sendmsg, 0);
								}
							}
							if (key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT) and key_up(KEY_LMENU) and key_up(KEY_RMENU) and key_pressed(KEY_EQUALS)) {
								string colocar = v.input("enter the command. Note: / will be put before it automaticly");
								if (colocar != "" and !is_eloquence_crash_word(colocar) and get_sequence(colocar, true) <= 3) {
									string sendmsg = colocar;
									for (uint a = 0; a < aliases.length(); a += 1) {
										string[] a2 = string_split(aliases[a], ":", false);
										if (a2.length() == 2)
											sendmsg = string_replace(sendmsg, a2[0], a2[1], true);
									}
									send_reliable(peer_id, "/" + sendmsg, 1);
								}
							}
						}
					}
				} else if (parsed[0] == "msg")
					msgmenu();
				else if (parsed[0] == "apps")
					appsmenu();
				else if (parsed[0] == "small_saw") {
					if (get_tile_at(me.x, me.y, me.z) == "wobbly_wood" or get_tile_at(me.x, me.y, me.z) == "wood" or get_tile_at(me.x, me.y, me.z) == "wood2" or get_tile_at(me.x, me.y, me.z) == "wood3" or get_tile_at(me.x, me.y, me.z) == "wood4" or get_tile_at(me.x, me.y, me.z) == "wood5" or get_tile_at(me.x, me.y, me.z) == "wood6" or get_tile_at(me.x, me.y, me.z) == "wood7" or get_tile_at(me.x, me.y, me.z) == "wood8" or get_tile_at(me.x, me.y, me.z) == "wood9" or get_tile_at(me.x, me.y, me.z) == "wood10" or get_tile_at(me.x, me.y, me.z) == "wood12" or get_tile_at(me.x, me.y, me.z) == "wood13" or get_tile_at(me.x, me.y, me.z) == "wood14" or get_tile_at(me.x, me.y, me.z) == "wood15" or get_tile_at(me.x, me.y, me.z) == "wood16" or get_tile_at(me.x, me.y, me.z) == "wood17" or get_tile_at(me.x, me.y, me.z) == "wood18" or get_tile_at(me.x, me.y, me.z) == "stairs" or get_tile_at(me.x, me.y, me.z) == "smallwood" or get_tile_at(me.x, me.y, me.z) == "bridge" or get_tile_at(me.x, me.y, me.z) == "bridge2" or get_tile_at(me.x, me.y, me.z) == "bridge3" or get_tile_at(me.x, me.y, me.z) == "old_wood" or get_tile_at(me.x, me.y, me.z) == "plywood" or get_tile_at(me.x, me.y, me.z) == "plywood2" or get_tile_at(me.x, me.y, me.z) == "plywood3" or get_tile_at(me.x, me.y, me.z) == "plywood4") {
						rvp.play_stationary("smallsaw" + random(1, 5) + ".ogg", false);
						send_reliable(peer_id, "draw smallsaw" + random(1, 5) + ".ogg", 7);
						send_reliable(peer_id, "getwwood", 0);
					}
				} else if (parsed[0] == "large_saw") {
					if (get_tile_at(me.x, me.y, me.z) == "hardwood" or get_tile_at(me.x, me.y, me.z) == "hardwood2" or get_tile_at(me.x, me.y, me.z) == "hadwood3" or get_tile_at(me.x, me.y, me.z) == "hardwood4" or get_tile_at(me.x, me.y, me.z) == "hardwood5" or get_tile_at(me.x, me.y, me.z) == "hardwood6" or get_tile_at(me.x, me.y, me.z) == "hardwood7") {
						rvp.play_stationary("largesaw" + random(1, 5) + ".ogg", false);
						send_reliable(peer_id, "draw largesaw" + random(1, 5) + ".ogg", 7);
						send_reliable(peer_id, "getwwood", 0);
					} else if (get_tile_at(me.x, me.y, me.z) == "metal" or get_tile_at(me.x, me.y, me.z) == "metal2" or get_tile_at(me.x, me.y, me.z) == "metal3" or get_tile_at(me.x, me.y, me.z) == "metal4" or get_tile_at(me.x, me.y, me.z) == "metal5" or get_tile_at(me.x, me.y, me.z) == "metal6" or get_tile_at(me.x, me.y, me.z) == "metal7" or get_tile_at(me.x, me.y, me.z) == "metal8" or get_tile_at(me.x, me.y, me.z) == "metal9" or get_tile_at(me.x, me.y, me.z) == "metal10" or get_tile_at(me.x, me.y, me.z) == "metal11" or get_tile_at(me.x, me.y, me.z) == "metal12" or get_tile_at(me.x, me.y, me.z) == "metal13" or get_tile_at(me.x, me.y, me.z) == "metalpipe" or get_tile_at(me.x, me.y, me.z) == "ladder" or get_tile_at(me.x, me.y, me.z) == "ladder2" or get_tile_at(me.x, me.y, me.z) == "ladder3") {
						rvp.play_stationary("largesaw" + random(1, 5) + ".ogg", false);
						send_reliable(peer_id, "draw largesaw" + random(1, 5) + ".ogg", 7);
						send_reliable(peer_id, "getmmetal", 0);
					}
				} else if (parsed[0] == "boat") {
					walktimer.restart();
					bbforward();
					walktime += 0.05;
					airtime += 0.05;
					movecheck2();
				} else if (parsed[0] == "launchmenu") {
					string i = string_replace(parsed[1], "[SPCE]", " ", true);
					string t = string_replace(parsed[2], "[SPCE]", " ", true);
					string items = string_replace(get_event_message(), parsed[0] + " " + parsed[1] + " " + parsed[2] + " ", "", true);
					serverside_menu(t, i, items);
				} else if (parsed[0] == "launchmenu2") {
					string i = string_replace(parsed[1], "[SPCE]", " ", true);
					string t = string_replace(parsed[2], "[SPCE]", " ", true);
					string items = string_replace(get_event_message(), parsed[0] + " " + parsed[1] + " " + parsed[2] + " ", "", true);
					serverside_menu2(t, i, items);
				} else if (parsed[0] == "chuvaativa") {
					chuvaativa = 1;
					if (chuvatelhado.playing) chuvatelhado.close();
					chuvatelhado.volume = -12;
					if (chuvaativa == 1 and somchuva != "none.ogg") {
						chuvatelhado.load(somchuva);
						chuvatelhado.play_looped();
					}
				} else if (parsed[0] == "fimchuva") {
					chuvaativa = 0;
					chuvatelhado.pause();
				} else if (parsed[0] == "windativa") {
					windativa = 1;
					if (windtelhado.playing) windtelhado.close();
					windtelhado.volume = -12;
					if (windativa == 1 and somwind != "none.ogg") {
						windtelhado.load(somwind);
						windtelhado.play_looped();
					}
				} else if (parsed[0] == "fimwind") {
					windativa = 0;
					windtelhado.pause();
				} else if (parsed[0] == "nightativa") {
					nightativa = 1;
					if (nighttelhado.playing) nighttelhado.close();
					nighttelhado.volume = -12;
					if (nightativa == 1 and somnight != "none.ogg") {
						nighttelhado.load(somnight);
						nighttelhado.play_looped();
					}
				} else if (parsed[0] == "fimnight") {
					nightativa = 0;
					nighttelhado.pause();
				} else if (parsed[0] == "spawnfire_starter" and parsed.length() > 5) {
					int x = string_to_number(parsed[1]);
					int y = string_to_number(parsed[2]);
					int z = string_to_number(parsed[3]);
					string map = parsed[4];
					int id = string_to_number(parsed[5]);
					spawn_fire_starter(x, y, z, map, id);
				} else if (parsed[0] == "killfire_starter" and parsed.length() > 1) {
					int fs = find_fire_starter(string_to_number(parsed[1]));
					if (fs > -1) {
						@fire_starters[fs] = null;
						fire_starters.remove_at(fs);
					}
				} else if (parsed[0] == "volumechuva") {
					chuvalivre.volume = string_to_number(parsed[1]);
					chuvatelhado.volume = string_to_number(parsed[1]);
				} else if (parsed[0] == "pst") {
					if (somchuva != "none.ogg")
						p.play_stationary(parsed[1], false);
				} else if (parsed[0] == "volumewind") {
					windlivre.volume = string_to_number(parsed[1]);
					windtelhado.volume = string_to_number(parsed[1]);
				} else if (parsed[0] == "wpst") {
					if (somwind != "none.ogg")
						p.play_stationary(parsed[1], false);
				} else if (parsed[0] == "volumenight") {
					nightlivre.volume = string_to_number(parsed[1]);
					nighttelhado.volume = string_to_number(parsed[1]);
				} else if (parsed[0] == "npst") {
					if (somnight != "none.ogg")
						p.play_stationary(parsed[1], false);
				} else if (parsed[0] == "hempty") {
					int index = string_to_number(parsed[1]);
					draw = "";
					if (index == 1)
						lefthand = "";
					llastuse = "";
					if (index == 2)
						righthand = "";
					rlastuse = "";
				} else if (parsed[0] == "canjump")
					canjump = true;
				else if (parsed[0] == "cannotjump")
					canjump = false;
				else if (parsed[0] == "setwalktime")
					walktime = string_to_number(parsed[1]);
				else if (parsed[0] == "resetwalktime") {
					walkmod = false;
					walktime = 180;
					if (canjump == false) canjump = true;
					airtime = 100;
				} else if (parsed[0] == "w+") {
					walktime += 0.5;
					airtime += 0.5;
					writeprefs();
				} else if (parsed[0] == "w-") {
					walktime -= 0.5;
					airtime -= 0.5;
					writeprefs();
				} else if (parsed[0] == "bw+") {
					bmovetime += 0.05;
					writeprefs();
				} else if (parsed[0] == "w-") {
					bmovetime -= 0.05;
					writeprefs();
				} else if (parsed[0] == "sendpacket2" && parsed.length() > 2)
					send_reliable(peer_id, string_replace(get_event_message(), parsed[0] + " " + parsed[1] + " ", "", true), string_to_number(parsed[1]));
				else if (parsed[0] == "playerlog") {
					file lf;
					lf.open("players.log", "wb");
					lf.write(string_replace(get_event_message(), "playerlog ", "", false));
					lf.close();
					speak("log written");
				} else if (parsed[0] == "dlg") {
					string MessageBox = string_replace(get_event_message(), "dlg ", "", false);
					dlg(MessageBox, true);
				} else if (parsed[0] == "enterplace" && parsed.length() >= 5) {
					place.x = string_to_number(parsed[1]);
					place.y = string_to_number(parsed[2]);
					place.z = string_to_number(parsed[3]);
					placemap = parsed[4];
					inplace = true;
				} else if (parsed[0] == "exitplace") {
					place.x = 0;
					place.y = 0;
					place.z = 0;
					placemap = "";
					inplace = false;
				} else if (parsed[0] == "restart") {
					speak("resetting the server... Please wait...");
					reconnect();
					writeprefs();
				} else if (parsed[0] == "servershutdown") {
					string r = string_trimleft(get_event_message(), (parsed[0] + " ").length());
					if (stringright(r, 1) == ".") r = string_trimright(r, 1);
					exitgame(false);
					dlg("the server offline" + (r != "" ? " for the following reason" : "") + "." + (r != "" ? " " + r + "." : ""));
					mainmenu();
					return;
				} else if (parsed[0] == "serverreboot") {
					string r = string_trimleft(get_event_message(), (parsed[0] + " ").length());
					if (stringright(r, 1) == ".") r = string_trimright(r, 1);
					exitgame(false);
					dlg("the server restart" + (r != "" ? " for the following reason" : "") + "." + (r != "" ? " " + r + "." : ""));
					p.play_stationary("reconnected" + sndtype, false);
					reconnect();
					return;
				} else if (parsed[0] == "msgvocÍganhou") {
					string m = ("you got ") + " " + parsed[1] + " xp!";
					add_sbuffer_item("speech", m);
					add_buffer_item("misc", m);
				} else if (parsed[0] == "msgvocÍganhou2") {
					string m = ("you got ") + " " + parsed[1] + " " + ("xp because of double xp!");
					add_sbuffer_item("speech", m);
					add_buffer_item("misc", m);
				} else if (parsed[0] == "msgvocÍganhou10") {
					string m = ("you got ") + " " + parsed[1] + " " + ("xp because of super xp!");
					add_sbuffer_item("speech", m);
					add_buffer_item("misc", m);
				} else if (parsed[0] == "msgsublinhado") {
					string a = get_event_message();
					string b;
					string m;
					a = string_replace(a, parsed[0] + " ", "", true);
					string[] mm = string_split(a, " ", false);
					for (uint i = 0; i < mm.length(); i++) {
						b = mm[i];
						b = string_replace(b, "_", " ", true);
						m += b + " ";
					}
					add_sbuffer_item("speech", m);
					add_buffer_item("misc", m);
				} else if (parsed[0] == "msg2") {
					string m;
					string a = get_event_message();
					a = string_replace(a, parsed[0] + " ", "", false);
					string[] b = string_split(a, ";", false);
					for (uint i = 0; i < b.length(); i++)
						m += (b[i]);
					add_sbuffer_item("speech", m);
					add_buffer_item("misc", m);
				} else if (parsed[0] == "motd2") {
					string mensagem = get_event_message();
					mensagem = string_replace(mensagem, parsed[0] + " ", "", true);
					add_sbuffer_item("speech", "Mensagem do dia:" + " " + mensagem);
					add_buffer_item("misc", "Mensagem do dia:" + " " + mensagem);
				} else if (parsed[0] == "menusound") {
					int x = string_to_number(parsed[1]);
					int y = string_to_number(parsed[2]);
					int z = string_to_number(parsed[3]);
					string map = parsed[4];
					string pn = parsed[5];
					if (name != pn and mapname == map)
						rvp.play_3d(parsed[6], me.x, me.y, me.z, x, y, z, calculate_theta(facing), false);
				} else if (parsed[0] == "mtester") mtester(string_replace(get_event_message(), "mtester ", "", true));
				else if (parsed[0] == "mtester3") mtester3(string_replace(get_event_message(), "mtester3 ", "", true));
				else if (parsed[0] == "tlptester") tlptester(string_replace(get_event_message(), "tlptester ", "", true));
				else if (parsed[0] == "ragequit")
					send_reliable(peer_id, "rqclose", 0);
				else if (parsed[0] == "ragequitok") {
					int rqnum = random(1, 7);
					dlgmeu("", "rage" + rqnum + ".ogg", true, 30);
					wait(200);
					exit();
				} else if (parsed[0] == "islcm") {
					lcm = true;
				} else if (parsed[0] == "isstaff" && parsed.length() > 1) {
					string t = string_trim_left(get_event_message(), (parsed[0] + " ").length());
					staff.setstaff(t, true);
					return;
				} else if (parsed[0] == "isnotstaff" && parsed.length() > 1) {
					string t = string_trim_left(get_event_message(), (parsed[0] + " ").length());
					staff.setstaff(t, false);
					return;
				} else if (parsed[0] == "ispartnerchat")
					chat_partner();
				else if (parsed[0] == "srmenu") {
					string meitems;
					string[] bl = string_split(get_event_message(), ":", false);
					for (uint i = 1; i < bl.length(); i++)
						meitems += bl[i];
					servermenu(string_trim_left(bl[0], 7), meitems);
				} else if (parsed[0] == "srmenui") {
					string meitems;
					string myacts;
					string[] bl = string_split(get_event_message(), ":", false);
					string[] bl2 = string_split(get_event_message(), "-_", true);
					for (uint i = 1; i < bl.length(); i++)
						meitems += bl[i];
					for (uint i = 0; i < bl2.length(); i++)
						myacts += bl2[i];
					servermenu(string_trim_left(bl[0], 7), meitems, false, 1, myacts);
				} else if (parsed[0] == "followstart") {
					can_move = false;
					following = true;
				} else if (parsed[0] == "followstop") {
					can_move = true;
					following = false;
				} else if (parsed[0] == "lookstart") {
					can_move = false;
					looking = true;
				} else if (parsed[0] == "lookstop") {
					can_move = true;
					looking = false;
				} else if (parsed[0] == "forcekey" and parsed.length() > 1) {
					int keycode = string_to_number(parsed[1]);
					//force_key_down(keycode);
					key_released(keycode);
				} else if (parsed[0] == "startmoving")
					can_move = true;
				else if (parsed[0] == "stopmoving")
					can_move = false;
				else if (parsed[0] == "movestart")
					can_move = true;
				else if (parsed[0] == "movestop")
					can_move = false;
				else if (parsed[0] == "freezestart") {
					can_move = false;
					frozen = true;
					pause_all_sources();
					pause_all_musics();
					pause_all_urls();
					pause_all_timedsounds();
					pause_all_timedmusics();
					pause_all_naturals();
					for (uint i = 0; i < msounds.length(); i++)
						mpool.pause_sound(msounds[i].loopint);
				} else if (parsed[0] == "freezestop") {
					can_move = true;
					frozen = false;
					resume_all_sources();
					resume_all_musics();
					resume_all_urls();
					resume_all_timedsounds();
					resume_all_timedmusics();
					resume_all_naturals();
					for (uint i = 0; i < msounds.length(); i++)
						mpool.resume_sound(msounds[i].loopint);
				} else if (parsed[0] == "look" and parsed.length() > 4) {
					me.x = string_to_number(parsed[1]);
					me.y = string_to_number(parsed[2]);
					me.z = string_to_number(parsed[3]);
					lookname = parsed[4];
					if (tpool1.elapsed >= npool1) {
						tpool1.restart();
						npool1 = random(30, 300);
						mpool.update_listener_3d(me.x, me.y, me.z, calculate_theta(facing));
						p.update_listener_3d(me.x, me.y, me.z, calculate_theta(facing));
						sourcepool.update_listener_3d(me.x, me.y, me.z, calculate_theta(facing));
						musicpool.update_listener_3d(me.x, me.y, me.z, calculate_theta(facing));
						distpool.update_listener_3d(me.x, me.y, me.z, calculate_theta(facing));
						placedistpool.update_listener_3d(me.x, me.y, me.z, calculate_theta(facing));
					}
					if (tpool2.elapsed >= npool2) {
						tpool2.restart();
						npool2 = random(30, 300);
						distpool.update_listener_3d(me.x, me.y, me.z, calculate_theta(facing));
						placedistpool.update_listener_3d(me.x, me.y, me.z, calculate_theta(facing));
						signpool.update_listener_3d(me.x, me.y, me.z, calculate_theta(facing));
						itempool.update_listener_3d(me.x, me.y, me.z, calculate_theta(facing));
					}
				} else if (parsed[0] == "speak")
					speak(string_trim_left(get_event_message(), 6));
				else if (parsed[0] == "clip")
					clipboard_copy_text(string_trim_left(get_event_message(), 5));
				else if (parsed[0] == "addbchat") {
					string msg = get_event_message();
					msg = string_replace(msg, parsed[0] + " ", "", true);
					string m = msg;
					add_buffer_item("chats", msg);
				} else if (parsed[0] == "peak") {
					string msg;
					msg = string_replace(get_event_message(), "peak ", "", false);
					p.play_stationary("peak.ogg", false);
					add_buffer_item("notifications", msg);
				} else if (parsed[0] == "checkpointcheckclient")
					send_reliable(peer_id, "checkpointcheck", 0);
				else if (parsed[0] == "notify" and buffer_active("notifications") == 1) {
					string msg;
					msg = string_replace(get_event_message(), "notify ", "", false);
					p.play_stationary("notice.ogg", false);
					add_buffer_item("notifications", msg);
				} else if (parsed[0] == "maps" and buffer_active("maps") == 1) {
					string msg;
					msg = string_replace(get_event_message(), "maps ", "", false);
					add_buffer_item("maps", msg);
				} else if (parsed[0] == "channel_message" and buffer_active("maps") == 1) {
					string msg;
					msg = string_replace(get_event_message(), "channel_message ", "", false);
					add_buffer_item("channel messages", msg);
				} else if (parsed[0] == "channelenter" and buffer_active("maps") == 1) {
					string msg;
					msg = string_replace(get_event_message(), "channelenter ", "", false);
					p.play_stationary("notify_blips.ogg", false);
					add_buffer_item("channel messages", msg);
				} else if (parsed[0] == "channelexit" and buffer_active("maps") == 1) {
					string msg;
					msg = string_replace(get_event_message(), "channelexit ", "", false);
					p.play_stationary("notify_google4.ogg", false);
					add_buffer_item("channel messages", msg);
				} else if (parsed[0] == "channelkick" and buffer_active("maps") == 1) {
					string msg;
					msg = string_replace(get_event_message(), "channelkick ", "", false);
					p.play_stationary("kick.ogg", false);
					add_buffer_item("channel messages", msg);
				} else if (parsed[0] == "notify2") {
					string msg;
					msg = string_replace(get_event_message(), "notify2 ", "", false);
					p.play_stationary("notify2.ogg", false);
					add_buffer_item("notifications", msg);
				} else if (parsed[0] == "notify_startrek_chime") {
					string msg;
					msg = string_replace(get_event_message(), "notify_startrek_chime ", "", false);
					p.play_stationary("notify_startrek_chime.ogg", false);
					add_buffer_item("notifications", msg);
				} else if (parsed[0] == "notify3") {
					string msg;
					msg = string_replace(get_event_message(), "notify3 ", "", false);
					p.play_stationary("notify3.ogg", false);
					add_buffer_item("notifications", msg);
				} else if (parsed[0] == "notify4") {
					string msg;
					msg = string_replace(get_event_message(), "notify4 ", "", false);
					p.play_stationary("notify4.ogg", false);
					add_buffer_item("notifications", msg);
				} else if (parsed[0] == "notify5") {
					string msg;
					msg = string_replace(get_event_message(), "notify5 ", "", false);
					p.play_stationary("notify5.ogg", false);
					add_buffer_item("notifications", msg);
				} else if (parsed[0] == "notify6") {
					string msg;
					msg = string_replace(get_event_message(), "notify6 ", "", false);
					p.play_stationary("notify6.ogg", false);
					add_buffer_item("notifications", msg);
				} else if (parsed[0] == "spnotify") {
					string msg;
					msg = string_replace(get_event_message(), "spnotify ", "", false);
					p.play_stationary("notify_blips3.ogg", false);
					add_buffer_item("notifications", msg);
				} else if (parsed[0] == "death") {
					walktime = 180;
					airtime = 220;
					send_reliable(peer_id, "revive", 0);
					send_reliable(peer_id, "move " + me.x + " " + me.y + " " + me.z, 8);
					if (sleepmode != 0) {
						sleepmode = -1;
						fade(dreamsound);
						fade(sleeping);
						fade_pool(p, 0, 40);
						fade_pool(mpool, 0, 10);
						fade_pool(distpool, 0, 10);
						fade_pool(placedistpool, 0, 10);
						fade_pool(sourcepool, 0, 10);
						fade_pool(musicpool, 0, 10);
						fade_pool(signpool, 0, 10);
						fade_pool(itempool, 0, 10);
					}
				} else if (parsed[0] == "input") {
					string[] ds = string_split(string_replace(get_event_message(), "input ++", "", false), "++", false);
					serverbox(string_to_number(ds[0]), string_to_number(ds[1]), string_to_number(ds[2]), string_to_number(ds[3]), ds[4], ds[5]);
				} else if (parsed[0] == "trackplayer") {
					int x = round(string_to_number(parsed[2]), 0);
					int y = round(string_to_number(parsed[3]), 0);
					int z = string_to_number(parsed[4]);
					string mp = parsed[5];
					if (mapname != mp)
						speak("This player is on a different map. Sorry");
					else
						tell_where(x, y, z, parsed[6], true);
				} else if (parsed[0] == "playermapmenu") {
					string m = string_replace(get_event_message(), "playermapmenu ", "Stop Tracking\n", false);
					string[] playerstuff = string_split(m, "\n");
					player::menu::map(playerstuff);
				} else if (parsed[0] == "playermenu") {
					string m = string_replace(get_event_message(), "playermenu", "", true);
					string[] playerstuff = string_split(m, "\n");
					player::menu::entire(playerstuff);
				} else if (parsed[0] == "newitem") {
					int x = string_to_number(parsed[1]);
					int y = string_to_number(parsed[2]);
					int z = string_to_number(parsed[3]);
					string map = parsed[4];
					int itemid = string_to_number(parsed[5]);
					spawn_mapitem(x, y, z, map, itemid);
				} else if (parsed[0] == "remitem" and parsed.length() > 1)
					remove_mapitem(string_to_number(parsed[1]));
				else if (parsed[0] == "speedup")
					walktime -= random(120, 170);
				else if (parsed[0] == "speeddown")
					walktime -= random(180, 220);
				else if (parsed[0] == "walkmod")
					walktime -= random(170, 190);
				else if (parsed[0] == "speed_drink0")
					walktime = 180;
				else if (parsed[0] == "speed_drink1")
					walktime = 150;
				else if (parsed[0] == "changepass" and parsed.length() > 1) {
					password = parsed[1];
					accounts.insert_last("name: " + name + ". Password: " + password + "");
					writeprefs();
					reconnect();
				} else if (parsed[0] == "jumping") {
					int x = string_to_number(parsed[1]);
					int y = string_to_number(parsed[2]);
					int z = string_to_number(parsed[3]);
					rvp.play_3d("jump" + random(1, 22) + ".ogg", me.x, me.y, me.z, x, y, z, calculate_theta(facing), false);
				} else if (parsed[0] == "facing" && parsed.length() > 1)
					facing = string_to_number(parsed[1]);
				else if (parsed[0] == "updatesvr") {
					send_reliable(peer_id, "close", 0);
					speak("The server is updating. Reconnecting to server...");
					reconnect();
					connected = false;
					writeprefs();
				} else if (parsed[0] == "killclient") {
					if (importbufferlogs == 1) export_all_buffers();
					exitgame(false);
					writeprefs();
					exit();
				} else if (parsed[0] == "offline" and parsed.length() > 5) {
					if (parsed[4] == name) {
						x = false;
						exitgame(true);
					}
					int x = string_to_number(parsed[1]);
					int y = string_to_number(parsed[2]);
					int z = string_to_number(parsed[3]);
					string n = parsed[4];
					string m = parsed[5];
					remove_player(n);
					if (readolmsg == 1 and name != "smart_bot") {
						if (offlinesound == "random") {
							if (offsound == 1) p.play_stationary("offline" + random(1, 25) + ".ogg", false);
							else p.play_stationary("offline" + random(1, 25) + ".ogg", false);
						} else {
							if (offsound == 1) p.play_stationary(offlinesound + ".ogg", false);
							else p.play_stationary(offlinesound + ".ogg", false);
						}
					} else if (parsed[4] != name) {
						if (readolmsg == 1 and name != "smart_bot") {
							if (offlinesound == "random") {
								if (offsound == 1) p.play_stationary("offline" + random(1, 25) + ".ogg", false);
								else p.play_stationary("offline" + random(1, 25) + ".ogg", false);
							} else {
								if (offsound == 1) p.play_stationary(offlinesound + ".ogg", false);
								else p.play_stationary(offlinesound + ".ogg", false);
							}
						}
					}
				} else if (parsed[0] == "m_data")
					load_map(string_replace(get_event_message(), "m_data ", "", true));
				else if (parsed[0] == "online" && parsed.length() > 5) {
					int x = string_to_number(parsed[1]);
					int y = string_to_number(parsed[2]);
					int z = string_to_number(parsed[3]);
					string n = parsed[4];
					string mp = parsed[5];
					if (readolmsg == 1 and name != n and name != "smart_bot") {
						if (onlinesound == "random") {
							if (onsound == 1) p.play_stationary("online" + random(1, 24) + ".ogg", false);
							else p.play_stationary("online" + random(1, 24) + ".ogg", false);
						} else {
							if (onsound == 1) p.play_stationary(onlinesound + ".ogg", false);
							else p.play_stationary(onlinesound + ".ogg", false);
						}
						spawn_player(x, y, z, mp, n);
					} else if (parsed[4] != name) {
						if (readolmsg == 1 and name != "smart_bot") {
							if (onlinesound == "random") {
								if (onsound == 1) p.play_stationary("online" + random(1, 24) + ".ogg", false);
								else p.play_stationary("online" + random(1, 24) + ".ogg", false);
							} else {
								if (onsound == 1) p.play_stationary(onlinesound + ".ogg", false);
								else p.play_stationary(onlinesound + ".ogg", false);
							}
						}
					}
				} else if (parsed.length() >= 5 and is_sound_number(parsed[1]) and is_sound_number(parsed[2]) and is_sound_number(parsed[3])) {
					if (parsed.length() == 5) {
						if (parsed[4] == mapname and sleepmode == -1)
							rvp.play_3d(parsed[0] + ".ogg", me.x, me.y, me.z, string_to_number(parsed[1]), string_to_number(parsed[2]), string_to_number(parsed[3]), calculate_theta(facing), false);
					}
				} else
					speak(get_event_message());
			} else if (e.channel == 1 and buffer_active("chats") == 1 and readchats == 1) {
				string[] parsed = string_split(get_event_message(), " ", false);
				if (parsed.length() > 1) {
					string action = parsed[0];
					if (action == "chat") {
						if (!buffer_muted("chats")) {
							if (chatsound == "random") {
								if (chsound == 1) p.play_stationary("chat" + random(1, 29) + ".ogg", false);
								else p.play_stationary("chat" + random(1, 29) + ".ogg", false);
							} else {
								if (chsound == 1) p.play_stationary(chatsound + ".ogg", false);
								else p.play_stationary(chatsound + ".ogg", false);
							}
						}
					} else
						p.play_stationary(action + ".ogg", false);
					string mess = string_trim_left(get_event_message(), string_len(action) + 1);
					add_sbuffer_item("speech", mess);
					add_buffer_item("chats", mess);
				}
			}
			if (e.channel == 2 and buffer_active("misc") == 1) {
				add_buffer_item("misc", get_event_message());
			}
			if (e.channel == 3) {
				string[] parsed = string_split(get_event_message(), " ", true);
				messager mdic = get_event_message_as_object();
				if (mdic.get_value("message") == "playsnd") {
					double x = stn(mdic.get_value("x"));
					double y = stn(mdic.get_value("y"));
					double z = stn(mdic.get_value("z"));
					double lx = me.x;
					double ly = me.y;
					double lz = me.z;
					string mn = mdic.get_value("map");
					string sndd = mdic.get_value("soundname");
					string alt_snd = mdic.get_value("alt_snd");
					if (@sndpack != null && alt_snd != "" && !sndpack.file_exists(sndd)) sndd = alt_snd;
					int range = stn(mdic.get_value("range", "0"));
					int s = rvp.play_3d(sndd, lx, ly, lz, x, y, z, calculate_theta(facing), false);
					rvp.update_sound_range_3d(s, 0, range, 0, range, 0, range);
					return;
				} else if (mdic.get_value("message") == "playsnd2") {
					double lx = me.x;
					double ly = me.y;
					double lz = me.z;
					string mn = mdic.get_value("map");
					string sndd = mdic.get_value("soundname");
					string[] m1s = mdic.get_value("min", "0;0;0").split(";");
					string[] m2s = mdic.get_value("max", "0;0;0").split(";");
					vector m1(stn(m1s[0]), stn(m1s[1]), stn(m1s[2]));
					vector m2(stn(m2s[0]), stn(m2s[1]), stn(m2s[2]));
					string alt_snd = mdic.get_value("alt_snd");
					if (@sndpack != null && alt_snd != "" && !sndpack.file_exists(sndd)) sndd = alt_snd;
					int range = stn(mdic.get_value("range", "0"));
					int s = rvp.play_3d(sndd, lx, ly, lz, m1.x, m1.y, m1.z, facing, false);
					rvp.update_sound_range_3d(s, 0, m2.x + range - m1.x + range, 0, m2.y - m1.y + range, 0, m2.z - m1.z + range);
					return;
				} else if (parsed.length() >= 5 and is_sound_number(parsed[1]) and is_sound_number(parsed[2]) and is_sound_number(parsed[3])) {
					if (parsed.length() == 5 and parsed[4] == mapname && frozen == false)
						rvp.play_3d(parsed[0] + ".ogg", me.x, me.y, me.z, string_to_number(parsed[1]), string_to_number(parsed[2]), string_to_number(parsed[3]), calculate_theta(facing), false);
				}
			}
			if (e.channel == 4) {
				string[] parsed = string_split(get_event_message(), " ", false);
				if (parsed[0] == "createmsound" && parsed.length() >= 8) createmsound(parsed[1], parsed[2], string_to_number(parsed[3]), string_to_number(parsed[4]), string_to_number(parsed[5]), parsed[6], string_to_number(parsed[7]));
				else if (parsed[0] == "updatemsound" && parsed.length() >= 6) updatemsound(parsed[1], string_to_number(parsed[2]), string_to_number(parsed[3]), string_to_number(parsed[4]), string_to_number(parsed[5]));
				else if (parsed[0] == "destroymsound" && parsed.length() > 1) destroymsound(parsed[1]);
			}
			if (e.channel == 5) {
				string[] parsed = string_split(get_event_message(), " ", false);
				if (parsed[0] == "voice") {
					string themap, un;
					int x, y, z;
					un = parsed[1];
					x = string_to_number(parsed[2]);
					y = string_to_number(parsed[3]);
					z = string_to_number(parsed[4]);
					themap = parsed[5];
					anumber = random(195000, 1900000);
					string vc = string_replace(get_event_message(), parsed[0] + " " + parsed[1] + " " + parsed[2] + " " + parsed[3] + " " + parsed[4] + " " + parsed[5] + " ", "", true);
					if (themap == mapname) {
						if (un == name and hearyourvoicechat == 1)
							p.play_3d(vc, me.x, me.y, me.z, x, y, z, calculate_theta(facing), false);
						else if (un != name and hearothersvoicechat == 1)
							p.play_3d(vc, me.x, me.y, me.z, x, y, z, calculate_theta(facing), false);
					}
				} else if (parsed[0] == "tts") {
					string themap, un;
					int x, y, z;
					un = parsed[1];
					x = string_to_number(parsed[2]);
					y = string_to_number(parsed[3]);
					z = string_to_number(parsed[4]);
					themap = parsed[5];
					anumber = random(195000, 1900000);
					string vc = try_memget(string_trimleft(get_event_message(), (parsed[0] + " " + parsed[1] + " " + parsed[2] + " " + parsed[3] + " " + parsed[4] + " " + parsed[5] + " ").length()));
					if (themap == mapname) {
						if (un == name and hearyourttschat == 1)
							rvp.play_3d(vc, me.x, me.y, me.z, x, y, z, calculate_theta(facing), false, memory = true);
						else if (un != name and hearothersttschat == 1)
							rvp.play_3d(vc, me.x, me.y, me.z, x, y, z, calculate_theta(facing), false, memory = true);
					}
				} else if (parsed[0] == "voice2") {
					anumber = random(195000, 1900000);
					string vc = string_replace(get_event_message(), parsed[0] + " " + parsed[1] + " ", "", true);
					p.play_stationary(vc, false);
					file f;
					f.open("voices/" + parsed[1] + " voice " + DATE_WEEKDAY_NAME + ", " + DATE_MONTH_NAME + "-" + DATE_DAY + "-" + DATE_YEAR + ", " + TIME_HOUR + " " + TIME_MINUTE + " " + TIME_SECOND + ".ogg", "wb");
					f.write(vc);
					f.close();
				} else if (parsed[0] == "tts2") {
					anumber = random(195000, 1900000);
					string vc = string_replace(get_event_message(), parsed[0] + " " + parsed[1] + " ", "", true);
					p.play_stationary(vc, false);
					file f;
					f.open("voices/" + parsed[1] + " tts message " + DATE_WEEKDAY_NAME + ", " + DATE_MONTH_NAME + "-" + DATE_DAY + "-" + DATE_YEAR + ", " + TIME_HOUR + " " + TIME_MINUTE + " " + TIME_SECOND + ".ogg", "wb");
					f.write(vc);
					f.close();
				}
			}
			if (e.channel == 6 && sleepmode == -1) {
				string[] parsed = string_split(get_event_message(), " ");
				if (parsed[0] == "play" and parsed.length() > 4)
					rvp.play_3d(parsed[1], me.x, me.y, me.z, string_to_number(parsed[2]), string_to_number(parsed[3]), string_to_number(parsed[4]), calculate_theta(facing), false);
				else if (parsed[0] == "distsound" and parsed.length() > 5) {
					string soundname = parsed[1];
					int x = string_to_number(parsed[2]);
					int y = string_to_number(parsed[3]);
					int z = string_to_number(parsed[4]);
					string soundmap = parsed[5];
					if (soundmap == mapname)
						distpool.play_3d(soundname + ".ogg", me.x, me.y, me.z, x, y, z, facing, false);
					else if (soundmap == placemap && inplace == true)
						placedistpool.play_3d(soundname + ".ogg", place.x, place.y, place.z, x, y, z, facing, false);
				} else if (parsed[0] == "playpavap" and parsed.length() > 4)
					rvp.play_3d(parsed[1], me.x, me.y, me.z, string_to_number(parsed[2]), string_to_number(parsed[3]), string_to_number(parsed[4]), calculate_theta(facing), false);
				else if (parsed[0] == "play_stationary" and parsed.length() >= 2)
					p.play_stationary(parsed[1], false);
				else if (parsed[0] == "play_file" and parsed.length() >= 2)
					p.play_stationary(string_trim_left(get_event_message(), 10), false);
				else if (parsed[0] == "gplay" && parsed.length() > 3)
					rvp.play_2d(parsed[1], me.x, me.y, string_to_number(parsed[2]), string_to_number(parsed[3]), false);
				else if (parsed[0] == "3d")
					rvp.play_3d(parsed[1], me.x, me.y, me.z, string_to_number(parsed[2]), string_to_number(parsed[3]), string_to_number(parsed[4]), calculate_theta(facing), false);
				else if (parsed[0] == "3dstep")
					rvp.play_3d(get_tile_at(string_to_number(parsed[1]), string_to_number(parsed[2]), string_to_number(parsed[3])) + "step" + random(1, 5) + ".ogg", me.x, me.y, me.z, string_to_number(parsed[1]), string_to_number(parsed[2]), string_to_number(parsed[3]), calculate_theta(facing), false);
				else if (parsed[0] == "3dsteppavap")
					rvp.play_3d(get_tile_at(string_to_number(parsed[1]), string_to_number(parsed[2]), string_to_number(parsed[3])) + "step" + random(1, 5) + ".ogg", me.x, me.y, me.z, string_to_number(parsed[1]), string_to_number(parsed[2]), string_to_number(parsed[3]), calculate_theta(facing), false);
				else if (parsed[0] == "draw" and parsed.length() >= 4) {
					if (parsed[1] != name)
						rvp.play_3d(parsed[2], me.x, me.y, me.z, string_to_number(parsed[3]), string_to_number(parsed[4]), string_to_number(parsed[5]), calculate_theta(facing), false);
				} else if (parsed[0] == "typing" and parsed.length() >= 4) {
					if (parsed[1] != name and v.hearotherskeyboardsound == 1)
						rvp.play_3d(parsed[2], me.x, me.y, me.z, string_to_number(parsed[3]), string_to_number(parsed[4]), string_to_number(parsed[5]), calculate_theta(facing), false);
				} else if (parsed[0] == "stereotyping" and parsed.length() >= 4) {
					if (parsed[1] != name and v.hearotherskeyboardsound == 1)
						if (string_to_number(parsed[3]) == me.x and string_to_number(parsed[4]) == me.y and string_to_number(parsed[5]) == me.z) rvp.play_3d(parsed[2], me.x, me.y, me.z, string_to_number(parsed[3]), string_to_number(parsed[4]), string_to_number(parsed[5]), calculate_theta(facing), false);
						else rvp.play_3d(parsed[2], me.x, me.y, me.z, string_to_number(parsed[3]), string_to_number(parsed[4]), string_to_number(parsed[5]), calculate_theta(facing), false);
				} else if (parsed[0] == "phonetyping" and parsed.length() >= 4) {
					if (parsed[1] != name and pv.hearotherskeyboardsound == 1)
						rvp.play_3d(parsed[2], me.x, me.y, me.z, string_to_number(parsed[3]), string_to_number(parsed[4]), string_to_number(parsed[5]), calculate_theta(facing), false);
				} else if (parsed[0] == "phonestereotyping" and parsed.length() >= 4) {
					if (parsed[1] != name and pv.hearotherskeyboardsound == 1)
						rvp.play_3d(parsed[2], me.x, me.y, me.z, string_to_number(parsed[3]), string_to_number(parsed[4]), string_to_number(parsed[5]), calculate_theta(facing), false);
				} else if (parsed[0] == "pmsound1" and parsed.length() >= 4) {
					if (parsed[1] != name and hearotherspmsound == 1)
						rvp.play_3d(parsed[2], me.x, me.y, me.z, string_to_number(parsed[3]), string_to_number(parsed[4]), string_to_number(parsed[5]), calculate_theta(facing), false);
				} else if (parsed[0] == "pmsound2" and parsed.length() >= 4) {
					if (parsed[1] != name and hearotherspmsound == 1)
						rvp.play_3d(parsed[2], me.x, me.y, me.z, string_to_number(parsed[3]), string_to_number(parsed[4]), string_to_number(parsed[5]), calculate_theta(facing), false);
				} else if (parsed[0] == "play_s" and parsed.length() >= 1)
					p.play_stationary(parsed[1], false);
				else if (parsed[0] == "rplay_s" and parsed.length() >= 1)
					rvp.play_stationary(parsed[1], false);
				else if (parsed[0] == "internal_play_s" and parsed.length() > 1) {
					string snd = parsed[1];
					internal.load(snd);
					internal.play();
				} else if (parsed[0] == "stoploop_s")
					svrsound.stop();
			}
			if (e.channel == 7) {
				string[] parsed = string_split(get_event_message(), " ", false);
				if (parsed[0] == "move" and parsed.length() >= 3) {
					me.x = string_to_number(parsed[1]);
					me.y = string_to_number(parsed[2]);
					me.z = string_to_number(parsed[3]);
					if (amoving == true) amoving = false;
					for (uint i = 0; i < automovers.length(); i++) {
						if (automovers[i].moving == true) automovers[i].moving = false;
					}
					for (uint i = 0; i < pautomovers.length(); i++) {
						if (pautomovers[i].moving == true) pautomovers[i].moving = false;
					}
					for (uint i = 0; i < icautomovers.length(); i++) {
						if (icautomovers[i].moving == true) icautomovers[i].moving = false;
					}
					for (uint i = 0; i < igautomovers.length(); i++) {
						if (igautomovers[i].moving == true) igautomovers[i].moving = false;
					}
					for (uint i = 0; i < itautomovers.length(); i++) {
						if (itautomovers[i].moving == true) itautomovers[i].moving = false;
					}
					if (dmoving == true) dmoving = false;
					for (uint i = 0; i < doors.length(); i++) {
						if (doors[i].moving == true) doors[i].moving = false;
					}
					for (uint i = 0; i < pdoors.length(); i++) {
						if (pdoors[i].moving == true) pdoors[i].moving = false;
					}
					for (uint i = 0; i < icdoors.length(); i++) {
						if (icdoors[i].moving == true) icdoors[i].moving = false;
					}
					for (uint i = 0; i < igdoors.length(); i++) {
						if (igdoors[i].moving == true) igdoors[i].moving = false;
					}
					for (uint i = 0; i < itdoors.length(); i++) {
						if (itdoors[i].moving == true) itdoors[i].moving = false;
					}
				}
			}
		}
	}
}
void mainloop() {
	revfxloop(me, camera);
	evloop();
	handscheck();
	if (winsound == 0) checarjanela();
	if (vanishing_platforms.length() > 0) vanishing_platformloop();
	if (forcefields.length() > 0) forcefieldloop();
	if (doors.length() > 0) doorcheckloop();
	if (pdoors.length() > 0) pdoorcheckloop();
	if (icdoors.length() > 0) icdoorcheckloop();
	if (itdoors.length() > 0) itdoorcheckloop();
	if (igdoors.length() > 0) igdoorcheckloop();
	if (automovers.length() > 0) automovercheckloop();
	if (pautomovers.length() > 0) pautomovercheckloop();
	if (icautomovers.length() > 0) icautomovercheckloop();
	if (itautomovers.length() > 0) itautomovercheckloop();
	if (igautomovers.length() > 0) igautomovercheckloop();
	checkloc();
	if (msounds.length() > 0) msoundcheckloop();
	if (timedsounds.length() > 0) timedsoundloop();
	if (timedmusics.length() > 0) timedmusicloop();
	if (timedtexts.length() > 0) timedtextloop();
	if (cppoints.length() > 0) checkpointloop();
	if (fire_starters.length() > 0) fire_starterloop();
	if (sources.length() > 0) sourcecheckloop();
	if (musics.length() > 0) musiccheckloop();
	if (urls.length() > 0) urlcheckloop();
	if (mapitems.length() > 0) mapitemloop();
	if (tpool1.elapsed >= npool1) {
		tpool1.restart();
		npool1 = random(30, 300);
		mpool.update_listener_3d(me.x, me.y, me.z, calculate_theta(facing));
		p.update_listener_3d(me.x, me.y, me.z, calculate_theta(facing));
		rvp.update_listener_3d(me.x, me.y, me.z, calculate_theta(facing));
		sourcepool.update_listener_3d(me.x, me.y, me.z, calculate_theta(facing));
		musicpool.update_listener_3d(me.x, me.y, me.z, calculate_theta(facing));
	}
	if (tpool2.elapsed >= npool2) {
		tpool2.restart();
		npool2 = random(30, 300);
		distpool.update_listener_3d(me.x, me.y, me.z, calculate_theta(facing));
		placedistpool.update_listener_3d(me.x, me.y, me.z, calculate_theta(facing));
		signpool.update_listener_3d(me.x, me.y, me.z, calculate_theta(facing));
		itempool.update_listener_3d(me.x, me.y, me.z, calculate_theta(facing));
	}
	if (voicechat == 1 and recording == true and rectimer.elapsed >= rectime) {
		p.play_stationary("voff.ogg", false);
		vc.stop(true, DIRECTORY_TEMP + "\\convert.ogg");
		file f;
		f.open(DIRECTORY_TEMP + "\\convert.ogg", "rb");
		send_reliable(peer_id, "voice " + spamtimer.elapsed + " " + f.read(), 3);
		f.close();
		file_delete(DIRECTORY_TEMP + "\\convert.ogg");
		recording = false;
		spamtimer.restart();
	}
	if (trackx != -1 and tracky != -1 and trackz != -1 and tracking != "") {
		if (trackingmode == 0 and trackingtimer.elapsed > 700) {
			trackingtimer.restart();
			p.play_3d("loctrack.ogg", me.x, me.y, me.z, trackx, tracky, trackz, calculate_theta(facing), false);
		} else if (trackingmode == 1 and trackingtimer.elapsed > 50 + get_3d_distance(me.x, me.y, me.z, trackx, tracky, trackz) * 5) {
			trackingtimer.restart();
			p.play_stationary("loctrack.ogg", false);
		}
		if (currentloc == tracking) {
			p.play_stationary("loctracked.ogg", false);
			trackx = -1; tracky = -1; trackz = -1; tracking = "";
		}
	}
	if (ttrackx != -1 and ttracky != -1 and ttrackz != -1 and ttracking != "") {
		if (trackingmode == 0 and trackingtimer.elapsed > 700) {
			trackingtimer.restart();
			p.play_3d("loctrack.ogg", me.x, me.y, me.z, ttrackx, ttracky, ttrackz, calculate_theta(facing), false);
		} else if (trackingmode == 1 and trackingtimer.elapsed > 50 + get_3d_distance(me.x, me.y, me.z, ttrackx, ttracky, ttrackz) * 5) {
			trackingtimer.restart();
			p.play_stationary("loctrack.ogg", false);
		}
		if (me.x == ttrackx and me.y == ttracky and me.z == ttrackz) {
			p.play_stationary("loctracked.ogg", false);
			ttrackx = -1; ttracky = -1; ttrackz = -1; ttracking = "";
		}
	}
	if (sleepmode == 1 and sleeptimer.elapsed >= 1000) {
		sleeptimer.restart();
		sleepmode = 0;
		sleeping.load("sleeping.ogg");
		sleeping.play_looped();
	}
	if (sleepmode == 0 and snoretimer.elapsed >= 5241) {
		snoretimer.restart();
		send_reliable(peer_id, "draw snore.ogg", 7);
	}
	if (sleepmode == 0 and dreaming == 1 and dreamtimer.elapsed >= dreamtime) {
		dreamtimer.restart();
		string[] ambs = string_split(allsounds, "\r\n", false);
		string temp = ambs[random(0, ambs.length() - 1)];
		dreamsound.close();
		dreamsound.load(temp + ".ogg");
		dreamsound.pan = random(-100, 100);
		dreamsound.volume = random(-30, 30);
		dreamsound.pitch = random(0, 200);
		dreamsound.play();
		int n1 = random(100, 5000);
		int n2 = dreamsound.length + random(0, 1000);
		dreamtime = random(n1, n2);
	}
	if (jumping == true)
		movetime = airtime;
	else
		movetime = walktime;
	if (in_map && !following && !looking && !frozen && playing) {
		fallloop();
		fallcheck();
		fallingloop();
	}
	if (connected) netloop();
}
void playcamera() {
	for (uint i = 0; i < players.length(); i++) {
		if (dcameraplayer == 0 and players[i].x == camera.x and players[i].y == camera.y and players[i].z == camera.z) {
			if (mfwc == 1) rvp.play_stationary("beacon.ogg", false);
			else rvp.play_3d("beacon.ogg", me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < mapitems.length(); i++) {
		if (dcameraitem == 0 and mapitems[i].map == mapname and mapitems[i].x == camera.x and mapitems[i].y == camera.y and mapitems[i].z == camera.z) {
			if (mfwc == 1) rvp.play_stationary("item.ogg", false);
			else rvp.play_3d("item.ogg", me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < doors.length(); i++) {
		if (dcameradoor == 0 and camera.x >= doors[i].mindx and camera.x <= doors[i].maxdx and camera.y >= doors[i].mindy and camera.y <= doors[i].maxdy and camera.z >= doors[i].mindz and camera.z <= doors[i].maxdz) {
			if (mfwc == 1) rvp.play_stationary(doors[i].ds, false);
			else rvp.play_3d(doors[i].ds, me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < pdoors.length(); i++) {
		if (dcamerapdoor == 0 and camera.x >= pdoors[i].mindx and camera.x <= pdoors[i].maxdx and camera.y >= pdoors[i].mindy and camera.y <= pdoors[i].maxdy and camera.z >= pdoors[i].mindz and camera.z <= pdoors[i].maxdz) {
			if (mfwc == 1) rvp.play_stationary(pdoors[i].ds, false);
			else rvp.play_3d(pdoors[i].ds, me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < icdoors.length(); i++) {
		if (dcameraicdoor == 0 and camera.x >= icdoors[i].mindx and camera.x <= icdoors[i].maxdx and camera.y >= icdoors[i].mindy and camera.y <= icdoors[i].maxdy and camera.z >= icdoors[i].mindz and camera.z <= icdoors[i].maxdz) {
			if (mfwc == 1) rvp.play_stationary(icdoors[i].ds, false);
			else rvp.play_3d(icdoors[i].ds, me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < itdoors.length(); i++) {
		if (dcameraitdoor == 0 and camera.x >= itdoors[i].mindx and camera.x <= itdoors[i].maxdx and camera.y >= itdoors[i].mindy and camera.y <= itdoors[i].maxdy and camera.z >= itdoors[i].mindz and camera.z <= itdoors[i].maxdz) {
			if (mfwc == 1) rvp.play_stationary(itdoors[i].ds, false);
			else rvp.play_3d(itdoors[i].ds, me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < igdoors.length(); i++) {
		if (dcameraigdoor == 0 and camera.x >= igdoors[i].mindx and camera.x <= igdoors[i].maxdx and camera.y >= igdoors[i].mindy and camera.y <= igdoors[i].maxdy and camera.z >= igdoors[i].mindz and camera.z <= igdoors[i].maxdz) {
			if (mfwc == 1) rvp.play_stationary(igdoors[i].ds, false);
			else rvp.play_3d(igdoors[i].ds, me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < automovers.length(); i++) {
		if (dcameraautomover == 0 and camera.x >= automovers[i].mindx and camera.x <= automovers[i].maxdx and camera.y >= automovers[i].mindy and camera.y <= automovers[i].maxdy and camera.z >= automovers[i].mindz and camera.z <= automovers[i].maxdz) {
			if (mfwc == 1) rvp.play_stationary(automovers[i].ds, false);
			else rvp.play_3d(automovers[i].ds, me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < pautomovers.length(); i++) {
		if (dcamerapautomover == 0 and camera.x >= pautomovers[i].mindx and camera.x <= pautomovers[i].maxdx and camera.y >= pautomovers[i].mindy and camera.y <= pautomovers[i].maxdy and camera.z >= pautomovers[i].mindz and camera.z <= pautomovers[i].maxdz) {
			if (mfwc == 1) rvp.play_stationary(pautomovers[i].ds, false);
			else rvp.play_3d(pautomovers[i].ds, me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < icautomovers.length(); i++) {
		if (dcameraicautomover == 0 and camera.x >= icautomovers[i].mindx and camera.x <= icautomovers[i].maxdx and camera.y >= icautomovers[i].mindy and camera.y <= icautomovers[i].maxdy and camera.z >= icautomovers[i].mindz and camera.z <= icautomovers[i].maxdz) {
			if (mfwc == 1) rvp.play_stationary(icautomovers[i].ds, false);
			else rvp.play_3d(icautomovers[i].ds, me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < itautomovers.length(); i++) {
		if (dcameraitautomover == 0 and camera.x >= itautomovers[i].mindx and camera.x <= itautomovers[i].maxdx and camera.y >= itautomovers[i].mindy and camera.y <= itautomovers[i].maxdy and camera.z >= itautomovers[i].mindz and camera.z <= itautomovers[i].maxdz) {
			if (mfwc == 1) rvp.play_stationary(itautomovers[i].ds, false);
			else rvp.play_3d(itautomovers[i].ds, me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < igautomovers.length(); i++) {
		if (dcameraigautomover == 0 and camera.x >= igautomovers[i].mindx and camera.x <= igautomovers[i].maxdx and camera.y >= igautomovers[i].mindy and camera.y <= igautomovers[i].maxdy and camera.z >= igautomovers[i].mindz and camera.z <= igautomovers[i].maxdz) {
			if (mfwc == 1) rvp.play_stationary(igautomovers[i].ds, false);
			else rvp.play_3d(igautomovers[i].ds, me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < automatic_travelpoints.length(); i++) {
		if (dcameraautomatic_travelpoint == 0 and camera.x >= automatic_travelpoints[i].mindx and camera.x <= automatic_travelpoints[i].maxdx and camera.y >= automatic_travelpoints[i].mindy and camera.y <= automatic_travelpoints[i].maxdy and camera.z >= automatic_travelpoints[i].mindz and camera.z <= automatic_travelpoints[i].maxdz) {
			if (mfwc == 1) rvp.play_stationary(automatic_travelpoints[i].ds, false);
			else rvp.play_3d(automatic_travelpoints[i].ds, me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < pautomatic_travelpoints.length(); i++) {
		if (dcamerapautomatic_travelpoint == 0 and camera.x >= pautomatic_travelpoints[i].mindx and camera.x <= pautomatic_travelpoints[i].maxdx and camera.y >= pautomatic_travelpoints[i].mindy and camera.y <= pautomatic_travelpoints[i].maxdy and camera.z >= pautomatic_travelpoints[i].mindz and camera.z <= pautomatic_travelpoints[i].maxdz) {
			if (mfwc == 1) rvp.play_stationary(pautomatic_travelpoints[i].ds, false);
			else rvp.play_3d(pautomatic_travelpoints[i].ds, me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < icautomatic_travelpoints.length(); i++) {
		if (dcameraicautomatic_travelpoint == 0 and camera.x >= icautomatic_travelpoints[i].mindx and camera.x <= icautomatic_travelpoints[i].maxdx and camera.y >= icautomatic_travelpoints[i].mindy and camera.y <= icautomatic_travelpoints[i].maxdy and camera.z >= icautomatic_travelpoints[i].mindz and camera.z <= icautomatic_travelpoints[i].maxdz) {
			if (mfwc == 1) rvp.play_stationary(icautomatic_travelpoints[i].ds, false);
			else rvp.play_3d(icautomatic_travelpoints[i].ds, me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < itautomatic_travelpoints.length(); i++) {
		if (dcameraitautomatic_travelpoint == 0 and camera.x >= itautomatic_travelpoints[i].mindx and camera.x <= itautomatic_travelpoints[i].maxdx and camera.y >= itautomatic_travelpoints[i].mindy and camera.y <= itautomatic_travelpoints[i].maxdy and camera.z >= itautomatic_travelpoints[i].mindz and camera.z <= itautomatic_travelpoints[i].maxdz) {
			if (mfwc == 1) rvp.play_stationary(itautomatic_travelpoints[i].ds, false);
			else rvp.play_3d(itautomatic_travelpoints[i].ds, me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < igautomatic_travelpoints.length(); i++) {
		if (dcameraigautomatic_travelpoint == 0 and camera.x >= igautomatic_travelpoints[i].mindx and camera.x <= igautomatic_travelpoints[i].maxdx and camera.y >= igautomatic_travelpoints[i].mindy and camera.y <= igautomatic_travelpoints[i].maxdy and camera.z >= igautomatic_travelpoints[i].mindz and camera.z <= igautomatic_travelpoints[i].maxdz) {
			if (mfwc == 1) rvp.play_stationary(igautomatic_travelpoints[i].ds, false);
			else rvp.play_3d(igautomatic_travelpoints[i].ds, me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < travelpoints.length(); i++) {
		if (dcameratravelpoint == 0 and camera.x >= travelpoints[i].mindx and camera.x <= travelpoints[i].maxdx and camera.y >= travelpoints[i].mindy and camera.y <= travelpoints[i].maxdy and camera.z >= travelpoints[i].mindz and camera.z <= travelpoints[i].maxdz) {
			if (mfwc == 1) rvp.play_stationary(travelpoints[i].ds, false);
			else rvp.play_3d(travelpoints[i].ds, me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < ptravelpoints.length(); i++) {
		if (dcameraptravelpoint == 0 and camera.x >= ptravelpoints[i].mindx and camera.x <= ptravelpoints[i].maxdx and camera.y >= ptravelpoints[i].mindy and camera.y <= ptravelpoints[i].maxdy and camera.z >= ptravelpoints[i].mindz and camera.z <= ptravelpoints[i].maxdz) {
			if (mfwc == 1) rvp.play_stationary(ptravelpoints[i].ds, false);
			else rvp.play_3d(ptravelpoints[i].ds, me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < ictravelpoints.length(); i++) {
		if (dcameraictravelpoint == 0 and camera.x >= ictravelpoints[i].mindx and camera.x <= ictravelpoints[i].maxdx and camera.y >= ictravelpoints[i].mindy and camera.y <= ictravelpoints[i].maxdy and camera.z >= ictravelpoints[i].mindz and camera.z <= ictravelpoints[i].maxdz) {
			if (mfwc == 1) rvp.play_stationary(ictravelpoints[i].ds, false);
			else rvp.play_3d(ictravelpoints[i].ds, me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < ittravelpoints.length(); i++) {
		if (dcameraittravelpoint == 0 and camera.x >= ittravelpoints[i].mindx and camera.x <= ittravelpoints[i].maxdx and camera.y >= ittravelpoints[i].mindy and camera.y <= ittravelpoints[i].maxdy and camera.z >= ittravelpoints[i].mindz and camera.z <= ittravelpoints[i].maxdz) {
			if (mfwc == 1) rvp.play_stationary(ittravelpoints[i].ds, false);
			else rvp.play_3d(ittravelpoints[i].ds, me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < igtravelpoints.length(); i++) {
		if (dcameraigtravelpoint == 0 and camera.x >= igtravelpoints[i].mindx and camera.x <= igtravelpoints[i].maxdx and camera.y >= igtravelpoints[i].mindy and camera.y <= igtravelpoints[i].maxdy and camera.z >= igtravelpoints[i].mindz and camera.z <= igtravelpoints[i].maxdz) {
			if (mfwc == 1) rvp.play_stationary(igtravelpoints[i].ds, false);
			else rvp.play_3d(igtravelpoints[i].ds, me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < vanishing_platforms.length(); i++) {
		if (dcameravp == 0 and vanishing_platforms[i].vanished == true and camera.x >= vanishing_platforms[i].minx and camera.x <= vanishing_platforms[i].maxx and camera.y >= vanishing_platforms[i].miny and camera.y <= vanishing_platforms[i].maxy and camera.z >= vanishing_platforms[i].minz and camera.z <= vanishing_platforms[i].maxz) {
			if (mfwc == 1) rvp.play_stationary("cameratile.ogg", false);
			else rvp.play_3d("cameratile.ogg", me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < forcefields.length(); i++) {
		if (dcameraff == 0 and forcefields[i].forcefielded == true and camera.x >= forcefields[i].minx and camera.x <= forcefields[i].maxx and camera.y >= forcefields[i].miny and camera.y <= forcefields[i].maxy and camera.z >= forcefields[i].minz and camera.z <= forcefields[i].maxz) {
			if (mfwc == 1) rvp.play_stationary("cameratile.ogg", false);
			else rvp.play_3d("cameratile.ogg", me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < teleporters.length(); i++) {
		if (dcameratp == 0 and camera.x >= teleporters[i].minx and camera.x <= teleporters[i].maxx and camera.y >= teleporters[i].miny and camera.y <= teleporters[i].maxy and camera.z >= teleporters[i].minz and camera.z <= teleporters[i].maxz) {
			if (mfwc == 1) rvp.play_stationary("cameratile.ogg", false);
			else rvp.play_3d("cameratile.ogg", me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	for (uint i = 0; i < signs.length(); i++) {
		if (dcamerasign == 0 and camera.x >= signs[i].minx and camera.x <= signs[i].maxx and camera.y >= signs[i].miny and camera.y <= signs[i].maxy and camera.z >= signs[i].minz and camera.z <= signs[i].maxz) {
			if (mfwc == 1) rvp.play_stationary(signs[i].signsound, false);
			else rvp.play_3d(signs[i].signsound, me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
		}
	}
	if (me.x == camera.x and me.y == camera.y and me.z == camera.z) {
		if (mfwc == 1) rvp.play_stationary("beacon.ogg", false);
		else rvp.play_3d("beacon.ogg", me.x, me.y, me.z, camera.x, camera.y, camera.z, calculate_theta(facing), false);
	}
	if (get_tile_at(camera.x, camera.y, camera.z) == "" or get_tile_at(camera.x, camera.y, camera.z) == "air") {
		if (mfwc == 1) rvp.play_stationary("cameraair.ogg", false);
		else rvp.play_3d("cameraair.ogg", me.x, me.y, me.z, round(camera.x, 0), round(camera.y, 0), camera.z, calculate_theta(facing), false);
	} else if (get_tile_at(camera.x, camera.y, camera.z) == "hazard") {
		if (mfwc == 1) rvp.play_stationary("camerahazard.ogg", false);
		else rvp.play_3d("camerahazard.ogg", me.x, me.y, me.z, round(camera.x, 0), round(camera.y, 0), camera.z, calculate_theta(facing), false);
	} else if (string_contains(get_tile_at(camera.x, camera.y, camera.z), "wall", 1) > -1 or string_contains(get_tile_at(camera.x, camera.y, camera.z), "breakable", 1) > -1) {
		if (mfwc == 1) rvp.play_stationary(get_tile_at(camera.x, camera.y, camera.z) + ".ogg", false);
		else rvp.play_3d(get_tile_at(camera.x, camera.y, camera.z) + ".ogg", me.x, me.y, me.z, round(camera.x, 0), round(camera.y, 0), camera.z, calculate_theta(facing), false);
	} else {
		if (mfwc == 1) rvp.play_stationary(get_tile_at(camera.x, camera.y, camera.z) + "step" + random(1, 5) + ".ogg", false);
		else rvp.play_3d(get_tile_at(camera.x, camera.y, camera.z) + "step" + random(1, 5) + ".ogg", me.x, me.y, me.z, round(camera.x, 0), round(camera.y, 0), camera.z, calculate_theta(facing), false);
	}
}
void fallloop() {
	if (jumptimer.elapsed > jumptime and jumping == true) {
		jumptimer.restart();
		if (jumpup == 1) {
			if (me.z <= jumplandz + 5) {
				me.z++;
				send_reliable(peer_id, "move " + me.x + " " + me.y + " " + me.z, 8);
				if (get_tile_at(me.x, me.y, me.z) != "" and get_tile_at(me.x, me.y, me.z) != "air")
					jumpup = 0;
			} else
				jumpup = 0;
		} else if (jumpup == 0) {
			if (me.z > jumplandz) {
				me.z--;
				send_reliable(peer_id, "move " + me.x + " " + me.y + " " + me.z, 8);
				if (get_tile_at(me.x, me.y, me.z) != "" and get_tile_at(me.x, me.y, me.z) != "air") {
					rvp.play_stationary(get_tile_at(me.x, me.y, me.z) + "land.ogg", false);
					send_reliable(peer_id, "draw " + get_tile_at(me.x, me.y, me.z) + "land.ogg", 7);
					jumping = false;
				}
			} else {
				if (get_tile_at(me.x, me.y, me.z) == "" or get_tile_at(me.x, me.y, me.z) == "air" and frozen == false and in_map) {
					falling = true;
					falldistance = 0;
					falltimer.restart();
					jumping = false;
					return;
				}
				rvp.play_stationary(get_tile_at(me.x, me.y, me.z) + "land.ogg", false);
				send_reliable(peer_id, "draw " + get_tile_at(me.x, me.y, me.z) + "land.ogg", 7);
				jumping = false;
				movecheck();
			}
		}
	}
}
void fallcheck() {
	if (!systemmoving and dmoving == false and amoving == false and in_map) {
		if (get_tile_at(me.x, me.y, me.z) == "" and falling == false and playing == true and jumping == false or get_tile_at(me.x, me.y, me.z) == "air" and falling == false and jumping == false and playing == true) {
			falling = true;
			falldistance = 0;
			falltimer.restart();
			rvp.play_stationary("fall" + random(1, 3) + ".ogg", false);
			send_reliable(peer_id, "draw fall" + random(1, 3) + ".ogg", 7);
			send_reliable(peer_id, "fallstart", 8);
		}
	}
}
void fallingloop() {
	if (!systemmoving and dmoving == false and amoving == false) {
		if (falling == true and falltimer.elapsed > falltime) {
			if (get_tile_at(me.x, me.y, me.z) != "" and get_tile_at(me.x, me.y, me.z) != "air") {
				falling = false;
				if (!in_map) falldistance = 0;
				if (falldistance < 5) {
					send_reliable(peer_id, "fallstop", 8);
					rvp.play_stationary(get_tile_at(me.x, me.y, me.z) + "land.ogg", false);
					send_reliable(peer_id, "draw " + get_tile_at(me.x, me.y, me.z) + "land.ogg", 7);
					send_reliable(peer_id, "move " + me.x + " " + me.y + " " + me.z, 8);
					falling = false;
					movecheck();
				} else {
					send_reliable(peer_id, "fallstop", 8);
					rvp.play_stationary(get_tile_at(me.x, me.y, me.z) + "fall.ogg", false);
					send_reliable(peer_id, "draw " + get_tile_at(me.x, me.y, me.z) + "fall.ogg", 7);
					send_reliable(peer_id, "move " + me.x + " " + me.y + " " + me.z, 8);
					send_reliable(peer_id, "hardland " + falldistance, 8);
					falling = false;
					movecheck();
				}
				return;
			}
			falltimer.restart();
			falldistance++;
			me.z--;
			send_reliable(peer_id, "move " + me.x + " " + me.y + " " + me.z, 8);
			movecheck();
		}
	}
}
string read(string filename) {
	file f;
	f.open(filename, "rb");
	return f.read();
}
string decrypt_and_read(string filename) {
	file f;
	f.open(filename, "rb");
	return string_decrypt(f.read(), "y3U/@/IJho6L4X%_2)CcDhCjGTxRH(on3Nmw4z!UFfrDpD$Q)GlMqnKyN^0$,WIae8XSX<.2VNInTB<ml=wbFkP_64^Ay*BDYf6SQ1tJD)v`spO`cZFGS((7*U&>Z$n@>!1&*%Jf4+QNCTV?yCX7d*qeNAHw1p+<kl6l6ZVGYeSU/gG/Tv?m!,pfb&XKFbZVzHP?%4f&fQWR!._$T,p6DHsSwW($??Ok+2SEnb76zYhz0lSIFv)8ISM`4~N.yvSa=Y3bnzk<%rF%<%Zf%9Z5)C53EADs4$E?%Uh1nVi)goFn,s5Sbp*#/P~&F2)B+aczw)XQHq!=P5M236@a%M7KY%w^~pHKTRbRGBp8^EAdjl!+CXn9jXiMzl");
}
void playermapmenu(string[] users) {
	get_characters();
	string cl, char, multichar, test;
	speak("users menu");
	int counter = 0;
	while (true) {
		wait(5);
		mainloop();
		if (navtime.elapsed > 1000 and multichar != "")
			multichar = "";
		string c = get_characters().lower();
		if (c != "" and multichar != c) {
			navtime.restart();
			multichar += c;
		}
		if (multichar != "" and c != "" and multichar != " " and c != " ") {
			multichar = multichar.lower();
			bool found = false;
			for (uint i = counter; i < users.length(); i++) {
				if (i == counter) continue;
				test = users[i];
				test = test.lower();
				if (stringleft(test, multichar.length()) == multichar) {
					if (stringleft(users[counter], multichar.length()).lower() == multichar and multichar.length() > 1) {
						found = true;
						break;
					}
					if (counter < i)
						counter = i;
					else if (counter > i)
						counter = i;
					speak(users[counter]);
					found = true;
					break;
				} else continue;
			}
			if (found == false) {
				multichar = multichar.lower();
				for (uint i = 0; i < users.length(); i++) {
					test = users[i];
					test = test.lower();
					if (stringleft(test, multichar.length()) == multichar) {
						if (stringleft(users[counter], multichar.length()).lower() == multichar and multichar.length() > 1) {
							found = true;
							break;
						}
						if (counter < i)
							counter = i;
						else if (counter > i)
							counter = i;
						speak(users[counter]);
						found = true;
						break;
					} else continue;
				}
			}
			if (!found)
				speak("No such player exists");
		}
		if (key_pressed(KEY_UP)) {
			if (users.length() == 1) {
				speak(users[0]);
				counter = 0;
			} else if (counter > 0) {
				counter--;
				speak(users[counter]);
			}
		}
		if (key_pressed(KEY_DOWN)) {
			if (users.length() == 1) {
				speak(users[0]);
				counter = 0;
			} else if (counter < users.length() - 1) {
				counter++;
				speak(users[counter]);
			}
		}
		if (counter > 0) {
			if (key_pressed(KEY_F1) and users[counter] != "" and counter <= users.length() - 1) {
				speak(users[counter] + " copyed to clipboard");
				clipboard_copy_text(users[counter]);
			}
			if (key_pressed(KEY_F2) and users[counter] != "" and counter <= users.length() - 1) {
				string message = input("Message", "enter the message that you want to send to " + users[counter], multiline = true);
				if (message != "" and !is_eloquence_crash_word(message) and get_sequence(message, true) <= 3) send_reliable(peer_id, "/pm " + users[counter] + " " + message, 1);
			}
			if (key_pressed(KEY_F3))send_reliable(peer_id, "j1 " + users[counter], 0);
			if (key_pressed(KEY_F4))send_reliable(peer_id, "j2 " + users[counter], 0);
			if (key_pressed(KEY_F5) and users[counter] != "" and counter <= users.length() - 1) send_reliable(peer_id, "stats " + users[counter], 0);
			if (key_pressed(KEY_F6))send_reliable(peer_id, "j3 " + users[counter], 0);
			if (key_pressed(KEY_F7))send_reliable(peer_id, "look " + users[counter], 0);
			if (key_pressed(KEY_F8))send_reliable(peer_id, "status " + users[counter], 0);
			if (shift_is_down()) {
				if (key_pressed(KEY_F9)) {
					string stuff = v.input("Enter your tts message");
					if (stuff != "") {
						if (stuff.length() > 256)
							speak("limit is 256 characters");
						else {
							string msg = ttsv.speak_to_memory(stuff);
							send_reliable(peer_id, "ptts " + stuff.length() + " " + users[counter] + " " + try_memset(msg), 3);
							//if (savettschats == 1)
								//file_copy(DIRECTORY_TEMP + "\\ttsmsg.ogg", "voices/tts message " + DATE_WEEKDAY_NAME + ", " + DATE_MONTH_NAME + "-" + DATE_DAY + "-" + DATE_YEAR + ", " + TIME_HOUR + " " + TIME_MINUTE + " " + TIME_SECOND + ".ogg", true);
							//file_delete(DIRECTORY_TEMP + "/ttsmsg.ogg");
						}
					}
				}
			}
			if (key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT)) {
				if (key_pressed(KEY_F9) and spamtimer.elapsed >= spamtime and voicechat == 1) {
					if (recording == false) {
						urc = users[counter];
						spamtimer.restart();
						vc.record();
						p.play_stationary("von.ogg", false);
						recording = true;
						rectimer.restart();
					} else if (recording == true and holdv == 0) {
						p.play_stationary("voff.ogg", false);
						vc.stop(true, DIRECTORY_TEMP + "\\convert.ogg");
						file f;
						f.open(DIRECTORY_TEMP + "\\convert.ogg", "rb");
						send_reliable(peer_id, "pvoice " + spamtimer.elapsed + " " + urc + " " + f.read(), 3);
						f.close();
						file_delete(DIRECTORY_TEMP + "\\convert.ogg");
						recording = false;
						spamtimer.restart();
					}
				}
				if (recording == true and rectimer.elapsed >= rectime) {
					p.play_stationary("voff.ogg", false);
					vc.stop(true, DIRECTORY_TEMP + "\\convert.ogg");
					file f;
					f.open(DIRECTORY_TEMP + "\\convert.ogg", "rb");
					send_reliable(peer_id, "pvoice " + spamtimer.elapsed + " " + urc + " " + f.read(), 3);
					f.close();
					file_delete(DIRECTORY_TEMP + "\\convert.ogg");
					recording = false;
					spamtimer.restart();
				}
				if (key_released(KEY_F9) and recording == true and voicechat == 1 and holdv == 1) {
					p.play_stationary("voff.ogg", false);
					vc.stop(true, DIRECTORY_TEMP + "\\convert.ogg");
					file f;
					f.open(DIRECTORY_TEMP + "\\convert.ogg", "rb");
					send_reliable(peer_id, "pvoice " + spamtimer.elapsed + " " + urc + " " + f.read(), 3);
					f.close();
					file_delete(DIRECTORY_TEMP + "\\convert.ogg");
					recording = false;
					spamtimer.restart();
				}
			}
		}
		if (key_pressed(KEY_RETURN) and counter <= users.length() - 1 and users[counter] != "") {
			if (counter > 0) {
				p.play_stationary("tracked.ogg", false);
				speak("tracking " + users[counter]);
				tracking = users[counter];
				return;
			} else {
				speak("tracking stopped");
				tracking = "";
				return;
			}
		}
		if (key_pressed(KEY_ESCAPE)) {
			speak("canceled");
			return;
		}
	}
	return;
}
void playermenu(string[] users) {
	get_characters();
	string cl, char, multichar, test;
	speak("players menu");
	int counter = 0;
	while (true) {
		wait(5);
		mainloop();
		if (navtime.elapsed > 1000 and multichar != "")
			multichar = "";
		string c = get_characters().lower();
		if (c != "" and multichar != c) {
			navtime.restart();
			multichar += c;
		}
		if (multichar != "" and c != "" and multichar != " " and c != " ") {
			multichar = multichar.lower();
			bool found = false;
			for (uint i = counter; i < users.length(); i++) {
				if (i == counter) continue;
				test = users[i];
				test = test.lower();
				if (stringleft(test, multichar.length()) == multichar) {
					if (stringleft(users[counter], multichar.length()).lower() == multichar and multichar.length() > 1) {
						found = true;
						break;
					}
					if (counter < i)
						counter = i;
					else if (counter > i)
						counter = i;
					speak(users[counter]);
					found = true;
					break;
				} else continue;
			}
			if (found == false) {
				multichar = multichar.lower();
				for (uint i = 0; i < users.length(); i++) {
					test = users[i];
					test = test.lower();
					if (stringleft(test, multichar.length()) == multichar) {
						if (stringleft(users[counter], multichar.length()).lower() == multichar and multichar.length() > 1) {
							found = true;
							break;
						}
						if (counter < i)
							counter = i;
						else if (counter > i)
							counter = i;
						speak(users[counter]);
						found = true;
						break;
					} else continue;
				}
			}
			if (!found)
				speak("No such player exists");
		}
		if (key_pressed(KEY_UP)) {
			if (users.length() == 1) {
				speak(users[0]);
				counter = 0;
			} else if (counter > 0) {
				counter--;
				speak(users[counter]);
			}
		}
		if (key_pressed(KEY_DOWN)) {
			if (users.length() == 1) {
				speak(users[0]);
				counter = 0;
			} else if (counter < users.length() - 1) {
				counter++;
				speak(users[counter]);
			}
		}
		if (key_pressed(KEY_F1) and counter <= users.length() - 1 and users[counter] != "") {
			string[] u = string_split(users[counter], " ", true);
			if (shift_down && assistant) {
				string rr = input("Respond", "Type the message to respond to " + u[0], multiline = true);
				if (rr == "") continue;
				sendcommand("/respond " + u[0] + " " + rr);
				continue;
			}
			speak(u[0] + " copyed to clipboard");
			clipboard_copy_text(u[0]);
		}
		if (key_pressed(KEY_F2) and users[counter] != "" and counter <= users.length() - 1) {
			string[] u = string_split(users[counter], " ", true);
			string message = input("PM", "enter the message that you want to send to " + u[0], multiline = true);
			if (message != "" and !is_eloquence_crash_word(message) and get_sequence(message, true) <= 3) send_reliable(peer_id, "/pm " + u[0] + " " + message, 1);
		}
		if (key_pressed(KEY_F3)) {
			string[] u = string_split(users[counter], " ", true);
			send_reliable(peer_id, "j1 " + u[0], 0);
		}
		if (key_pressed(KEY_F4)) {
			string[] u = string_split(users[counter], " ", true);
			send_reliable(peer_id, "j2 " + u[0], 0);
		}
		if (key_pressed(KEY_F5) and users[counter] != "" and counter <= users.length() - 1) {
			string[] u = string_split(users[counter], " ", true);
			send_reliable(peer_id, "stats " + u[0], 0);
		}
		if (key_pressed(KEY_F6)) {
			string[] u = string_split(users[counter], " ", true);
			send_reliable(peer_id, "j3 " + u[0], 0);
		}
		if (key_pressed(KEY_F7)) {
			string[] u = string_split(users[counter], " ", true);
			send_reliable(peer_id, "look " + u[0], 0);
		}
		if (key_pressed(KEY_F8)) {
			string[] u = string_split(users[counter], " ", true);
			send_reliable(peer_id, "status " + u[0], 0);
		}
		if (shift_is_down()) {
			if (key_pressed(KEY_F9)) {
				string stuff = v.input("Enter your tts message");
				if (stuff != "") {
					if (stuff.length() > 256)
						speak("limit is 256 characters");
					else {
						string msg = ttsv.speak_to_memory(stuff);
						string[] u = string_split(users[counter], " ", true);
						send_reliable(peer_id, "ptts " + stuff.length() + " " + u[0] + " " + try_memset(msg), 3);
						//if (savettschats == 1)
							//file_copy(DIRECTORY_TEMP + "\\ttsmsg.ogg", "voices/tts message " + DATE_WEEKDAY_NAME + ", " + DATE_MONTH_NAME + "-" + DATE_DAY + "-" + DATE_YEAR + ", " + TIME_HOUR + " " + TIME_MINUTE + " " + TIME_SECOND + ".ogg", true);
						//file_delete(DIRECTORY_TEMP + "/ttsmsg.ogg");
					}
				}
			}
		}
		if (key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT)) {
			if (key_pressed(KEY_F9) and spamtimer.elapsed >= spamtime and voicechat == 1) {
				if (recording == false) {
					string[] u = string_split(users[counter], " ", true);
					urc = u[0];
					spamtimer.restart();
					vc.record();
					p.play_stationary("von.ogg", false);
					recording = true;
					rectimer.restart();
				} else if (recording == true and holdv == 0) {
					p.play_stationary("voff.ogg", false);
					vc.stop(true, DIRECTORY_TEMP + "\\convert.ogg");
					file f;
					f.open(DIRECTORY_TEMP + "\\convert.ogg", "rb");
					send_reliable(peer_id, "pvoice " + spamtimer.elapsed + " " + urc + " " + f.read(), 3);
					f.close();
					file_delete(DIRECTORY_TEMP + "\\convert.ogg");
					recording = false;
					spamtimer.restart();
				}
			}
			if (recording == true and rectimer.elapsed >= rectime) {
				p.play_stationary("voff.ogg", false);
				vc.stop(true, DIRECTORY_TEMP + "\\convert.ogg");
				file f;
				f.open(DIRECTORY_TEMP + "\\convert.ogg", "rb");
				send_reliable(peer_id, "pvoice " + spamtimer.elapsed + " " + urc + " " + f.read(), 3);
				f.close();
				file_delete(DIRECTORY_TEMP + "\\convert.ogg");
				recording = false;
				spamtimer.restart();
			}
			if (key_released(KEY_F9) and recording == true and voicechat == 1 and holdv == 1) {
				p.play_stationary("voff.ogg", false);
				vc.stop(true, DIRECTORY_TEMP + "\\convert.ogg");
				file f;
				f.open(DIRECTORY_TEMP + "\\convert.ogg", "rb");
				send_reliable(peer_id, "pvoice " + spamtimer.elapsed + " " + urc + " " + f.read(), 3);
				f.close();
				file_delete(DIRECTORY_TEMP + "\\convert.ogg");
				recording = false;
				spamtimer.restart();
			}
		}
		if (control_is_down() and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT)) {
			if (key_pressed(KEY_T)) {
				string[] u = string_split(users[counter], " ", true);
				send_reliable(peer_id, "/trust " + u[0], 1);
			}
			if (key_pressed(KEY_M)) {
				string[] u = string_split(users[counter], " ", true);
				send_reliable(peer_id, "/mute " + u[0], 1);
			}
		}
		if (control_is_down() and shift_is_down()) {
			if (key_pressed(KEY_T)) {
				string[] u = string_split(users[counter], " ", true);
				send_reliable(peer_id, "/untrust " + u[0], 1);
			}
			if (key_pressed(KEY_M)) {
				string[] u = string_split(users[counter], " ", true);
				send_reliable(peer_id, "/unmute " + u[0], 1);
			}
		}
		if (key_pressed(KEY_RETURN) and counter <= users.length() - 1 and users[counter] != "")
			return;
		if (key_pressed(KEY_ESCAPE)) {
			speak("canceled");
			return;
		}
	}
	return;
}
void tell_where(int x, int y, int z, string soundname, bool include_locations = false) {
	if (z > me.z)
		go = "above, ";
	else if (z < me.z)
		go = "below, ";
	go4 = calculate_x_y_string(calculate_x_y_angle(me.x, me.y, x, y, facing));
	string boing = "";
	if (include_locations == true)
		boing = " in " + get_zone_at(x, y, z) + " ";
	int dist = get_3d_distance(me.x, me.y, me.z, x, y, z);
	if (dcoordinates == 0) {
		if (d2dsupport == 0)
			speak(go + go4 + " (" + dist + " tiles away) " + boing + "at " + x + ", " + y + ", " + z);
		else
			speak(go + go4 + " (" + dist + " tiles away) " + boing + "at " + x + ", " + z);
	} else if (dcoordinates == 1) speak(go + go4 + " (" + dist + " tiles away) " + boing + "");
	p.play_3d(soundname + ".ogg", me.x, me.y, me.z, x, y, z, calculate_theta(facing), false);
	go = "";
}
void fade_all(sound_pool@ handle, sound_pool@ handle2, sound_pool@ handle3, sound_pool@ handle4, sound_pool@ handle5, sound_pool@ handle6, sound_pool@ handle7, sound_pool@ handle8, double time = 0.25, double minvol = -40) {
	for (double current = 0; current > minvol; current -= time) {
		for (uint x = 0; x < handle.items.length(); x++) {
			if (@handle.items[x].handle == null)
				break;
			if (handle.items[x].handle.playing == false)
				break;
			handle.items[x].handle.volume = handle.items[x].handle.volume - time;
		}
		for (uint y = 0; y < handle2.items.length(); y++) {
			if (@handle2.items[y].handle == null)
				break;
			if (handle2.items[y].handle.playing == false)
				break;
			handle2.items[y].handle.volume = handle2.items[y].handle.volume - time;
		}
		for (uint z = 0; z < handle3.items.length(); z++) {
			if (@handle3.items[z].handle == null)
				break;
			if (handle3.items[z].handle.playing == false)
				break;
			handle3.items[z].handle.volume = handle3.items[z].handle.volume - time;
		}
		for (uint w = 0; w < handle4.items.length(); w++) {
			if (@handle4.items[w].handle == null)
				break;
			if (handle4.items[w].handle.playing == false)
				break;
			handle4.items[w].handle.volume = handle4.items[w].handle.volume - time;
		}
		for (uint sourcesounds = 0; sourcesounds < handle5.items.length(); sourcesounds++) {
			if (@handle5.items[sourcesounds].handle == null)
				break;
			if (handle5.items[sourcesounds].handle.playing == false)
				break;
			handle5.items[sourcesounds].handle.volume = handle5.items[sourcesounds].handle.volume - time;
		}
		for (uint musicsounds = 0; musicsounds < handle6.items.length(); musicsounds++) {
			if (@handle6.items[musicsounds].handle == null)
				break;
			if (handle6.items[musicsounds].handle.playing == false)
				break;
			handle6.items[musicsounds].handle.volume = handle6.items[musicsounds].handle.volume - time;
		}
		for (uint signsounds = 0; signsounds < handle7.items.length(); signsounds++) {
			if (@handle7.items[signsounds].handle == null)
				break;
			if (handle7.items[signsounds].handle.playing == false)
				break;
			handle7.items[signsounds].handle.volume = handle7.items[signsounds].handle.volume - time;
		}
		for (uint mapitemsounds = 0; mapitemsounds < handle8.items.length(); mapitemsounds++) {
			if (@handle8.items[mapitemsounds].handle == null)
				break;
			if (handle8.items[mapitemsounds].handle.playing == false)
				break;
			handle8.items[mapitemsounds].handle.volume = handle8.items[mapitemsounds].handle.volume - time;
		}
		wait(5);
	}
	handle.destroy_all();
	handle2.destroy_all();
	handle3.destroy_all();
	handle4.destroy_all();
	handle5.destroy_all();
	handle6.destroy_all();
	handle7.destroy_all();
	handle8.destroy_all();
}
double convert_to_pan(double m1, double m2) {
	try {
		return (m1 * 100 / m2) - 50;
	} catch {
		return 0;
	}
}
void fade_pool_out(sound_pool@ pool, bool destroy = true) {
	int volume = 0;
	while (volume > -20) {
		volume--;
		for (uint i = 0; i < pool.items.length(); i++) {
			if (@pool.items[i].handle != null)
				pool.items[i].handle.volume = volume;
		}
		wait(5);
	}
	if (destroy)
		pool.destroy_all();
}
void fade_pool_in(sound_pool@ pool) {
	int volume = -20;
	while (volume < 0) {
		volume++;
		for (uint i = 0; i < pool.items.length(); i++) {
			if (@pool.items[i].handle != null)
				pool.items[i].handle.volume = volume;
		}
		wait(5);
	}
}
void beep(int wavetype, string freqs, int ms) {
	if (ms <= 0 || ms > 5000) return;
	bleeper.waveform_type = wavetype;
	bleeper.set_edge_fades(0, 0);
	bleeper.volume = -10;
	//bleeper.freq(freqs, ms);
	@bleepy = bleeper.write_wave_sound();
	bleeper.reset();
	bleepy.play();
}
string get_script_path() {
	string scriptpath;
	if (SCRIPT_COMPILED == false)
		scriptpath = SCRIPT_CURRENT_FILE;
	else
		scriptpath = SCRIPT_EXECUTABLE;
	return scriptpath;
}
string get_game_path() {
	string game_path;
	if (SCRIPT_COMPILED == false)game_path = string_replace(get_script_path(), "\\uw.bgt", "", true);
	else game_path = string_replace(get_script_path(), "\\uw.exe", "", true);
	return game_path;
}
void checarjanela() {
	if (is_game_window_active() == true)
		set_sound_master_volume(mvol);
	else set_sound_master_volume(-100);
}
void exitgame(bool return_to_menu = true) {
	send_reliable(0, "close", 0);
	client::destruct();
	reset_network();
	if (autologin == 1) exit();
	m.reset(true);
	if (return_to_menu) mainmenu();
	players.resize(0);
}
void checkloc() {
	string locate = get_zone_at(me.x, me.y, me.z);
	if (locate != "") {
		if (locate != currentloc) {
			if (zonestatus == 1) speak(locate);
			currentloc = locate;
		}
	} else {
		locate = "unknown area";
		if (currentloc != locate)
			currentloc = locate;
	}
}
void serverbox(int mode = 0, int maxlength = -1, int autosend = 0, int keypresses = -1, string sendtext = "server_box", string text = "enter text") {
	key_hold back(KEY_BACK, 50, 50);
	key_hold back2(KEY_DELETE, 50, 50);
	inbox = true;
	string message;
	speak(text);
	get_characters();
	int total_keypresses = 0;
	while (true) {
		wait(5);
		mainloop();
		string char = get_characters();
		if (key_pressed(KEY_TAB))
			speak(text);
		if ((key_down(KEY_LMENU) or key_down(KEY_RMENU)) and (key_pressed(KEY_LSHIFT) or key_pressed(KEY_RSHIFT))) {
			if (klang.length() < 1)
				speak("add a keyboard language first");
			else {
				klangpos += 1;
				if (klangpos >= klang.length())
					klangpos = 0;
				currentkeyboardlangfile = string_replace(klang[klangpos], ".lng", "", true);
				keyboarddata = file_get_contents("keyboard_languages\\" + currentkeyboardlangfile + ".lng");
				speak(string_replace(klang[klangpos], ".lng", "", true));
			}
		}
		if (key_pressed(KEY_F1)) {
			v.repeat = v.repeat == 1 ? 0 : 1;
			p.play_stationary((v.repeat == 1 ? "toggleon" : "toggleoff") + ".ogg", false);
			send_reliable(peer_id, "draw " + (v.repeat == 1 ? "toggleon" : "toggleoff") + ".ogg", 7);
			speak("Character repeat " + (v.repeat == 1 ? "enabled" : "disabled"));
		}
		if (key_pressed(KEY_F2)) {
			if (v.caps == 1) {
				v.caps = 2;
				p.play_stationary("cap.ogg", false);
				send_reliable(peer_id, "draw cap.ogg", 7);
				speak("Beep for uppercase letters.");
				continue;
			}
			if (v.caps == 2) {
				v.caps = 3;
				p.play_stationary("toggleon.ogg", false);
				send_reliable(peer_id, "draw toggleon.ogg", 7);
				speak("Ignore uppercase letters.");
				continue;
			}
			if (v.caps == 3) {
				v.caps = 1;
				p.play_stationary("toggleon.ogg", false);
				send_reliable(peer_id, "draw toggleon.ogg", 7);
				speak("Speak uppercase letters.");
				continue;
			}
		}
		if (key_pressed(KEY_F3)) {
			if (v.keyboardclicks == 0) {
				p.play_stationary("toggleon.ogg", false);
				send_reliable(peer_id, "draw toggleon.ogg", 7);
				speak("keyboard clicks enabled");
				v.keyboardclicks = 1;
			} else {
				p.play_stationary("toggleoff.ogg", false);
				send_reliable(peer_id, "draw toggleoff.ogg", 7);
				speak("keyboard clicks disabled");
				v.keyboardclicks = 0;
			}
		}
		if (key_pressed(KEY_F4)) {
			if (v.keyboardtheme == 1) {
				rvp.play_stationary("keyboard2type" + random(1, 10) + ".ogg", false);
				send_reliable(peer_id, "draw keyboard2type" + random(1, 10) + ".ogg", 7);
				v.keyboardtheme = 2;
				speak("theme" + v.keyboardtheme + "");
			} else if (v.keyboardtheme == 2) {
				rvp.play_stationary("keyboard3type" + random(1, 5) + ".ogg", false);
				send_reliable(peer_id, "draw keyboard3type" + random(1, 5) + ".ogg", 7);
				v.keyboardtheme = 3;
				speak("theme" + v.keyboardtheme + "");
			} else if (v.keyboardtheme == 3) {
				rvp.play_stationary("keyboard4type" + random(1, 3) + ".ogg", false);
				send_reliable(peer_id, "draw keyboard4type" + random(1, 3) + ".ogg", 7);
				v.keyboardtheme = 4;
				speak("theme" + v.keyboardtheme + "");
			} else if (v.keyboardtheme == 4) {
				rvp.play_stationary("keyboard5key" + random(1, 4) + ".ogg", false);
				send_reliable(peer_id, "draw keyboard5key" + random(1, 4) + ".ogg", 7);
				v.keyboardtheme = 5;
				speak("theme" + v.keyboardtheme + "");
			} else if (v.keyboardtheme == 5) {
				rvp.play_stationary("keyboard6type" + random(1, 4) + ".ogg", false);
				send_reliable(peer_id, "draw keyboard6type" + random(1, 4) + ".ogg", 7);
				v.keyboardtheme = 6;
				speak("theme" + v.keyboardtheme + "");
			} else if (v.keyboardtheme == 6) {
				rvp.play_stationary("keyboard7.ogg", false);
				send_reliable(peer_id, "draw keyboard7.ogg", 7);
				v.keyboardtheme = 7;
				speak("theme" + v.keyboardtheme + "");
			} else if (v.keyboardtheme == 7) {
				rvp.play_stationary("keyboard8key" + random(1, 4) + ".ogg", false);
				send_reliable(peer_id, "draw keyboard8key" + random(1, 4) + ".ogg", 7);
				v.keyboardtheme = 8;
				speak("theme" + v.keyboardtheme + "");
			} else if (v.keyboardtheme == 8) {
				rvp.play_stationary("keyboard9type.ogg", false);
				send_reliable(peer_id, "draw keyboard9type.ogg", 7);
				v.keyboardtheme = 9;
				speak("theme" + v.keyboardtheme + "");
			} else if (v.keyboardtheme == 9) {
				rvp.play_stationary("phonekeytype.ogg", false);
				send_reliable(peer_id, "draw phonekeytype.ogg", 7);
				v.keyboardtheme = 10;
				speak("theme" + v.keyboardtheme + "");
			} else if (v.keyboardtheme == 11) {
				rvp.play_stationary("keyboard10type" + random(1, 10) + ".ogg", false);
				send_reliable(peer_id, "draw keyboard10type" + random(1, 10) + ".ogg", 7);
				v.keyboardtheme = 11;
				speak("theme" + v.keyboardtheme + "");
			} else if (v.keyboardtheme == 12) {
				rvp.play_stationary("keyboard1type" + random(1, 10) + ".ogg", false);
				send_reliable(peer_id, "draw keyboard1type" + random(1, 10) + ".ogg", 7);
				v.keyboardtheme = 12;
				speak("theme" + v.keyboardtheme + "");
			}
		}
		if (key_pressed(KEY_F5)) {
			if (v.keyboardsoundforothers == 0) {
				p.play_stationary("toggleon.ogg", false);
				send_reliable(peer_id, "draw toggleon.ogg", 7);
				speak("others will now hear your typing sounds");
				v.keyboardsoundforothers = 1;
			} else {
				p.play_stationary("toggleoff.ogg", false);
				send_reliable(peer_id, "draw toggleoff.ogg", 7);
				speak("others won't hear your typing sounds from now on");
				v.keyboardsoundforothers = 0;
			}
		}
		if (key_pressed(KEY_F6)) {
			if (v.hearotherskeyboardsound == 0) {
				p.play_stationary("toggleon.ogg", false);
				send_reliable(peer_id, "draw toggleon.ogg", 7);
				speak("now hearing others typing sounds");
				v.hearotherskeyboardsound = 1;
			} else {
				p.play_stationary("toggleoff.ogg", false);
				send_reliable(peer_id, "draw toggleoff.ogg", 7);
				speak("you won't hear others typing sounds from now on");
				v.hearotherskeyboardsound = 0;
			}
		}
		if (key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT) and key_pressed(KEY_F8)) {
			if (!directory_exists("keyboard_languages")) {
				dlg("Could not find keyboard languages");
				break;
			}
			string[] lngfiles = find_files("keyboard_languages/*.lng");
			if (lngfiles.length() <= 0) {
				dlg("No keyboard languages found");
				break;
			}
			if (screen_reader_is_running(1))
				form.set_output_mode(JAWS);
			if (screen_reader_is_running(2))
				form.set_output_mode(WINDOW_EYES);
			if (screen_reader_is_running(3))
				form.set_output_mode(SYSTEM_ACCESS);
			if (screen_reader_is_running(4))
				form.set_output_mode(NVDA);
			form.create_window("Select a language to be added to the keyboard languages", false);
			int klng = form.create_list("&Keyboard languages", 0);
			for (uint i = 0; i < lngfiles.length(); i++)
				form.add_list_item(klng, string_replace(lngfiles[i], ".lng", "", true), -1);
			int ok = form.create_button("OK");
			int cancel = form.create_button("cancel");
			form.set_button_attributes(ok, true, false);
			form.set_button_attributes(cancel, false, true);
			while (true) {
				form.monitor();
				wait(5);
				mainloop();
				if (form.is_pressed(cancel)) {
					form.reset();
					break;
				} else if (form.is_pressed(ok)) {
					if (form.get_list_position(klng) == -1) {
						dlg("An error has occured. Please set your keyboard language");
						form.reset();
					} else {
						klang.insert_last("" + form.get_list_item(klng, form.get_list_position(klng)) + ".lng");
						form.reset();
						speak("done");
						break;
					}
				}
			}
		}
		if (shift_is_down() and key_pressed(KEY_F8)) {
			if (screen_reader_is_running(1))
				form.set_output_mode(JAWS);
			if (screen_reader_is_running(2))
				form.set_output_mode(WINDOW_EYES);
			if (screen_reader_is_running(3))
				form.set_output_mode(SYSTEM_ACCESS);
			if (screen_reader_is_running(4))
				form.set_output_mode(NVDA);
			form.create_window("Select a language to be removed from keyboard languages", false);
			int klng2 = form.create_list("&Keyboard languages", 0);
			for (uint i = 0; i < klang.length(); i++)
				form.add_list_item(klng2, string_replace(klang[i], ".lng", "", true), -1);
			int ok = form.create_button("OK");
			int cancel = form.create_button("cancel");
			form.set_button_attributes(ok, true, false);
			form.set_button_attributes(cancel, false, true);
			while (true) {
				form.monitor();
				wait(5);
				mainloop();
				if (form.is_pressed(cancel)) {
					form.reset();
					break;
				} else if (form.is_pressed(ok)) {
					int something = klang.find("" + form.get_list_item(klng2, form.get_list_position(klng2)) + ".lng");
					if (something > -1)
						klang.remove_at(something);
					currentkeyboardlangfile = "";
					form.reset();
					speak("done");
					break;
				}
			}
		}
		if (control_down) {
			if (key_pressed(KEY_V)) {
				if (clipboard_read_text() == "")
					speak("There is no text on the clipboard");
				else {
					speak(clipboard_read_text() + " pasted");
					message += clipboard_read_text();
				}
			}
		}
		if (mode == 1) {
			if (!string_is_alphanumeric(char) and char != " ") char = "";
		}
		if (mode == 2) {
			if (!string_contains_numbers(char)) char = "";
		}
		if (char != "") {
			total_keypresses += char.length();
			if (string_is_upper_case(char)) {
				if (v.keyboardtheme == 1) vplay("keyboard1type" + random(1, 10) + "");
				else if (v.keyboardtheme == 2) vplay("keyboard2type" + random(1, 10) + "");
				else if (v.keyboardtheme == 3) vplay("keyboard3type" + random(1, 5) + "");
				else if (v.keyboardtheme == 4) vplay("keyboard4type" + random(1, 3) + "");
				else if (v.keyboardtheme == 5) vplay("keyboard5key" + random(1, 4) + "");
				else if (v.keyboardtheme == 6) vplay("keyboard6type" + random(1, 4) + "");
				else if (v.keyboardtheme == 7) vplay("keyboard7");
				else if (v.keyboardtheme == 8) vplay("keyboard8key" + random(1, 4) + "");
				else if (v.keyboardtheme == 9) vplay("keyboard9type");
				else if (v.keyboardtheme == 10) vplay("phonekeytype");
				if (currentkeyboardlangfile == "english") {
					if (v.caps == 1) {
						if (v.repeat == 1) speak("Capital " + char);
					} else if (v.caps == 2) {
						v.capital.stop(); v.capital.play();
						if (v.repeat == 1) speak(char);
					} else if (v.caps == 3) {
						if (v.repeat == 1) speak(char);
					}
				} else {
					if (v.repeat == 1) speak(char);
				}
			} else if (char == " ") {
				if (v.keyboardtheme == 4) vplay("keyboard4type" + random(1, 3) + "");
				else if (v.keyboardtheme == 5) vplay("keyboard5key" + random(1, 4) + "");
				else if (v.keyboardtheme == 6) vplay("keyboard6type" + random(1, 4) + "");
				else if (v.keyboardtheme == 7) vplay("keyboard7");
				else if (v.keyboardtheme == 8) vplay("keyboard8key" + random(1, 4) + "");
				else if (v.keyboardtheme == 10) vplay("phonekeyspace");
				else vplay("keyboard" + v.keyboardtheme + "space");
				if (v.repeat == 1) speak("space");
			} else {
				if (v.keyboardtheme == 1) vplay("keyboard1type" + random(1, 10) + "");
				else if (v.keyboardtheme == 2) vplay("keyboard2type" + random(1, 10) + "");
				else if (v.keyboardtheme == 3) vplay("keyboard3type" + random(1, 5) + "");
				else if (v.keyboardtheme == 4) vplay("keyboard4type" + random(1, 3) + "");
				else if (v.keyboardtheme == 5) vplay("keyboard5key" + random(1, 4) + "");
				else if (v.keyboardtheme == 6) vplay("keyboard6type" + random(1, 4) + "");
				else if (v.keyboardtheme == 7) vplay("keyboard7");
				else if (v.keyboardtheme == 8) vplay("keyboard8key" + random(1, 4) + "");
				else if (v.keyboardtheme == 9) vplay("keyboard9type");
				else if (v.keyboardtheme == 10) vplay("phonekeytype");
				if (v.repeat == 1) speak(char);
			}
			message += char;
			if (total_keypresses >= keypresses and keypresses > -1) {
				if (autosend >= 1) {
					message = string_replace(message, " ", "[SPCE]", true);
					send_reliable(peer_id, sendtext + " " + message, 0);
					keys_pressed();
					get_characters();
					//keys_released();
					//keys_up();
					inbox = false;
					return;
				}
			}
		}
		if ((back.pressing() or back2.pressing())) {
			if (v.keyboardtheme == 4) vplay("keyboard4type" + random(1, 3) + "");
			else if (v.keyboardtheme == 5) vplay("keyboard5key" + random(1, 4) + "");
			else if (v.keyboardtheme == 6) vplay("keyboard6type" + random(1, 4) + "");
			else if (v.keyboardtheme == 7) vplay("keyboard7");
			else if (v.keyboardtheme == 8) vplay("keyboard8key" + random(1, 4) + "");
			else if (v.keyboardtheme == 10) vplay("phonekeydelete");
			else vplay("keyboard" + v.keyboardtheme + "delete");
			if (message.length() > 0) {
				string char = message[message.length() - 1];
				speak(char);
				message.resize(message.length() - 1);
			}
			total_keypresses--;
			if (total_keypresses >= keypresses and keypresses > -1) {
				if (autosend >= 1) {
					if (message.length() <= 0)
						message = "[bckspace]";
					send_reliable(peer_id, sendtext + " " + message, 0);
					keys_pressed();
					get_characters();
					//keys_released();
					//keys_up();
					inbox = false;
					return;
				}
			}
		}
		if (key_pressed(KEY_LEFT) or key_pressed(KEY_RIGHT) or key_pressed(KEY_UP) or key_pressed(KEY_DOWN)) {
			if (message.length() > 0)
				speak(message);
			else
				speak("blank");
		}
		if (key_pressed(KEY_ESCAPE)) {
			send_reliable(peer_id, sendtext + " [cncel]", 0);
			keys_pressed();
			get_characters();
			//keys_released();
			//keys_up();
			inbox = false;
			return;
		} else if (key_pressed(KEY_RETURN) and message.length() > 0) {
			if (v.keyboardtheme == 5) vplay("keyboard5key" + random(1, 4) + "");
			else if (v.keyboardtheme == 7) vplay("keyboard7");
			else if (v.keyboardtheme == 8) vplay("keyboard8key" + random(1, 4) + "");
			else if (v.keyboardtheme == 10) vplay("phone
				                                      ");
				                                      else vplay("keyboard" + v.keyboardtheme + "enter");
					                                      send_reliable(peer_id, sendtext + " " + message, 0);
					                                      get_characters();
					                                      //keys_released();
					                                      //keys_up();
					                                      inbox = false;
					                                      return;
				}
		wait(5);
	}
	keys_pressed();
	get_characters();
	get_characters();
	//keys_released();
	//keys_up();
	return;
}
void beep(int hz) {
	ts.reset();
	ts.set_edge_fades(0, 0);
	ts.waveform_type = 4;
	ts.freq_ms(hz, 50);
	sound@ snd = ts.write_wave_sound();
	snd.play_wait();
}
string random_string_from_array(string[] arraystring) {
	string retval = arraystring[random(0, arraystring.length() - 1)];
	return retval;
}
int stng(string the_string) {
	return string_to_number(the_string);
}
void tell_where(int x, int y, int z, string name = "") {
	if (me.x <= x) {
		godir = "right";
		go = x - me.x;
	} else if (me.x >= x) {
		godir = "left";
		go = me.x - x;
	}
	if (me.y <= y) {
		godir2 = "infrunt";
		go2 = y - me.y;
	} else if (me.y >= y) {
		godir2 = "behined";
		go2 = me.y - y;
	}
	if (me.z <= z) {
		godir3 = "above";
		go3 = z - me.z;
	} else if (me.z >= z) {
		godir3 = "below";
		go3 = me.z - z;
	}
	speak((name == "" ? "" : name + ": ") + godir + " " + go + " and " + godir2 + " " + go2 + " and " + godir3 + " " + go3);
}
string[] find_closest_players() {
	string[] dp, o;
	int[] dx;
	dp.reserve(players.length());
	dx.reserve(players.length());
	o.reserve(players.length());
	for (uint i = 0; i < players.length(); i++) {
		const int d = absolute(me.x - players[i].x);
		dp.insert_last(d + "|" + players[i].name);
		dx.insert_last(d);
	}
	dx.sort_ascending();
	for (uint i = 0; i < dx.length(); i++) {
		for (uint j = 0; j < dp.length(); j++) {
			if (string_split(dp[j], "|", true)[1] != name and string_split(dp[j], "|", true)[0] == dx[i])
				o.insert_last(string_split(dp[j], "|", true)[1]);
		}
	}
	return o;
}
int find_player(const string un) {
	for (uint i = 0; i < players.length(); i++) {
		if (un == players[i].name)
			return i;
	}
	return -1;
}
int mcb(dynamic_menu_pro@ d, string a = "") {
	return 0;
}
void pause_all_naturals() {
	if (chuvatelhado.playing) chuvatelhado.close();
	chuvatelhado.volume = -12;
	if (windtelhado.playing) windtelhado.close();
	windtelhado.volume = -12;
	if (nighttelhado.playing) nighttelhado.close();
	nighttelhado.volume = -12;
}
void resume_all_naturals() {
	if (chuvaativa == 1) {
		chuvatelhado.load(somchuva);
		chuvatelhado.play_looped();
	}
	if (windativa == 1) {
		windtelhado.load(somwind);
		windtelhado.play_looped();
	}
	if (nightativa == 1) {
		nighttelhado.load(somnight);
		nighttelhado.play_looped();
	}
}
bool get_total_distance(double sx, double sy, double sz, double tx, double ty, double tz, int mindist = 20) {
	return (sx < tx + mindist and sx > tx - mindist and sy < ty + mindist and sy > ty - mindist and sz < tz + mindist and sz > tz - mindist);
}
void entercheck() {
	for (uint i = 0; i < doors.length(); i++) {
		if (me.x >= doors[i].mindx and me.x <= doors[i].maxdx and me.y >= doors[i].mindy and me.y <= doors[i].maxdy and me.z >= doors[i].mindz and me.z <= doors[i].maxdz and amoving == false and dmoving == false and !systemmoving) {
			if (doors[i].text != " ") speak(doors[i].text);
			can_move = false;
			if (doors[i].ds3 != "silence" and sleepmode != 0) rvp.play_stationary(doors[i].ds3, false);
			if (doors[i].ds3 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + doors[i].ds3, 7);
			doors[i].doorsound2 = p.play_stationary(doors[i].ds2, true);
			doors[i].moving = true;
			dmoving = true;
			send_reliable(peer_id, "iamdmoving " + doors[i].ds2, 0);
		}
	}
	for (uint i = 0; i < pdoors.length(); i++) {
		if (me.x >= pdoors[i].mindx and me.x <= pdoors[i].maxdx and me.y >= pdoors[i].mindy and me.y <= pdoors[i].maxdy and me.z >= pdoors[i].mindz and me.z <= pdoors[i].maxdz and amoving == false and dmoving == false and !systemmoving) {
			string s = v.input(pdoors[i].text);
			if (s != "" and !is_eloquence_crash_word(s) and get_sequence(s, true) <= 3) {
				if (s == pdoors[i].password) {
					can_move = false;
					if (pdoors[i].ds3 != "silence" and sleepmode != 0) rvp.play_stationary(pdoors[i].ds3, false);
					if (pdoors[i].ds3 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + pdoors[i].ds3, 7);
					pdoors[i].pdoorsound2 = p.play_stationary(pdoors[i].ds2, true);
					pdoors[i].moving = true;
					dmoving = true;
					send_reliable(peer_id, "iamdmoving " + pdoors[i].ds2, 0);
				} else
					speak("rong password");
			} else
				speak("rong password");
		}
	}
	for (uint i = 0; i < icdoors.length(); i++) {
		if (me.x >= icdoors[i].mindx and me.x <= icdoors[i].maxdx and me.y >= icdoors[i].mindy and me.y <= icdoors[i].maxdy and me.z >= icdoors[i].mindz and me.z <= icdoors[i].maxdz and amoving == false and dmoving == false and !systemmoving) {
			if (inv_item_number(icdoors[i].item) >= icdoors[i].amount) {
				if (icdoors[i].text != " ") speak(icdoors[i].text);
				can_move = false;
				if (icdoors[i].ds3 != "silence" and sleepmode != 0) rvp.play_stationary(icdoors[i].ds3, false);
				if (icdoors[i].ds3 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + icdoors[i].ds3, 7);
				icdoors[i].icdoorsound2 = p.play_stationary(icdoors[i].ds2, true);
				icdoors[i].moving = true;
				dmoving = true;
				send_reliable(peer_id, "iamdmoving " + icdoors[i].ds2, 0);
			} else
				speak("not enough " + icdoors[i].item + ", you need " + icdoors[i].amount + " " + icdoors[i].item + "");
		}
	}
	for (uint i = 0; i < itdoors.length(); i++) {
		if (me.x >= itdoors[i].mindx and me.x <= itdoors[i].maxdx and me.y >= itdoors[i].mindy and me.y <= itdoors[i].maxdy and me.z >= itdoors[i].mindz and me.z <= itdoors[i].maxdz and amoving == false and dmoving == false) {
			if (inv_item_number(itdoors[i].item) >= itdoors[i].amount) {
				if (itdoors[i].text != " ") speak(itdoors[i].text);
				send_reliable(peer_id, "doortake " + itdoors[i].item + " " + itdoors[i].amount, 0);
				can_move = false;
				if (itdoors[i].ds3 != "silence" and sleepmode != 0) rvp.play_stationary(itdoors[i].ds3, false);
				if (itdoors[i].ds3 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + itdoors[i].ds3, 7);
				itdoors[i].itdoorsound2 = p.play_stationary(itdoors[i].ds2, true);
				itdoors[i].moving = true;
				dmoving = true;
				send_reliable(peer_id, "iamdmoving " + itdoors[i].ds2, 0);
			} else
				speak("not enough " + itdoors[i].item + ", you need " + itdoors[i].amount + " " + itdoors[i].item + "");
		}
	}
	for (uint i = 0; i < igdoors.length(); i++) {
		if (me.x >= igdoors[i].mindx and me.x <= igdoors[i].maxdx and me.y >= igdoors[i].mindy and me.y <= igdoors[i].maxdy and me.z >= igdoors[i].mindz and me.z <= igdoors[i].maxdz and amoving == false and dmoving == false) {
			if (igdoors[i].text != " ") speak(igdoors[i].text);
			send_reliable(peer_id, "doorgive " + igdoors[i].item + " " + igdoors[i].amount, 0);
			can_move = false;
			if (igdoors[i].ds3 != "silence" and sleepmode != 0) rvp.play_stationary(igdoors[i].ds3, false);
			if (igdoors[i].ds3 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + igdoors[i].ds3, 7);
			igdoors[i].igdoorsound2 = p.play_stationary(igdoors[i].ds2, true);
			igdoors[i].moving = true;
			dmoving = true;
			send_reliable(peer_id, "iamdmoving " + igdoors[i].ds2, 0);
		}
	}
	if (get_zone_at(me.x, me.y, me.z) == "civil registry office") civilregistrymenu();
	if (get_zone_at(me.x, me.y, me.z) == "telephone") telephonemenu();
	if (get_zone_at(me.x, me.y, me.z) == "download_box") dbmenu();
	for (uint i = 0; i < signs.length(); i++) {
		if (me.x >= signs[i].minx and me.x <= signs[i].maxx and me.y >= signs[i].miny and me.y <= signs[i].maxy and me.z >= signs[i].minz and me.z <= signs[i].maxz) {
			rvp.play_3d("signpress.ogg", me.x, me.y, me.z, me.x, me.y, me.z, calculate_theta(facing), false);
			speak(signs[i].text);
		}
	}
	for (uint i = 0; i < dialogs.length(); i++) {
		if (me.x >= dialogs[i].minx and me.x <= dialogs[i].maxx and me.y >= dialogs[i].miny and me.y <= dialogs[i].maxy and me.z >= dialogs[i].minz and me.z <= dialogs[i].maxz)
			silencedialogs(dialogs[i].text);
	}
}
void travelcheck() {
	for (uint i = 0; i < travelpoints.length(); i++) {
		if (me.x >= travelpoints[i].mindx and me.x <= travelpoints[i].maxdx and me.y >= travelpoints[i].mindy and me.y <= travelpoints[i].maxdy and me.z >= travelpoints[i].mindz and me.z <= travelpoints[i].maxdz) {
			if (travelpoints[i].text != " ") speak(travelpoints[i].text);
			if (travelpoints[i].ds2 != "silence" and sleepmode != 0) rvp.play_stationary(travelpoints[i].ds2, false);
			if (travelpoints[i].ds2 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + travelpoints[i].ds2, 0);
			send_reliable(peer_id, "travelto " + travelpoints[i].nx + " " + travelpoints[i].ny + " " + travelpoints[i].nz + " " + travelpoints[i].nmap, 0);
			if (travelpoints[i].ds3 != "silence" and sleepmode != 0) send_reliable(0, "draw " + travelpoints[i].ds3, 7);
			if (travelpoints[i].ds3 != "silence") rvp.play_stationary(travelpoints[i].ds3, false);
		}
	}
	for (uint i = 0; i < ptravelpoints.length(); i++) {
		if (me.x >= ptravelpoints[i].mindx and me.x <= ptravelpoints[i].maxdx and me.y >= ptravelpoints[i].mindy and me.y <= ptravelpoints[i].maxdy and me.z >= ptravelpoints[i].mindz and me.z <= ptravelpoints[i].maxdz) {
			string s = v.input(ptravelpoints[i].text);
			if (s != "" and !is_eloquence_crash_word(s) and get_sequence(s, true) <= 3) {
				if (s == ptravelpoints[i].password) {
					if (ptravelpoints[i].ds2 != "silence" and sleepmode != 0) rvp.play_stationary(ptravelpoints[i].ds2, false);
					if (ptravelpoints[i].ds2 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + ptravelpoints[i].ds2, 0);
					send_reliable(peer_id, "ptravelto " + ptravelpoints[i].nx + " " + ptravelpoints[i].ny + " " + ptravelpoints[i].nz + " " + ptravelpoints[i].nmap, 0);
					if (ptravelpoints[i].ds3 != "silence" and sleepmode != 0) send_reliable(0, "draw " + ptravelpoints[i].ds3, 7);
					if (ptravelpoints[i].ds3 != "silence") rvp.play_stationary(ptravelpoints[i].ds3, false);
				} else
					speak("rong password");
			} else
				speak("rong password");
		}
	}
	for (uint i = 0; i < ictravelpoints.length(); i++) {
		if (me.x >= ictravelpoints[i].mindx and me.x <= ictravelpoints[i].maxdx and me.y >= ictravelpoints[i].mindy and me.y <= ictravelpoints[i].maxdy and me.z >= ictravelpoints[i].mindz and me.z <= ictravelpoints[i].maxdz) {
			if (inv_item_number(ictravelpoints[i].item) >= 1) {
				int s = inv_item_number(ictravelpoints[i].item);
				if (s > ictravelpoints[i].amount) {
					if (ictravelpoints[i].ds2 != "silence" and sleepmode != 0) rvp.play_stationary(ictravelpoints[i].ds2, false);
					if (ictravelpoints[i].ds2 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + ictravelpoints[i].ds2, 0);
					send_reliable(peer_id, "ictravelto " + ictravelpoints[i].nx + " " + ictravelpoints[i].ny + " " + ictravelpoints[i].nz + " " + ictravelpoints[i].nmap, 0);
					if (ictravelpoints[i].ds3 != "silence" and sleepmode != 0) send_reliable(0, "draw " + ictravelpoints[i].ds3, 7);
					if (ictravelpoints[i].ds3 != "silence") rvp.play_stationary(ictravelpoints[i].ds3, false);
				} else
					speak("not enough " + ictravelpoints[i].item + ", you need " + ictravelpoints[i].amount + " " + ictravelpoints[i].item + "");
			} else
				speak("not enough " + ictravelpoints[i].item + ", you need " + ictravelpoints[i].amount + " " + ictravelpoints[i].item + "");
		}
	}
	for (uint i = 0; i < ittravelpoints.length(); i++) {
		if (me.x >= ittravelpoints[i].mindx and me.x <= ittravelpoints[i].maxdx and me.y >= ittravelpoints[i].mindy and me.y <= ittravelpoints[i].maxdy and me.z >= ittravelpoints[i].mindz and me.z <= ittravelpoints[i].maxdz) {
			if (inv_item_number(ittravelpoints[i].item) >= 1) {
				int s = inv_item_number(ittravelpoints[i].item);
				if (s > ittravelpoints[i].amount) {
					if (ittravelpoints[i].text != " ") speak(ittravelpoints[i].text);
					if (ittravelpoints[i].ds2 != "silence" and sleepmode != 0) rvp.play_stationary(ittravelpoints[i].ds2, false);
					if (ittravelpoints[i].ds2 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + ittravelpoints[i].ds2, 0);
					send_reliable(peer_id, "ittravelto " + ittravelpoints[i].nx + " " + ittravelpoints[i].ny + " " + ittravelpoints[i].nz + " " + ittravelpoints[i].nmap, 0);
					if (ittravelpoints[i].ds3 != "silence" and sleepmode != 0) send_reliable(0, "draw " + ittravelpoints[i].ds3, 7);
					if (ittravelpoints[i].ds3 != "silence") rvp.play_stationary(ittravelpoints[i].ds3, false);
				} else
					speak("not enough " + ittravelpoints[i].item + ", you need " + ittravelpoints[i].amount + " " + ittravelpoints[i].item + "");
			} else
				speak("not enough " + ittravelpoints[i].item + ", you need " + ittravelpoints[i].amount + " " + ittravelpoints[i].item + "");
		}
	}
	for (uint i = 0; i < igtravelpoints.length(); i++) {
		if (me.x >= igtravelpoints[i].mindx and me.x <= igtravelpoints[i].maxdx and me.y >= igtravelpoints[i].mindy and me.y <= igtravelpoints[i].maxdy and me.z >= igtravelpoints[i].mindz and me.z <= igtravelpoints[i].maxdz) {
			if (igtravelpoints[i].text != " ") speak(igtravelpoints[i].text);
			if (igtravelpoints[i].ds2 != "silence" and sleepmode != 0) rvp.play_stationary(igtravelpoints[i].ds2, false);
			if (igtravelpoints[i].ds2 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + igtravelpoints[i].ds2, 0);
			send_reliable(peer_id, "igtravelto " + igtravelpoints[i].nx + " " + igtravelpoints[i].ny + " " + igtravelpoints[i].nz + " " + igtravelpoints[i].nmap, 0);
			send_reliable(peer_id, "travelpointgive " + igtravelpoints[i].item + " " + igtravelpoints[i].amount, 0);
			if (igtravelpoints[i].ds3 != "silence" and sleepmode != 0) send_reliable(0, "draw " + igtravelpoints[i].ds3, 7);
			if (igtravelpoints[i].ds3 != "silence") rvp.play_stationary(igtravelpoints[i].ds3, false);
		}
	}
}
void movecheck() {
	for (uint i = 0; i < automatic_travelpoints.length(); i++) {
		if (me.x >= automatic_travelpoints[i].mindx and me.x <= automatic_travelpoints[i].maxdx and me.y >= automatic_travelpoints[i].mindy and me.y <= automatic_travelpoints[i].maxdy and me.z >= automatic_travelpoints[i].mindz and me.z <= automatic_travelpoints[i].maxdz) {
			if (automatic_travelpoints[i].text != " ") speak(automatic_travelpoints[i].text);
			if (automatic_travelpoints[i].ds2 != "silence" and sleepmode != 0) rvp.play_stationary(automatic_travelpoints[i].ds2, false);
			if (automatic_travelpoints[i].ds2 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + automatic_travelpoints[i].ds2, 0);
			send_reliable(peer_id, "travelto " + automatic_travelpoints[i].nx + " " + automatic_travelpoints[i].ny + " " + automatic_travelpoints[i].nz + " " + automatic_travelpoints[i].nmap, 0);
			if (automatic_travelpoints[i].ds3 != "silence" and sleepmode != 0) send_reliable(0, "draw " + automatic_travelpoints[i].ds3, 7);
			if (automatic_travelpoints[i].ds3 != "silence") rvp.play_stationary(automatic_travelpoints[i].ds3, false);
		}
	}
	for (uint i = 0; i < pautomatic_travelpoints.length(); i++) {
		if (me.x >= pautomatic_travelpoints[i].mindx and me.x <= pautomatic_travelpoints[i].maxdx and me.y >= pautomatic_travelpoints[i].mindy and me.y <= pautomatic_travelpoints[i].maxdy and me.z >= pautomatic_travelpoints[i].mindz and me.z <= pautomatic_travelpoints[i].maxdz) {
			string s = v.input(pautomatic_travelpoints[i].text);
			if (s != "" and !is_eloquence_crash_word(s) and get_sequence(s, true) <= 3) {
				if (s == pautomatic_travelpoints[i].password) {
					if (pautomatic_travelpoints[i].ds2 != "silence" and sleepmode != 0) rvp.play_stationary(pautomatic_travelpoints[i].ds2, false);
					if (pautomatic_travelpoints[i].ds2 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + pautomatic_travelpoints[i].ds2, 0);
					send_reliable(peer_id, "ptravelto " + pautomatic_travelpoints[i].nx + " " + pautomatic_travelpoints[i].ny + " " + pautomatic_travelpoints[i].nz + " " + pautomatic_travelpoints[i].nmap, 0);
					if (pautomatic_travelpoints[i].ds3 != "silence" and sleepmode != 0) send_reliable(0, "draw " + pautomatic_travelpoints[i].ds3, 7);
					if (pautomatic_travelpoints[i].ds3 != "silence") rvp.play_stationary(pautomatic_travelpoints[i].ds3, false);
				} else
					speak("rong password");
			} else
				speak("rong password");
		}
	}
	for (uint i = 0; i < icautomatic_travelpoints.length(); i++) {
		if (me.x >= icautomatic_travelpoints[i].mindx and me.x <= icautomatic_travelpoints[i].maxdx and me.y >= icautomatic_travelpoints[i].mindy and me.y <= icautomatic_travelpoints[i].maxdy and me.z >= icautomatic_travelpoints[i].mindz and me.z <= icautomatic_travelpoints[i].maxdz) {
			if (inv_item_number(icautomatic_travelpoints[i].item) >= icautomatic_travelpoints[i].amount) {
				if (icautomatic_travelpoints[i].text != " ") speak(icautomatic_travelpoints[i].text);
				if (icautomatic_travelpoints[i].ds2 != "silence" and sleepmode != 0) rvp.play_stationary(icautomatic_travelpoints[i].ds2, false);
				if (icautomatic_travelpoints[i].ds2 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + icautomatic_travelpoints[i].ds2, 0);
				send_reliable(peer_id, "ictravelto " + icautomatic_travelpoints[i].nx + " " + icautomatic_travelpoints[i].ny + " " + icautomatic_travelpoints[i].nz + " " + icautomatic_travelpoints[i].nmap, 0);
				if (icautomatic_travelpoints[i].ds3 != "silence" and sleepmode != 0) send_reliable(0, "draw " + icautomatic_travelpoints[i].ds3, 7);
				if (icautomatic_travelpoints[i].ds3 != "silence") rvp.play_stationary(icautomatic_travelpoints[i].ds3, false);
			} else
				speak("not enough " + icautomatic_travelpoints[i].item + ", you need " + icautomatic_travelpoints[i].amount + " " + icautomatic_travelpoints[i].item + "");
		}
	}
	for (uint i = 0; i < itautomatic_travelpoints.length(); i++) {
		if (me.x >= itautomatic_travelpoints[i].mindx and me.x <= itautomatic_travelpoints[i].maxdx and me.y >= itautomatic_travelpoints[i].mindy and me.y <= itautomatic_travelpoints[i].maxdy and me.z >= itautomatic_travelpoints[i].mindz and me.z <= itautomatic_travelpoints[i].maxdz) {
			if (inv_item_number(itautomatic_travelpoints[i].item) >= itautomatic_travelpoints[i].amount) {
				if (itautomatic_travelpoints[i].text != " ") speak(itautomatic_travelpoints[i].text);
				if (itautomatic_travelpoints[i].ds2 != "silence" and sleepmode != 0) rvp.play_stationary(itautomatic_travelpoints[i].ds2, false);
				if (itautomatic_travelpoints[i].ds2 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + itautomatic_travelpoints[i].ds2, 0);
				send_reliable(peer_id, "ittravelto " + itautomatic_travelpoints[i].nx + " " + itautomatic_travelpoints[i].ny + " " + itautomatic_travelpoints[i].nz + " " + itautomatic_travelpoints[i].nmap, 0);
				if (itautomatic_travelpoints[i].ds3 != "silence" and sleepmode != 0) send_reliable(0, "draw " + itautomatic_travelpoints[i].ds3, 7);
				if (itautomatic_travelpoints[i].ds3 != "silence") rvp.play_stationary(itautomatic_travelpoints[i].ds3, false);
			} else
				speak("not enough " + itautomatic_travelpoints[i].item + ", you need " + itautomatic_travelpoints[i].amount + " " + itautomatic_travelpoints[i].item + "");
		}
	}
	for (uint i = 0; i < igautomatic_travelpoints.length(); i++) {
		if (me.x >= igautomatic_travelpoints[i].mindx and me.x <= igautomatic_travelpoints[i].maxdx and me.y >= igautomatic_travelpoints[i].mindy and me.y <= igautomatic_travelpoints[i].maxdy and me.z >= igautomatic_travelpoints[i].mindz and me.z <= igautomatic_travelpoints[i].maxdz) {
			if (igautomatic_travelpoints[i].text != " ") speak(igautomatic_travelpoints[i].text);
			if (igautomatic_travelpoints[i].ds2 != "silence" and sleepmode != 0) rvp.play_stationary(igautomatic_travelpoints[i].ds2, false);
			if (igautomatic_travelpoints[i].ds2 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + igautomatic_travelpoints[i].ds2, 0);
			send_reliable(peer_id, "igtravelto " + igautomatic_travelpoints[i].nx + " " + igautomatic_travelpoints[i].ny + " " + igautomatic_travelpoints[i].nz + " " + igautomatic_travelpoints[i].nmap, 0);
			send_reliable(peer_id, "automatic_travelpointgive " + igautomatic_travelpoints[i].item + " " + igautomatic_travelpoints[i].amount, 0);
			if (igautomatic_travelpoints[i].ds3 != "silence" and sleepmode != 0) send_reliable(0, "draw " + igautomatic_travelpoints[i].ds3, 7);
			if (igautomatic_travelpoints[i].ds3 != "silence") rvp.play_stationary(igautomatic_travelpoints[i].ds3, false);
		}
	}
	for (uint i = 0; i < automovers.length(); i++) {
		if (me.x >= automovers[i].mindx and me.x <= automovers[i].maxdx and me.y >= automovers[i].mindy and me.y <= automovers[i].maxdy and me.z >= automovers[i].mindz and me.z <= automovers[i].maxdz and amoving == false) {
			if (automovers[i].text != " ") speak(automovers[i].text);
			can_move = false;
			if (automovers[i].ds3 != "silence" and sleepmode != 0) rvp.play_stationary(automovers[i].ds3, false);
			if (automovers[i].ds3 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + automovers[i].ds3, 7);
			automovers[i].automoversound2 = p.play_stationary(automovers[i].ds2, true);
			automovers[i].moving = true;
			amoving = true;
			send_reliable(peer_id, "iamamoving " + automovers[i].ds2, 0);
		}
	}
	for (uint i = 0; i < pautomovers.length(); i++) {
		if (me.x >= pautomovers[i].mindx and me.x <= pautomovers[i].maxdx and me.y >= pautomovers[i].mindy and me.y <= pautomovers[i].maxdy and me.z >= pautomovers[i].mindz and me.z <= pautomovers[i].maxdz and amoving == false and amoving == false) {
			string s = v.input(pautomovers[i].text);
			if (s != "" and !is_eloquence_crash_word(s) and get_sequence(s, true) <= 3) {
				if (s == pautomovers[i].password) {
					can_move = false;
					if (pautomovers[i].ds3 != "silence" and sleepmode != 0) rvp.play_stationary(pautomovers[i].ds3, false);
					if (pautomovers[i].ds3 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + pautomovers[i].ds3, 7);
					pautomovers[i].pautomoversound2 = p.play_stationary(pautomovers[i].ds2, true);
					pautomovers[i].moving = true;
					amoving = true;
					send_reliable(peer_id, "iamamoving " + pautomovers[i].ds2, 0);
				} else
					speak("rong password");
			} else
				speak("rong password");
		}
	}
	for (uint i = 0; i < icautomovers.length(); i++) {
		if (me.x >= icautomovers[i].mindx and me.x <= icautomovers[i].maxdx and me.y >= icautomovers[i].mindy and me.y <= icautomovers[i].maxdy and me.z >= icautomovers[i].mindz and me.z <= icautomovers[i].maxdz and amoving == false and amoving == false) {
			if (inv_item_number(icautomovers[i].item) >= 1) {
				int s = inv_item_number(icautomovers[i].item);
				if (s > icautomovers[i].amount) {
					if (icautomovers[i].text != " ") speak(icautomovers[i].text);
					can_move = false;
					if (icautomovers[i].ds3 != "silence" and sleepmode != 0) rvp.play_stationary(icautomovers[i].ds3, false);
					if (icautomovers[i].ds3 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + icautomovers[i].ds3, 7);
					icautomovers[i].icautomoversound2 = p.play_stationary(icautomovers[i].ds2, true);
					icautomovers[i].moving = true;
					amoving = true;
					send_reliable(peer_id, "iamamoving " + icautomovers[i].ds2, 0);
				} else
					speak("not enough " + icautomovers[i].item + ", you need " + icautomovers[i].amount + " " + icautomovers[i].item + "");
			} else
				speak("not enough  " + icautomovers[i].item + ", you need " + icautomovers[i].amount + " " + icautomovers[i].item + "");
		}
	}
	for (uint i = 0; i < itautomovers.length(); i++) {
		if (me.x >= itautomovers[i].mindx and me.x <= itautomovers[i].maxdx and me.y >= itautomovers[i].mindy and me.y <= itautomovers[i].maxdy and me.z >= itautomovers[i].mindz and me.z <= itautomovers[i].maxdz and amoving == false and amoving == false) {
			if (inv_item_number(itautomovers[i].item) >= 1) {
				int s = inv_item_number(itautomovers[i].item);
				if (s > itautomovers[i].amount) {
					if (itautomovers[i].text != " ") speak(itautomovers[i].text);
					send_reliable(peer_id, "automovertake " + itautomovers[i].item + " " + itautomovers[i].amount, 0);
					can_move = false;
					if (itautomovers[i].ds3 != "silence" and sleepmode != 0) rvp.play_stationary(itautomovers[i].ds3, false);
					if (itautomovers[i].ds3 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + itautomovers[i].ds3, 7);
					itautomovers[i].itautomoversound2 = p.play_stationary(itautomovers[i].ds2, true);
					itautomovers[i].moving = true;
					amoving = true;
					send_reliable(peer_id, "iamamoving " + itautomovers[i].ds2, 0);
				} else
					speak("not enough " + itautomovers[i].item + ", you need " + itautomovers[i].amount + " " + itautomovers[i].item + "");
			} else
				speak("not enough " + itautomovers[i].item + ", you need " + itautomovers[i].amount + " " + itautomovers[i].item + "");
		}
	}
	for (uint i = 0; i < igautomovers.length(); i++) {
		if (me.x >= igautomovers[i].mindx and me.x <= igautomovers[i].maxdx and me.y >= igautomovers[i].mindy and me.y <= igautomovers[i].maxdy and me.z >= igautomovers[i].mindz and me.z <= igautomovers[i].maxdz and amoving == false and amoving == false) {
			if (igautomovers[i].text != " ") speak(igautomovers[i].text);
			send_reliable(peer_id, "automovergive " + igautomovers[i].item + " " + igautomovers[i].amount, 0);
			can_move = false;
			if (igautomovers[i].ds3 != "silence" and sleepmode != 0) rvp.play_stationary(igautomovers[i].ds3, false);
			if (igautomovers[i].ds3 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + igautomovers[i].ds3, 7);
			igautomovers[i].igautomoversound2 = p.play_stationary(igautomovers[i].ds2, true);
			igautomovers[i].moving = true;
			amoving = true;
			send_reliable(peer_id, "iamamoving " + igautomovers[i].ds2, 0);
		}
	}
	if (get_tile_at(me.x, me.y, me.z) == "hazard")
		send_reliable(peer_id, "hhealth", 0);
	for (uint i = 0; i < teleporters.length(); i++) {
		if (me.x >= teleporters[i].minx and me.x <= teleporters[i].maxx and me.y >= teleporters[i].miny and me.y <= teleporters[i].maxy and me.z >= teleporters[i].minz and me.z <= teleporters[i].maxz) {
			p.play_stationary("tele.ogg", false);
			send_reliable(peer_id, "draw tele.ogg", 7);
			send_reliable(peer_id, "tmove", 8);
		}
	}
	for (uint i = 0; i < automatic_dialogs.length(); i++) {
		if (me.x >= automatic_dialogs[i].minx and me.x <= automatic_dialogs[i].maxx and me.y >= automatic_dialogs[i].miny and me.y <= automatic_dialogs[i].maxy and me.z >= automatic_dialogs[i].minz and me.z <= automatic_dialogs[i].maxz)
			silencedialogs(automatic_dialogs[i].text);
	}
	for (uint i = 0; i < txts.length(); i++) {
		if (me.x >= txts[i].minx and me.x <= txts[i].maxx and me.y >= txts[i].miny and me.y <= txts[i].maxy and me.z >= txts[i].minz and me.z <= txts[i].maxz)
			speak(txts[i].text);
	}
}
void movecheck2() {
	for (uint i = 0; i < automatic_travelpoints.length(); i++) {
		if (me.x >= automatic_travelpoints[i].mindx and me.x <= automatic_travelpoints[i].maxdx and me.y >= automatic_travelpoints[i].mindy and me.y <= automatic_travelpoints[i].maxdy and me.z >= automatic_travelpoints[i].mindz and me.z <= automatic_travelpoints[i].maxdz) {
			if (automatic_travelpoints[i].text != " ") speak(automatic_travelpoints[i].text);
			if (automatic_travelpoints[i].ds2 != "silence" and sleepmode != 0) rvp.play_stationary(automatic_travelpoints[i].ds2, false);
			if (automatic_travelpoints[i].ds2 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + automatic_travelpoints[i].ds2, 0);
			send_reliable(peer_id, "travelto " + automatic_travelpoints[i].nx + " " + automatic_travelpoints[i].ny + " " + automatic_travelpoints[i].nz + " " + automatic_travelpoints[i].nmap, 0);
			if (automatic_travelpoints[i].ds3 != "silence" and sleepmode != 0) send_reliable(0, "draw " + automatic_travelpoints[i].ds3, 7);
			if (automatic_travelpoints[i].ds3 != "silence") rvp.play_stationary(automatic_travelpoints[i].ds3, false);
		}
	}
	for (uint i = 0; i < pautomatic_travelpoints.length(); i++) {
		if (me.x >= pautomatic_travelpoints[i].mindx and me.x <= pautomatic_travelpoints[i].maxdx and me.y >= pautomatic_travelpoints[i].mindy and me.y <= pautomatic_travelpoints[i].maxdy and me.z >= pautomatic_travelpoints[i].mindz and me.z <= pautomatic_travelpoints[i].maxdz) {
			string s = v.input(pautomatic_travelpoints[i].text);
			if (s != "" and !is_eloquence_crash_word(s) and get_sequence(s, true) <= 3) {
				if (s == pautomatic_travelpoints[i].password) {
					if (pautomatic_travelpoints[i].ds2 != "silence" and sleepmode != 0) rvp.play_stationary(pautomatic_travelpoints[i].ds2, false);
					if (pautomatic_travelpoints[i].ds2 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + pautomatic_travelpoints[i].ds2, 0);
					send_reliable(peer_id, "ptravelto " + pautomatic_travelpoints[i].nx + " " + pautomatic_travelpoints[i].ny + " " + pautomatic_travelpoints[i].nz + " " + pautomatic_travelpoints[i].nmap, 0);
					if (pautomatic_travelpoints[i].ds3 != "silence" and sleepmode != 0) send_reliable(0, "draw " + pautomatic_travelpoints[i].ds3, 7);
					if (pautomatic_travelpoints[i].ds3 != "silence") rvp.play_stationary(pautomatic_travelpoints[i].ds3, false);
				} else
					speak("rong password");
			} else
				speak("rong password");
		}
	}
	for (uint i = 0; i < icautomatic_travelpoints.length(); i++) {
		if (me.x >= icautomatic_travelpoints[i].mindx and me.x <= icautomatic_travelpoints[i].maxdx and me.y >= icautomatic_travelpoints[i].mindy and me.y <= icautomatic_travelpoints[i].maxdy and me.z >= icautomatic_travelpoints[i].mindz and me.z <= icautomatic_travelpoints[i].maxdz) {
			if (inv_item_number(icautomatic_travelpoints[i].item) >= icautomatic_travelpoints[i].amount) {
				if (icautomatic_travelpoints[i].text != " ") speak(icautomatic_travelpoints[i].text);
				if (icautomatic_travelpoints[i].ds2 != "silence" and sleepmode != 0) rvp.play_stationary(icautomatic_travelpoints[i].ds2, false);
				if (icautomatic_travelpoints[i].ds2 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + icautomatic_travelpoints[i].ds2, 0);
				send_reliable(peer_id, "ictravelto " + icautomatic_travelpoints[i].nx + " " + icautomatic_travelpoints[i].ny + " " + icautomatic_travelpoints[i].nz + " " + icautomatic_travelpoints[i].nmap, 0);
				if (icautomatic_travelpoints[i].ds3 != "silence" and sleepmode != 0) send_reliable(0, "draw " + icautomatic_travelpoints[i].ds3, 7);
				if (icautomatic_travelpoints[i].ds3 != "silence") rvp.play_stationary(icautomatic_travelpoints[i].ds3, false);
			} else
				speak("not enough " + icautomatic_travelpoints[i].item + ", you need " + icautomatic_travelpoints[i].amount + " " + icautomatic_travelpoints[i].item + "");
		}
	}
	for (uint i = 0; i < itautomatic_travelpoints.length(); i++) {
		if (me.x >= itautomatic_travelpoints[i].mindx and me.x <= itautomatic_travelpoints[i].maxdx and me.y >= itautomatic_travelpoints[i].mindy and me.y <= itautomatic_travelpoints[i].maxdy and me.z >= itautomatic_travelpoints[i].mindz and me.z <= itautomatic_travelpoints[i].maxdz) {
			if (inv_item_number(itautomatic_travelpoints[i].item) >= itautomatic_travelpoints[i].amount) {
				if (itautomatic_travelpoints[i].text != " ") speak(itautomatic_travelpoints[i].text);
				if (itautomatic_travelpoints[i].ds2 != "silence" and sleepmode != 0) rvp.play_stationary(itautomatic_travelpoints[i].ds2, false);
				if (itautomatic_travelpoints[i].ds2 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + itautomatic_travelpoints[i].ds2, 0);
				send_reliable(peer_id, "ittravelto " + itautomatic_travelpoints[i].nx + " " + itautomatic_travelpoints[i].ny + " " + itautomatic_travelpoints[i].nz + " " + itautomatic_travelpoints[i].nmap, 0);
				if (itautomatic_travelpoints[i].ds3 != "silence" and sleepmode != 0) send_reliable(0, "draw " + itautomatic_travelpoints[i].ds3, 7);
				if (itautomatic_travelpoints[i].ds3 != "silence") rvp.play_stationary(itautomatic_travelpoints[i].ds3, false);
			} else
				speak("not enough " + itautomatic_travelpoints[i].item + ", you need " + itautomatic_travelpoints[i].amount + " " + itautomatic_travelpoints[i].item + "");
		}
	}
	for (uint i = 0; i < igautomatic_travelpoints.length(); i++) {
		if (me.x >= igautomatic_travelpoints[i].mindx and me.x <= igautomatic_travelpoints[i].maxdx and me.y >= igautomatic_travelpoints[i].mindy and me.y <= igautomatic_travelpoints[i].maxdy and me.z >= igautomatic_travelpoints[i].mindz and me.z <= igautomatic_travelpoints[i].maxdz) {
			if (igautomatic_travelpoints[i].text != " ") speak(igautomatic_travelpoints[i].text);
			if (igautomatic_travelpoints[i].ds2 != "silence" and sleepmode != 0) rvp.play_stationary(igautomatic_travelpoints[i].ds2, false);
			if (igautomatic_travelpoints[i].ds2 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + igautomatic_travelpoints[i].ds2, 0);
			send_reliable(peer_id, "igtravelto " + igautomatic_travelpoints[i].nx + " " + igautomatic_travelpoints[i].ny + " " + igautomatic_travelpoints[i].nz + " " + igautomatic_travelpoints[i].nmap, 0);
			send_reliable(peer_id, "automatic_travelpointgive " + igautomatic_travelpoints[i].item + " " + igautomatic_travelpoints[i].amount, 0);
			if (igautomatic_travelpoints[i].ds3 != "silence" and sleepmode != 0) send_reliable(0, "draw " + igautomatic_travelpoints[i].ds3, 7);
			if (igautomatic_travelpoints[i].ds3 != "silence") rvp.play_stationary(igautomatic_travelpoints[i].ds3, false);
		}
	}
	for (uint i = 0; i < automovers.length(); i++) {
		if (me.x >= automovers[i].mindx and me.x <= automovers[i].maxdx and me.y >= automovers[i].mindy and me.y <= automovers[i].maxdy and me.z >= automovers[i].mindz and me.z <= automovers[i].maxdz and amoving == false) {
			if (automovers[i].text != " ") speak(automovers[i].text);
			can_move = false;
			if (automovers[i].ds3 != "silence" and sleepmode != 0) rvp.play_stationary(automovers[i].ds3, false);
			if (automovers[i].ds3 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + automovers[i].ds3, 7);
			automovers[i].automoversound2 = p.play_stationary(automovers[i].ds2, true);
			automovers[i].moving = true;
			amoving = true;
			send_reliable(peer_id, "iamamoving " + automovers[i].ds2, 0);
		}
	}
	for (uint i = 0; i < pautomovers.length(); i++) {
		if (me.x >= pautomovers[i].mindx and me.x <= pautomovers[i].maxdx and me.y >= pautomovers[i].mindy and me.y <= pautomovers[i].maxdy and me.z >= pautomovers[i].mindz and me.z <= pautomovers[i].maxdz and amoving == false and amoving == false) {
			string s = v.input(pautomovers[i].text);
			if (s != "" and !is_eloquence_crash_word(s) and get_sequence(s, true) <= 3) {
				if (s == pautomovers[i].password) {
					can_move = false;
					if (pautomovers[i].ds3 != "silence" and sleepmode != 0) rvp.play_stationary(pautomovers[i].ds3, false);
					if (pautomovers[i].ds3 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + pautomovers[i].ds3, 7);
					pautomovers[i].pautomoversound2 = p.play_stationary(pautomovers[i].ds2, true);
					pautomovers[i].moving = true;
					amoving = true;
					send_reliable(peer_id, "iamamoving " + pautomovers[i].ds2, 0);
				} else
					speak("rong password");
			} else
				speak("rong password");
		}
	}
	for (uint i = 0; i < icautomovers.length(); i++) {
		if (me.x >= icautomovers[i].mindx and me.x <= icautomovers[i].maxdx and me.y >= icautomovers[i].mindy and me.y <= icautomovers[i].maxdy and me.z >= icautomovers[i].mindz and me.z <= icautomovers[i].maxdz and amoving == false and amoving == false) {
			if (inv_item_number(icautomovers[i].item) >= 1) {
				int s = inv_item_number(icautomovers[i].item);
				if (s > icautomovers[i].amount) {
					if (icautomovers[i].text != " ") speak(icautomovers[i].text);
					can_move = false;
					if (icautomovers[i].ds3 != "silence" and sleepmode != 0) rvp.play_stationary(icautomovers[i].ds3, false);
					if (icautomovers[i].ds3 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + icautomovers[i].ds3, 7);
					icautomovers[i].icautomoversound2 = p.play_stationary(icautomovers[i].ds2, true);
					icautomovers[i].moving = true;
					amoving = true;
					send_reliable(peer_id, "iamamoving " + icautomovers[i].ds2, 0);
				} else
					speak("not enough " + icautomovers[i].item + ", you need " + icautomovers[i].amount + " " + icautomovers[i].item + "");
			} else
				speak("not enough " + icautomovers[i].item + ", you need " + icautomovers[i].amount + " " + icautomovers[i].item + "");
		}
	}
	for (uint i = 0; i < itautomovers.length(); i++) {
		if (me.x >= itautomovers[i].mindx and me.x <= itautomovers[i].maxdx and me.y >= itautomovers[i].mindy and me.y <= itautomovers[i].maxdy and me.z >= itautomovers[i].mindz and me.z <= itautomovers[i].maxdz and amoving == false and amoving == false) {
			if (inv_item_number(itautomovers[i].item) >= 1) {
				int s = inv_item_number(itautomovers[i].item);
				if (s > itautomovers[i].amount) {
					if (itautomovers[i].text != " ") speak(itautomovers[i].text);
					send_reliable(peer_id, "automovertake " + itautomovers[i].item + " " + itautomovers[i].amount, 0);
					can_move = false;
					if (itautomovers[i].ds3 != "silence" and sleepmode != 0) rvp.play_stationary(itautomovers[i].ds3, false);
					if (itautomovers[i].ds3 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + itautomovers[i].ds3, 7);
					itautomovers[i].itautomoversound2 = p.play_stationary(itautomovers[i].ds2, true);
					itautomovers[i].moving = true;
					amoving = true;
					send_reliable(peer_id, "iamamoving " + itautomovers[i].ds2, 0);
				} else
					speak("not enough " + itautomovers[i].item + ", you need " + itautomovers[i].amount + " " + itautomovers[i].item + "");
			} else
				speak("not enough " + itautomovers[i].item + ", you need " + itautomovers[i].amount + " " + itautomovers[i].item + "");
		}
	}
	for (uint i = 0; i < igautomovers.length(); i++) {
		if (me.x >= igautomovers[i].mindx and me.x <= igautomovers[i].maxdx and me.y >= igautomovers[i].mindy and me.y <= igautomovers[i].maxdy and me.z >= igautomovers[i].mindz and me.z <= igautomovers[i].maxdz and amoving == false and amoving == false) {
			if (igautomovers[i].text != " ") speak(igautomovers[i].text);
			send_reliable(peer_id, "automovergive " + igautomovers[i].item + " " + igautomovers[i].amount, 0);
			can_move = false;
			if (igautomovers[i].ds3 != "silence" and sleepmode != 0) rvp.play_stationary(igautomovers[i].ds3, false);
			if (igautomovers[i].ds3 != "silence" and sleepmode != 0) send_reliable(peer_id, "draw " + igautomovers[i].ds3, 7);
			igautomovers[i].igautomoversound2 = p.play_stationary(igautomovers[i].ds2, true);
			igautomovers[i].moving = true;
			amoving = true;
			send_reliable(peer_id, "iamamoving " + igautomovers[i].ds2, 0);
		}
	}
	if (get_tile_at(me.x, me.y, me.z) == "hazard")
		send_reliable(peer_id, "hhealth", 0);
	for (uint i = 0; i < teleporters.length(); i++) {
		if (me.x >= teleporters[i].minx and me.x <= teleporters[i].maxx and me.y >= teleporters[i].miny and me.y <= teleporters[i].maxy and me.z >= teleporters[i].minz and me.z <= teleporters[i].maxz) {
			p.play_stationary("tele.ogg", false);
			send_reliable(peer_id, "draw tele.ogg", 7);
			send_reliable(peer_id, "tmove", 8);
		}
	}
}
double compare_values(double n1, double n2) {
	return n1 - n2;
}
bool branca(int nome) {
	if (nome == 0 || nome == 1 || nome == 5 || nome == 19 || nome == 27 || nome == 28 || nome == 29)return true;
	else return false;
}
void telephonemenu() {
	bool jatem = false;
	for (uint i = 0; i < players.length(); i++) {
		if (players[i].name != name && players[i].x == me.x && players[i].y == me.y && players[i].z == me.z) {
			jatem = true;
			break;
		}
	}
	if (jatem == true)
		add_buffer_item("misc", "someone is using the phone!");
	else if (jatem == false) {
		string telefonar = tel.input("");
		can_move = false;
		sound s;
		s.load("telefone.ogg");
		int a = random(2, 9);
		for (int i = 0; i < a; i++) {
			s.play();
			if (telefonar > 0) send_reliable(peer_id, "phonering " + telefonar + "", 7);
			while (s.playing) {
				wait(5);
				mainloop();
				if (key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT)) {
					if (key_pressed(KEY_COMMA) == false and kcomma.pressing())
						prevbufferitem();
					if (key_pressed(KEY_PERIOD) == false and kperiod.pressing())
						nextbufferitem();
					if (key_pressed(KEY_LBRACKET) == false and klbracket.pressing())
						bufferleft();
					if (key_pressed(KEY_RBRACKET) == false and krbracket.pressing())
						bufferright();
				}
				if (shift_is_down()) {
					if (key_pressed(KEY_COMMA))
						topbufferitem();
					if (key_pressed(KEY_PERIOD))
						bottombufferitem();
					if (key_pressed(KEY_LBRACKET))
						firstbuffer();
					if (key_pressed(KEY_RBRACKET))
						lastbuffer();
				}
				if (key_pressed(KEY_SLASH)) {
					string chat = v.input("type your message here");
					if (chat != "" and !is_eloquence_crash_word(chat) and get_sequence(chat, true) <= 3) {
						string[] chats = string_split(chat, "::", true);
						if (chat != "") {
							string sendmsg = chat;
							for (uint a = 0; a < aliases.length(); a += 1) {
								string[] a2 = string_split(aliases[a], ":", false);
								if (a2.length() == 2)
									sendmsg = string_replace(sendmsg, a2[0], a2[1], true);
							}
							send_reliable(peer_id, sendmsg, 1);
						}
					}
				}
				if (key_pressed(KEY_BACKSLASH) and dlocalchat == 0) {
					string s = v.input("type your message here");
					if (s != "" and !is_eloquence_crash_word(s) and get_sequence(s, true) <= 3) {
						string sendmsg = s;
						for (uint a = 0; a < aliases.length(); a += 1) {
							string[] a2 = string_split(aliases[a], ":", false);
							if (a2.length() == 2)
								sendmsg = string_replace(sendmsg, a2[0], a2[1], true);
						}
						send_reliable(peer_id, "localchat " + sendmsg, 0);
					}
				}
				if (key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT) and key_up(KEY_LMENU) and key_up(KEY_RMENU) and key_pressed(KEY_EQUALS)) {
					string colocar = v.input("enter the command. Note: / will be put before it automaticly");
					if (colocar != "" and !is_eloquence_crash_word(colocar) and get_sequence(colocar, true) <= 3) {
						string sendmsg = colocar;
						for (uint a = 0; a < aliases.length(); a += 1) {
							string[] a2 = string_split(aliases[a], ":", false);
							if (a2.length() == 2)
								sendmsg = string_replace(sendmsg, a2[0], a2[1], true);
						}
						send_reliable(peer_id, "/" + sendmsg, 1);
					}
				}
			}
		}
		can_move = true;
	}
}
void piplay(string sound) {
	send_reliable(peer_id, "pipplay_online " + sound, 0);
}
int get_sequence(const string s, const bool only_alpha = false) {
	int o = 1;
	if (s.length() <= 1)
		return -1;
	for (uint i = 0; i < s.length(); i++) {
		for (uint ii = i + 1; ii < s.length(); ii++) {
			if (s[i] == s[ii]) {
				if (only_alpha and string_is_alphabetic(s[i]) or !only_alpha)
					o++;
				break;
			} else
				return o;
		}
	}
	return o;
}
bool is_eloquence_crash_word(string phrase) {
	phrase = string_to_lower_case(phrase);
	if (string_contains(phrase, ":22nd", 1) != -1)
		return true;
	if (string_contains(phrase, ":23nd", 1) != -1)
		return true;
	if (string_contains(phrase, ":24nd", 1) != -1)
		return true;
	if (string_contains(phrase, ":25nd", 1) != -1)
		return true;
	if (string_contains(phrase, "hesday", 1) != -1)
		return true;
	if (string_contains(phrase, "'d're", 1) != -1)
		return true;
	if (string_contains(phrase, "'d've", 1) != -1)
		return true;
	if (string_contains(phrase, "uncosp", 1) != -1)
		return true;
	if (string_contains(phrase, "deadhes", 1) != -1)
		return true;
	if (string_contains(phrase, "webhes", 1) != -1)
		return true;
	if (string_contains(phrase, "melhes", 1) != -1)
		return true;
	if (string_contains(phrase, "hesfall", 1) != -1)
		return true;
	if (string_contains(phrase, "hesspace", 1) != -1)
		return true;
	if (string_contains(phrase, "heskill", 1) != -1)
		return true;
	return false;
}
small find_joy(const string n) {
	const string[] joy = j.list_joysticks();
	small f = -1;
	if (j.joysticks == 0)
		return f;
	for (usmall i = 0; i < joy.length(); i++) {
		if (joy[i] == n) {
			f = i;
			break;
		}
	}
	return f;
}
string self_file() {
	if (SCRIPT_COMPILED)
		return SCRIPT_EXECUTABLE;
	else
		return SCRIPT_CURRENT_FILE;
}
void auction(string item) {
	llastuse = "";
	rlastuse = "";
	lefthand = "";
	righthand = "";
	draw = "";
	double amount = string_to_number(v.input("How many?"));
	if (amount > 0) {
		string currency = v.input("For what?", "coins");
		if (currency != "" and !is_eloquence_crash_word(currency) and get_sequence(currency, true) <= 3) {
			double minbid = string_to_number(v.input("minimum bid for this auction?"));
			if (minbid > 0) {
				if (askauction == 1) {
					setupmenu(false, true);
					m.add_item_tts("" + amount + " " + item + " for " + minbid + " " + currency + "", "yes");
					m.add_item_tts("no", "no");
					m.set_callback(netclb, "");
					int mres = m.run("Are you sure you want to auction " + amount + " " + item + " for " + minbid + " " + currency + "? press enter on " + amount + " " + item + " for " + minbid + " " + currency + " to confurm, and no to cancel", true);
					if (mres == 1)
						send_reliable(peer_id, "auction " + amount + " " + item + " " + currency + " " + minbid, 0);
					else {
						speak("canceled");
						return;
					}
				} else
					send_reliable(peer_id, "auction " + amount + " " + item + " " + currency + " " + minbid, 0);
			}
		}
	}
}
void bid(string currency, double amount) {
	if (askbid == 1) {
		setupmenu(false, true);
		m.add_item_tts("" + amount + " " + currency + "", "yes");
		m.add_item_tts("no", "no");
		m.set_callback(netclb, "");
		int mres = m.run("Are you sure you'd like to bid " + amount + " " + currency + "? press enter on " + amount + " " + currency + " to confurm, and no to cancel", true);
		if (mres == 1)
			send_reliable(peer_id, "bid " + amount, 0);
		else {
			speak("canceled");
			return;
		}
	} else
		send_reliable(peer_id, "bid " + amount, 0);
}
void transfer(string item) {
	double amount = string_to_number(v.input("How many " + item + "s would you like to transfer?"));
	if (amount != "")
		send_reliable(peer_id, "transfer " + item + " " + amount, 0);
}
string email(string address, string from, string subject, string message) {
	string n = "dl registration server";
	return url_post("http://aew-game.com/dl/fm.php", "who=" + address + "&name=" + n + "&from=" + from + "&sub=" + subject + "&mess=" + message);
}
void spy(int direction, int distance) {
	vector spyage(me.x, me.y, me.z);
	string materials;
	string tile = get_tile_at(spyage.x, spyage.y, spyage.z);
	for (uint i = 1; i < distance; i++) {
		if (direction == Left)
			spyage = move(spyage.x, spyage.y, spyage.z, facing, 0, west, 0);
		else if (direction == Right)
			spyage = move(spyage.x, spyage.y, spyage.z, facing, 0, east, 0);
		else if (direction == Forward)
			spyage = move(spyage.x, spyage.y, spyage.z, facing, 0, north, 0);
		else if (direction == Backward)
			spyage = move(spyage.x, spyage.y, spyage.z, facing, 0, south, 0);
		else if (direction == Up)
			spyage.z += 1;
		else if (direction == Down)
			spyage.z -= 1;
		if (spyage.x<min.x or spyage.x>max.x or spyage.y<min.y or spyage.y>max.y or spyage.z<min.z or spyage.z>max.z)
			continue;
		if (tile != get_tile_at(spyage.x, spyage.y, spyage.z)) {
			tile = get_tile_at(spyage.x, spyage.y, spyage.z);
			if (tile == "")
				materials += "air: " + i + " feet. ";
			else if (tile == "bathtub" or tile == "bathtub2" or tile == "bathtub3")
				materials += "bathtub: " + i + " feet. ";
			else if (tile == "bleacher" or tile == "bleacher2" or tile == "bleacher3" or tile == "bleacher4" or tile == "bleacher5" or tile == "bleacher6" or tile == "bleacher7" or tile == "bleacher8")
				materials += "bleacher: " + i + " feet. ";
			else if (tile == "branch" or tile == "branch2")
				materials += "branch: " + i + " feet. ";
			else if (tile == "bridge" or tile == "bridge2" or tile == "bridge3")
				materials += "bridge: " + i + " feet. ";
			else if (tile == "brokenglass")
				materials += "broken glass: " + i + " feet. ";
			else if (tile == "brush" or tile == "brush2" or tile == "brush3" or tile == "brush4" or tile == "brush5")
				materials += "brush: " + i + " feet. ";
			else if (tile == "carpet" or tile == "carpet2" or tile == "carpet3" or tile == "carpet4" or tile == "carpet5" or tile == "carpet6" or tile == "carpet7" or tile == "carpet8" or tile == "carpet9" or tile == "carpet10" or tile == "carpet11" or tile == "carpet12")
				materials += "carpet: " + i + " feet. ";
			else if (tile == "cavegrounds" or tile == "cavegrounds2")
				materials += "cavegrounds: " + i + " feet. ";
			else if (tile == "cement" or tile == "cement2" or tile == "cement3" or tile == "cement4")
				materials += "cement: " + i + " feet. ";
			else if (tile == "ceramic" or tile == "ceramic2" or tile == "ceramic3" or tile == "ceramic4")
				materials += "ceramic: " + i + " feet. ";
			else if (tile == "clay" or tile == "clay2" or tile == "clay3")
				materials += "clay: " + i + " feet. ";
			else if (tile == "concrete" or tile == "concrete2" or tile == "concrete3" or tile == "concrete4" or tile == "concrete5" or tile == "concrete6" or tile == "concrete7" or tile == "concrete8" or tile == "concrete9" or tile == "concrete10" or tile == "concrete11" or tile == "concrete12" or tile == "concrete13" or tile == "concrete14" or tile == "concrete15" or tile == "concrete16" or tile == "concrete17" or tile == "concrete18" or tile == "concrete19" or tile == "concrete20" or tile == "concrete21" or tile == "concrete22" or tile == "concrete23" or tile == "concrete24" or tile == "concrete25" or tile == "concrete26" or tile == "concrete27" or tile == "concrete28" or tile == "concrete29" or tile == "concrete30" or tile == "concrete31" or tile == "concrete32" or tile == "concrete33" or tile == "concrete34" or tile == "concrete35" or tile == "concrete36")
				materials += "concrete: " + i + " feet. ";
			else if (tile == "corpse" or tile == "corpse2")
				materials += "corpse: " + i + " feet. ";
			else if (tile == "deepsand" or tile == "deepsand2")
				materials += "deepsand: " + i + " feet. ";
			else if (tile == "dirt" or tile == "dirt2" or tile == "dirt3" or tile == "dirt4" or tile == "dirt5" or tile == "dirt6" or tile == "dirt7" or tile == "dirt8" or tile == "dirt9" or tile == "dirt10" or tile == "dirt11" or tile == "dirt12" or tile == "dirt13" or tile == "dirt14" or tile == "dirt15" or tile == "dirt16" or tile == "dirt17" or tile == "dirt18" or tile == "dirt19" or tile == "dirt20")
				materials += "dirt: " + i + " feet. ";
			else if (tile == "fence" or tile == "fence2")
				materials += "fence: " + i + " feet. ";
			else if (tile == "glass" or tile == "glass2" or tile == "glass3" or tile == "glass4" or tile == "glass5" or tile == "glass6" or tile == "glass7")
				materials += "glass: " + i + " feet. ";
			else if (tile == "grass" or tile == "grass2" or tile == "grass3" or tile == "grass4" or tile == "grass5" or tile == "grass6" or tile == "grass7" or tile == "grass8" or tile == "grass9" or tile == "grass10")
				materials += "grass: " + i + " feet. ";
			else if (tile == "gravel" or tile == "gravel2" or tile == "gravel3" or tile == "gravel4" or tile == "gravel5" or tile == "gravel6" or tile == "gravel7" or tile == "gravel8" or tile == "gravel9" or tile == "gravel10" or tile == "gravel11")
				materials += "gravel: " + i + " feet. ";
			else if (tile == "hardwood" or tile == "hardwood2" or tile == "hardwood3" or tile == "hardwood4" or tile == "hardwood5" or tile == "hardwood6" or tile == "hardwood7")
				materials += "hardwood: " + i + " feet. ";
			else if (tile == "ice" or tile == "ice2" or tile == "ice3" or tile == "ice4")
				materials += "ice: " + i + " feet. ";
			else if (tile == "ladder" or tile == "ladder2" or tile == "ladder3")
				materials += "ladder: " + i + " feet. ";
			else if (tile == "leaves" or tile == "leaves2" or tile == "leaves3" or tile == "leaves4" or tile == "leaves5")
				materials += "leaves: " + i + " feet. ";
			else if (tile == "ledge" or tile == "ledge2")
				materials += "ledge: " + i + " feet. ";
			else if (tile == "marble" or tile == "marble2" or tile == "marble3" or tile == "marble4" or tile == "marble5" or tile == "marble6" or tile == "marble7")
				materials += "marble: " + i + " feet. ";
			else if (tile == "marsh" or tile == "marsh2")
				materials += "marsh: " + i + " feet. ";
			else if (tile == "metal" or tile == "metal2" or tile == "metal3" or tile == "metal4" or tile == "metal5" or tile == "metal6" or tile == "metal7" or tile == "metal8" or tile == "metal9" or tile == "metal10" or tile == "metal11" or tile == "metal12" or tile == "metal13" or tile == "metal14" or tile == "metal15" or tile == "metal16" or tile == "metal17" or tile == "metal18" or tile == "metal19" or tile == "metal20" or tile == "metal21" or tile == "metal22")
				materials += "metal: " + i + " feet. ";
			else if (tile == "mud" or tile == "mud2" or tile == "mud3" or tile == "mud4" or tile == "mud5" or tile == "mud6" or tile == "mud7")
				materials += "mud: " + i + " feet. ";
			else if (tile == "pipe" or tile == "pipe2" or tile == "pipe3")
				materials += "pipe: " + i + " feet. ";
			else if (tile == "plywood" or tile == "plywood2" or tile == "plywood3" or tile == "plywood4")
				materials += "plywood: " + i + " feet. ";
			else if (tile == "rocks" or tile == "rocks2" or tile == "rocks3" or tile == "rocks4" or tile == "rocks5")
				materials += "rocks: " + i + " feet. ";
			else if (tile == "roof" or tile == "roof2" or tile == "roof3" or tile == "roof4")
				materials += "roof: " + i + " feet. ";
			else if (tile == "sand" or tile == "sand2" or tile == "sand3" or tile == "sand4" or tile == "sand5" or tile == "sand6" or tile == "sand7")
				materials += "sand: " + i + " feet. ";
			else if (tile == "sewer" or tile == "sewer2")
				materials += "sewer: " + i + " feet. ";
			else if (tile == "snow" or tile == "snow2" or tile == "snow3" or tile == "snow4" or tile == "snow5" or tile == "snow6" or tile == "snow7" or tile == "snow8" or tile == "snow9" or tile == "snow10" or tile == "snow11" or tile == "snow12" or tile == "snow13" or tile == "snow_wet" or tile == "deepsnow")
				materials += "snow: " + i + " feet. ";
			else if (tile == "spring" or tile == "spring2")
				materials += "spring: " + i + " feet. ";
			else if (tile == "stairs" or tile == "stairs2" or tile == "stairs3" or tile == "stairs4")
				materials += "stairs: " + i + " feet. ";
			else if (tile == "steel" or tile == "steel2" or tile == "steel3" or tile == "steel4" or tile == "steel5")
				materials += "steel: " + i + " feet. ";
			else if (tile == "stone" or tile == "stone2" or tile == "stone3" or tile == "stone4" or tile == "stone5")
				materials += "stone: " + i + " feet. ";
			else if (tile == "swamp" or tile == "swamp2")
				materials += "swamp: " + i + " feet. ";
			else if (tile == "swimming" or tile == "swimming2")
				materials += "swimming: " + i + " feet. ";
			else if (tile == "tile" or tile == "tile2" or tile == "tile3" or tile == "tile4" or tile == "tile5" or tile == "tile6" or tile == "tile7" or tile == "tile8")
				materials += "tile: " + i + " feet. ";
			else if (tile == "water" or tile == "water2" or tile == "water3" or tile == "water4" or tile == "water5" or tile == "water6" or tile == "water7" or tile == "water8" or tile == "water9" or tile == "water10" or tile == "wallboat")
				materials += "water: " + i + " feet. ";
			else if (tile == "weed" or tile == "weed2" or tile == "weed3")
				materials += "weed: " + i + " feet. ";
			else if (tile == "wetconcrete" or tile == "wetconcrete2")
				materials += "wetconcrete: " + i + " feet. ";
			else if (tile == "wood" or tile == "wood2" or tile == "wood3" or tile == "wood4" or tile == "wood5" or tile == "wood6" or tile == "wood7" or tile == "wood8" or tile == "wood9" or tile == "wood10" or tile == "wood11" or tile == "wood12" or tile == "wood13" or tile == "wood14" or tile == "wood15" or tile == "wood16" or tile == "wood17" or tile == "wood18")
				materials += "wood: " + i + " feet. ";
			else if (string_contains(get_tile_at(spyage.x, spyage.y, spyage.z), "wall", 1) > -1)
				materials += "wall: " + i + " feet. ";
			else
				materials += tile + ": " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < players.length(); i2++) {
			if (dspyplayer == 0 and players[i2].x == spyage.x and players[i2].y == spyage.y and players[i2].z == spyage.z and players[i2].name != name and players[i2].map == mapname + "")
				materials += players[i2].name + ": " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < mapitems.length(); i2++) {
			if (dspyitem == 0 and mapitems[i2].x == spyage.x and mapitems[i2].y == spyage.y and mapitems[i2].z == spyage.z and mapitems[i2].map == mapname + "")
				materials += "item: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < doors.length(); i2++) {
			if (dspydoor == 0 and spyage.x >= doors[i2].mindx and spyage.x <= doors[i2].maxdx and spyage.y >= doors[i2].mindy and spyage.y <= doors[i2].maxdy and spyage.z >= doors[i2].mindz and spyage.z <= doors[i2].maxdz + "")
				materials += "door: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < pdoors.length(); i2++) {
			if (dspypdoor == 0 and spyage.x >= pdoors[i2].mindx and spyage.x <= pdoors[i2].maxdx and spyage.y >= pdoors[i2].mindy and spyage.y <= pdoors[i2].maxdy and spyage.z >= pdoors[i2].mindz and spyage.z <= pdoors[i2].maxdz + "")
				materials += "password protected door: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < icdoors.length(); i2++) {
			if (dspyicdoor == 0 and spyage.x >= icdoors[i2].mindx and spyage.x <= icdoors[i2].maxdx and spyage.y >= icdoors[i2].mindy and spyage.y <= icdoors[i2].maxdy and spyage.z >= icdoors[i2].mindz and spyage.z <= icdoors[i2].maxdz + "")
				materials += "item checker door: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < itdoors.length(); i2++) {
			if (dspyitdoor == 0 and spyage.x >= itdoors[i2].mindx and spyage.x <= itdoors[i2].maxdx and spyage.y >= itdoors[i2].mindy and spyage.y <= itdoors[i2].maxdy and spyage.z >= itdoors[i2].mindz and spyage.z <= itdoors[i2].maxdz + "")
				materials += "item taker door: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < igdoors.length(); i2++) {
			if (dspyigdoor == 0 and spyage.x >= igdoors[i2].mindx and spyage.x <= igdoors[i2].maxdx and spyage.y >= igdoors[i2].mindy and spyage.y <= igdoors[i2].maxdy and spyage.z >= igdoors[i2].mindz and spyage.z <= igdoors[i2].maxdz + "")
				materials += "item giver door: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < automovers.length(); i2++) {
			if (dspyautomover == 0 and spyage.x >= automovers[i2].mindx and spyage.x <= automovers[i2].maxdx and spyage.y >= automovers[i2].mindy and spyage.y <= automovers[i2].maxdy and spyage.z >= automovers[i2].mindz and spyage.z <= automovers[i2].maxdz + "")
				materials += "automover: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < pautomovers.length(); i2++) {
			if (dspypautomover == 0 and spyage.x >= pautomovers[i2].mindx and spyage.x <= pautomovers[i2].maxdx and spyage.y >= pautomovers[i2].mindy and spyage.y <= pautomovers[i2].maxdy and spyage.z >= pautomovers[i2].mindz and spyage.z <= pautomovers[i2].maxdz + "")
				materials += "password protected automover: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < icautomovers.length(); i2++) {
			if (dspyicautomover == 0 and spyage.x >= icautomovers[i2].mindx and spyage.x <= icautomovers[i2].maxdx and spyage.y >= icautomovers[i2].mindy and spyage.y <= icautomovers[i2].maxdy and spyage.z >= icautomovers[i2].mindz and spyage.z <= icautomovers[i2].maxdz + "")
				materials += "item checker automover: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < itautomovers.length(); i2++) {
			if (dspyitautomover == 0 and spyage.x >= itautomovers[i2].mindx and spyage.x <= itautomovers[i2].maxdx and spyage.y >= itautomovers[i2].mindy and spyage.y <= itautomovers[i2].maxdy and spyage.z >= itautomovers[i2].mindz and spyage.z <= itautomovers[i2].maxdz + "")
				materials += "item taker automover: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < igautomovers.length(); i2++) {
			if (dspyigautomover == 0 and spyage.x >= igautomovers[i2].mindx and spyage.x <= igautomovers[i2].maxdx and spyage.y >= igautomovers[i2].mindy and spyage.y <= igautomovers[i2].maxdy and spyage.z >= igautomovers[i2].mindz and spyage.z <= igautomovers[i2].maxdz + "")
				materials += "item giver automover: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < automatic_travelpoints.length(); i2++) {
			if (dspyautomatic_travelpoint == 0 and spyage.x >= automatic_travelpoints[i2].mindx and spyage.x <= automatic_travelpoints[i2].maxdx and spyage.y >= automatic_travelpoints[i2].mindy and spyage.y <= automatic_travelpoints[i2].maxdy and spyage.z >= automatic_travelpoints[i2].mindz and spyage.z <= automatic_travelpoints[i2].maxdz + "")
				materials += "automatic_travelpoint: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < pautomatic_travelpoints.length(); i2++) {
			if (dspypautomatic_travelpoint == 0 and spyage.x >= pautomatic_travelpoints[i2].mindx and spyage.x <= pautomatic_travelpoints[i2].maxdx and spyage.y >= pautomatic_travelpoints[i2].mindy and spyage.y <= pautomatic_travelpoints[i2].maxdy and spyage.z >= pautomatic_travelpoints[i2].mindz and spyage.z <= pautomatic_travelpoints[i2].maxdz + "")
				materials += "password protected automatic_travelpoint: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < icautomatic_travelpoints.length(); i2++) {
			if (dspyicautomatic_travelpoint == 0 and spyage.x >= icautomatic_travelpoints[i2].mindx and spyage.x <= icautomatic_travelpoints[i2].maxdx and spyage.y >= icautomatic_travelpoints[i2].mindy and spyage.y <= icautomatic_travelpoints[i2].maxdy and spyage.z >= icautomatic_travelpoints[i2].mindz and spyage.z <= icautomatic_travelpoints[i2].maxdz + "")
				materials += "item checker automatic_travelpoint: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < itautomatic_travelpoints.length(); i2++) {
			if (dspyitautomatic_travelpoint == 0 and spyage.x >= itautomatic_travelpoints[i2].mindx and spyage.x <= itautomatic_travelpoints[i2].maxdx and spyage.y >= itautomatic_travelpoints[i2].mindy and spyage.y <= itautomatic_travelpoints[i2].maxdy and spyage.z >= itautomatic_travelpoints[i2].mindz and spyage.z <= itautomatic_travelpoints[i2].maxdz + "")
				materials += "item taker automatic_travelpoint: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < igautomatic_travelpoints.length(); i2++) {
			if (dspyigautomatic_travelpoint == 0 and spyage.x >= igautomatic_travelpoints[i2].mindx and spyage.x <= igautomatic_travelpoints[i2].maxdx and spyage.y >= igautomatic_travelpoints[i2].mindy and spyage.y <= igautomatic_travelpoints[i2].maxdy and spyage.z >= igautomatic_travelpoints[i2].mindz and spyage.z <= igautomatic_travelpoints[i2].maxdz + "")
				materials += "item giver automatic_travelpoint: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < travelpoints.length(); i2++) {
			if (dspytravelpoint == 0 and spyage.x >= travelpoints[i2].mindx and spyage.x <= travelpoints[i2].maxdx and spyage.y >= travelpoints[i2].mindy and spyage.y <= travelpoints[i2].maxdy and spyage.z >= travelpoints[i2].mindz and spyage.z <= travelpoints[i2].maxdz + "")
				materials += "travelpoint: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < ptravelpoints.length(); i2++) {
			if (dspyptravelpoint == 0 and spyage.x >= ptravelpoints[i2].mindx and spyage.x <= ptravelpoints[i2].maxdx and spyage.y >= ptravelpoints[i2].mindy and spyage.y <= ptravelpoints[i2].maxdy and spyage.z >= ptravelpoints[i2].mindz and spyage.z <= ptravelpoints[i2].maxdz + "")
				materials += "password protected travelpoint: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < ictravelpoints.length(); i2++) {
			if (dspyictravelpoint == 0 and spyage.x >= ictravelpoints[i2].mindx and spyage.x <= ictravelpoints[i2].maxdx and spyage.y >= ictravelpoints[i2].mindy and spyage.y <= ictravelpoints[i2].maxdy and spyage.z >= ictravelpoints[i2].mindz and spyage.z <= ictravelpoints[i2].maxdz + "")
				materials += "item checker travelpoint: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < ittravelpoints.length(); i2++) {
			if (dspyittravelpoint == 0 and spyage.x >= ittravelpoints[i2].mindx and spyage.x <= ittravelpoints[i2].maxdx and spyage.y >= ittravelpoints[i2].mindy and spyage.y <= ittravelpoints[i2].maxdy and spyage.z >= ittravelpoints[i2].mindz and spyage.z <= ittravelpoints[i2].maxdz + "")
				materials += "item taker travelpoint: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < igtravelpoints.length(); i2++) {
			if (dspyigtravelpoint == 0 and spyage.x >= igtravelpoints[i2].mindx and spyage.x <= igtravelpoints[i2].maxdx and spyage.y >= igtravelpoints[i2].mindy and spyage.y <= igtravelpoints[i2].maxdy and spyage.z >= igtravelpoints[i2].mindz and spyage.z <= igtravelpoints[i2].maxdz + "")
				materials += "item giver travelpoint: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < vanishing_platforms.length(); i2++) {
			if (dspyvp == 0 and vanishing_platforms[i2].vanished == true and spyage.x >= vanishing_platforms[i2].minx and spyage.x <= vanishing_platforms[i2].maxx and spyage.y >= vanishing_platforms[i2].miny and spyage.y <= vanishing_platforms[i2].maxy and spyage.z >= vanishing_platforms[i2].minz and spyage.z <= vanishing_platforms[i2].maxz + "")
				materials += "vanishing platform: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < forcefields.length(); i2++) {
			if (dspyff == 0 and forcefields[i2].forcefielded == true and spyage.x >= forcefields[i2].minx and spyage.x <= forcefields[i2].maxx and spyage.y >= forcefields[i2].miny and spyage.y <= forcefields[i2].maxy and spyage.z >= forcefields[i2].minz and spyage.z <= forcefields[i2].maxz + "")
				materials += "forcefield: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < teleporters.length(); i2++) {
			if (dspytp == 0 and spyage.x >= teleporters[i2].minx and spyage.x <= teleporters[i2].maxx and spyage.y >= teleporters[i2].miny and spyage.y <= teleporters[i2].maxy and spyage.z >= teleporters[i2].minz and spyage.z <= teleporters[i2].maxz + "")
				materials += "teleporter: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < signs.length(); i2++) {
			if (dspysign == 0 and spyage.x >= signs[i2].minx and spyage.x <= signs[i2].maxx and spyage.y >= signs[i2].miny and spyage.y <= signs[i2].maxy and spyage.z >= signs[i2].minz and spyage.z <= signs[i2].maxz + "")
				materials += "sign: " + i + " feet. ";
		}
		for (uint i2 = 0; i2 < txts.length(); i2++) {
			if (dspytxt == 0 and spyage.x >= txts[i2].minx and spyage.x <= txts[i2].maxx and spyage.y >= txts[i2].miny and spyage.y <= txts[i2].maxy and spyage.z >= txts[i2].minz and spyage.z <= txts[i2].maxz + "")
				materials += "txt: " + i + " feet. ";
		}
	}
	if (materials == "")
		materials = "Nothing in this direction";
	speak(materials);
}
bool is_sound_number(string t) {
	if (sleepmode != -1) return false;
	t = string_replace(t, ".", "", true);
	t = string_replace(t, "-", "", true);
	if (string_is_digits(t))
		return true;
	return false;
}
void chat_lcm() {
	string msg = input("LCM", "type your message here", multiline = true);
	if (msg != "" and !is_eloquence_crash_word(msg) and get_sequence(msg, true) <= 3)send_reliable(peer_id, "lcm " + msg, 0);
}
void chat_manager() {
	string msg = input("Manager", "type your message here", multiline = true);
	if (msg != "" and !is_eloquence_crash_word(msg) and get_sequence(msg, true) <= 3)send_reliable(peer_id, "manager " + msg, 0);
}
void chat_administrativo() {
	string msg = input("Admin", "type your message here", multiline = true);
	if (msg != "" and !is_eloquence_crash_word(msg) and get_sequence(msg, true) <= 3)send_reliable(peer_id, "adm " + msg, 0);
}
void chat_dev() {
	string msg = input("Developer", "type your message here", multiline = true);
	if (msg != "" and !is_eloquence_crash_word(msg) and get_sequence(msg, true) <= 3)send_reliable(peer_id, "devc " + msg, 0);
}
void chat_partner() {
	string msg = input("Partnar", "type your message here", multiline = true);
	if (msg != "" and !is_eloquence_crash_word(msg) and get_sequence(msg, true) <= 3)send_reliable(peer_id, "partnerchat2 " + msg, 0);
}
void lower_pitch_in_pool(sound_pool@ handle, sound_pool@ handle2, sound_pool@ handle3, sound_pool@ handle4, sound_pool@ handle5, sound_pool@ handle6, sound_pool@ handle7, sound_pool@ handle8, double time = 0.35, double minpitch = -100) {
	for (double current = 0; current > minpitch; current -= time) {
		for (uint x = 0; x < handle.items.length(); x++) {
			if (@handle.items[x].handle == null)
				break;
			if (handle.items[x].handle.playing == false)
				break;
			handle.items[x].handle.pitch = handle.items[x].handle.pitch - time;
		}
		for (uint y = 0; y < handle2.items.length(); y++) {
			if (@handle2.items[y].handle == null)
				break;
			if (handle2.items[y].handle.playing == false)
				break;
			handle2.items[y].handle.pitch = handle2.items[y].handle.pitch - time;
		}
		for (uint z = 0; z < handle3.items.length(); z++) {
			if (@handle3.items[z].handle == null)
				break;
			if (handle3.items[z].handle.playing == false)
				break;
			handle3.items[z].handle.pitch = handle3.items[z].handle.pitch - time;
		}
		for (uint w = 0; w < handle4.items.length(); w++) {
			if (@handle4.items[w].handle == null)
				break;
			if (handle4.items[w].handle.playing == false)
				break;
			handle4.items[w].handle.pitch = handle4.items[w].handle.pitch - time;
		}
		for (uint sourcesounds = 0; sourcesounds < handle5.items.length(); sourcesounds++) {
			if (@handle5.items[sourcesounds].handle == null)
				break;
			if (handle5.items[sourcesounds].handle.playing == false)
				break;
			handle5.items[sourcesounds].handle.pitch = handle5.items[sourcesounds].handle.pitch - time;
		}
		for (uint musicsounds = 0; musicsounds < handle6.items.length(); musicsounds++) {
			if (@handle6.items[musicsounds].handle == null)
				break;
			if (handle6.items[musicsounds].handle.playing == false)
				break;
			handle6.items[musicsounds].handle.pitch = handle6.items[musicsounds].handle.pitch - time;
		}
		for (uint signsounds = 0; signsounds < handle7.items.length(); signsounds++) {
			if (@handle7.items[signsounds].handle == null)
				break;
			if (handle7.items[signsounds].handle.playing == false)
				break;
			handle7.items[signsounds].handle.pitch = handle7.items[signsounds].handle.pitch - time;
		}
		for (uint mapitemsounds = 0; mapitemsounds < handle8.items.length(); mapitemsounds++) {
			if (@handle8.items[mapitemsounds].handle == null)
				break;
			if (handle8.items[mapitemsounds].handle.playing == false)
				break;
			handle8.items[mapitemsounds].handle.pitch = handle8.items[mapitemsounds].handle.pitch - time;
		}
		wait(5);
	}
	handle.destroy_all();
	handle2.destroy_all();
	handle3.destroy_all();
	handle4.destroy_all();
	handle5.destroy_all();
	handle6.destroy_all();
	handle7.destroy_all();
	handle8.destroy_all();
}
void sendkey(string number) {
	if (script_keys.length() < 1)
		speak("Script key not assigned.");
	else {
		for (uint i = 0; i < script_keys.length(); i += 1) {
			string[] a2 = string_split(script_keys[i], ":", false);
			if (a2.length() == 2) {
				if (a2[0] == number)
					send_reliable(peer_id, a2[1], 1);
				else {
				}
			}
		}
	}
}
void checksonar() {
	if (sonar == 1) {
		int sonarx = me.x;
		for (uint i = sonarx; i >= sonarx - sonarrange; i--) {
			if (get_tile_at(i, me.y, me.z) != get_tile_at(me.x, me.y, me.z) and string_contains(get_tile_at(i, me.y, me.z), "wall", 1) == -1) {
				p.play_3d("sonartile.ogg", me.x, me.y, me.z, i, me.y, me.z, calculate_theta(facing), false);
				break;
			} else if (get_tile_at(i, me.y, me.z) != get_tile_at(me.x, me.y, me.z) and get_tile_at(i, me.y, me.z) != "") {
				p.play_3d("sonarair.ogg", me.x, me.y, me.z, i, me.y, me.z, calculate_theta(facing), false);
				break;
			} else if (get_tile_at(i, me.y, me.z) == "" and jumping == false) {
				p.play_3d("sonarhazard.ogg", me.x, me.y, me.z, i, me.y, me.z, calculate_theta(facing), false);
				break;
			} else if (string_contains(get_tile_at(i, me.y, me.z), "wall", 1) > -1) {
				p.play_3d("sonarwall2.ogg", me.x, me.y, me.z, i, me.y, me.z, calculate_theta(facing), false);
				break;
			}
		}
	}
	if (sonar == 2) {
		int sonarz = me.z + 1;
		for (uint i = sonarz; i <= sonarz + 10; i++) {
			if (get_tile_at(me.x, me.y, i) != "") {
				p.play_3d("sonarwall2.ogg", me.x, me.y, me.z, me.x, me.y, i, calculate_theta(facing), false);
				break;
			}
		}
	}
	if (sonar == 3) {
		int sonarx = me.x;
		for (uint i = sonarx; i <= sonarx + sonarrange; i++) {
			if (get_tile_at(i, me.y, me.z) != get_tile_at(me.x, me.y, me.z) and string_contains(get_tile_at(i, me.y, me.z), "wall", 1) == -1) {
				p.play_3d("sonartile.ogg", me.x, me.y, me.z, i, me.y, me.z, calculate_theta(facing), false);
				break;
			} else if (get_tile_at(i, me.y, me.z) == "" and jumping == false) {
				p.play_3d("sonarair.ogg", me.x, me.y, me.z, i, me.y, me.z, calculate_theta(facing), false);
				break;
			} else if (get_tile_at(i, me.y, me.z) == "" and jumping == false) {
				p.play_3d("sonarhazard.ogg", me.x, me.y, me.z, i, me.y, me.z, calculate_theta(facing), false);
				break;
			} else if (string_contains(get_tile_at(i, me.y, me.z), "wall", 1) > -1) {
				p.play_3d("sonarwall2.ogg", me.x, me.y, me.z, i, me.y, me.z, calculate_theta(facing), false);
				break;
			}
		}
	}
	if (sonar == 4) {
		int sonary = me.y;
		for (uint i = sonary; i >= sonary - sonarrange; i--) {
			if (get_tile_at(me.x, i, me.z) != get_tile_at(me.x, me.y, me.z) and string_contains(get_tile_at(me.x, i, me.z), "wall", 1) == -1) {
				p.play_3d("sonartile.ogg", me.x, me.y, me.z, me.x, i, me.z, calculate_theta(facing), false);
				break;
			} else if (get_tile_at(me.x, i, me.z) != get_tile_at(me.x, me.y, me.z) and get_tile_at(me.x, i, me.z) != "") {
				p.play_3d("sonarair.ogg", me.x, me.y, me.z, me.x, i, me.z, calculate_theta(facing), false);
				break;
			} else if (get_tile_at(me.x, i, me.z) == "" and jumping == false) {
				p.play_3d("sonarhazard.ogg", me.x, me.y, me.z, me.x, i, me.z, calculate_theta(facing), false);
				break;
			} else if (string_contains(get_tile_at(i, me.y, me.z), "wall", 1) > -1) {
				p.play_3d("sonarwall2.ogg", me.x, me.y, me.z, me.x, i, me.z, calculate_theta(facing), false);
				break;
			}
		}
	}
	if (sonar == 5) {
		int sonary = me.y;
		for (uint i = sonary; i <= sonary + sonarrange; i++) {
			if (get_tile_at(me.x, i, me.z) != get_tile_at(me.x, me.y, me.z) and string_contains(get_tile_at(me.x, i, me.z), "wall", 1) == -1) {
				p.play_3d("sonartile.ogg", me.x, me.y, me.z, me.x, i, me.z, calculate_theta(facing), false);
				break;
			} else if (get_tile_at(me.x, i, me.z) == "" and jumping == false) {
				p.play_3d("sonarair.ogg", me.x, me.y, me.z, me.x, i, me.z, calculate_theta(facing), false);
				break;
			} else if (get_tile_at(me.x, i, me.z) == "" and jumping == false) {
				p.play_3d("sonarhazard.ogg", me.x, me.y, me.z, me.x, i, me.z, calculate_theta(facing), false);
				break;
			} else if (string_contains(get_tile_at(i, me.y, me.z), "wall", 1) > -1) {
				p.play_3d("sonarwall2.ogg", me.x, me.y, me.z, me.x, i, me.z, calculate_theta(facing), false);
				break;
			}
		}
	}
}
void civilregistrymenu() {
	string nick = v.input("type your new nickname");
	if (nick != "" and !is_eloquence_crash_word(nick) and get_sequence(nick, true) <= 3)
		send_reliable(peer_id, "nickname " + nick, 0);
}
void MessageBox(string title, string message) {
}
void msocialmenu() {
	string soundfile = list_msocials();
	if (soundfile == "") {
		speak("canceled");
		return;
	}
	rvp.play_stationary(soundfile + ".ogg", false);
	send_reliable(peer_id, "draw " + soundfile + ".ogg", 7);
}
void fsocialmenu() {
	string soundfile = list_fsocials();
	if (soundfile == "") {
		speak("canceled");
		return;
	}
	rvp.play_stationary(soundfile + ".ogg", false);
	send_reliable(peer_id, "draw " + soundfile + ".ogg", 7);
}
int mts(int s) {
	return s * 1000;
}
bool string_contains_numbers(string scn) {
	if (string_contains(scn, "1", 1) > -1 or string_contains(scn, "2", 1) > -1 or string_contains(scn, "3", 1) > -1 or string_contains(scn, "4", 1) > -1 or string_contains(scn, "5", 1) > -1 or string_contains(scn, "6", 1) > -1 or string_contains(scn, "7", 1) > -1 or string_contains(scn, "8", 1) > -1 or string_contains(scn, "9", 1) > -1 or string_contains(scn, "0", 1) > -1 or string_contains(scn, "-", 1) > -1)
		return true;
	return false;
}
void uploadfile(bool stationary = false) {
	string sf = soundsmenu();
	if (sf != "") {
		file fr;
		fr.open("upsounds/" + sf, "rb");
		send_reliable(peer_id, "up_voice " + fr.read(), 3);
		fr.close();
	}
}
void srcv(string s, double vl = volume, double spitch = pitch) {
	speak("Press or hold space to play/pause the track. Press or hold up and down arrows to change the sound volume. Press or hold left and right arrows to change it's pitch. Press or hold r to reset the volume and pitch. Press or hold q to seek backward. Press or hold e to seek forward. Press or hold w to go to the beginning of the track. Press escape to cancel. Press enter to submit");
	sound tst;
	tst.load(s + ".ogg");
	tst.volume = volume;
	tst.pitch = pitch;
	tst.play_looped();
	while (true) {
		wait(5);
		mainloop();
		if (key_pressed(KEY_DOWN) == false and kdown.pressing() and volume > -60) {
			volume += -1;
			tst.volume = volume;
			speak(volume);
		}
		if (key_pressed(KEY_UP) == false and kup.pressing() and volume < 0) {
			volume += 1;
			tst.volume = volume;
			speak(volume);
		}
		if (key_pressed(KEY_LEFT) == false and kleft.pressing() and pitch > 0) {
			pitch += -1;
			tst.pitch = pitch;
			speak(pitch);
		}
		if (key_pressed(KEY_RIGHT) == false and kright.pressing() and pitch < 200) {
			pitch += 1;
			tst.pitch = pitch;
			speak(pitch);
		}
		if (key_pressed(KEY_Q) == false and kq.pressing())
			tst.seek(tst.position - 1000);
		if (key_pressed(KEY_W) == false and kw.pressing())
			tst.seek(0);
		if (key_pressed(KEY_E) == false and ke.pressing())
			tst.seek(tst.position + 1000);
		if (key_pressed(KEY_R) == false and kr.pressing()) {
			volume = 0;
			pitch = 100;
			tst.volume = volume;
			tst.pitch = pitch;
			speak("the volume and pitch has been reset. Volume: 0. Pitch: 100");
		}
		if (key_pressed(KEY_SPACE) == false and kspace.pressing()) {
			if (tst.playing == true)
				tst.pause();
			else
				tst.play();
		}
		if (key_pressed(KEY_ESCAPE)) {
			speak("canceled");
			tst.stop();
			tst.close();
			return;
		}
		if (key_pressed(KEY_RETURN)) {
			tst.stop();
			tst.close();
			return;
		}
	}
}
void allsoundsvp(string s, double vl = allsoundsvolume, double sallsoundspitch = allsoundspitch) {
	speak("Press or hold space to play/pause the track. Press or hold up and down arrows to change the sound allsoundsvolume. Press or hold left and right arrows to change it's allsoundspitch. Press or hold r to reset the allsoundsvolume and allsoundspitch. Press or hold q to seek backward. Press or hold e to seek forward. Press or hold w to go to the beginning of the track. Press escape to cancel. Press enter to submit");
	sound tst;
	tst.load(s + ".ogg");
	tst.volume = allsoundsvolume;
	tst.pitch = allsoundspitch;
	tst.play_looped();
	while (true) {
		wait(5);
		mainloop();
		if (key_pressed(KEY_DOWN) == false and kdown.pressing() and allsoundsvolume > -60) {
			allsoundsvolume += -1;
			tst.volume = allsoundsvolume;
			speak(allsoundsvolume);
		}
		if (key_pressed(KEY_UP) == false and kup.pressing() and allsoundsvolume < 0) {
			allsoundsvolume += 1;
			tst.volume = allsoundsvolume;
			speak(allsoundsvolume);
		}
		if (key_pressed(KEY_LEFT) == false and kleft.pressing() and allsoundspitch > 0) {
			allsoundspitch += -1;
			tst.pitch = allsoundspitch;
			speak(allsoundspitch);
		}
		if (key_pressed(KEY_RIGHT) == false and kright.pressing() and allsoundspitch < 200) {
			allsoundspitch += 1;
			tst.pitch = allsoundspitch;
			speak(allsoundspitch);
		}
		if (key_pressed(KEY_Q) == false and kq.pressing())
			tst.seek(tst.position - 1000);
		if (key_pressed(KEY_W) == false and kw.pressing())
			tst.seek(0);
		if (key_pressed(KEY_E) == false and ke.pressing())
			tst.seek(tst.position + 1000);
		if (key_pressed(KEY_R) == false and kr.pressing()) {
			allsoundsvolume = 0;
			allsoundspitch = 100;
			tst.volume = allsoundsvolume;
			tst.pitch = allsoundspitch;
			speak("the sound volume and sound pitch has been reset. sound volume: 0. sound pitch: 100");
		}
		if (key_pressed(KEY_SPACE) == false and kspace.pressing()) {
			if (tst.playing == true)
				tst.pause();
			else
				tst.play();
		}
		if (key_pressed(KEY_ESCAPE)) {
			speak("canceled");
			tst.stop();
			tst.close();
			return;
		}
		if (key_pressed(KEY_RETURN)) {
			tst.stop();
			tst.close();
			return;
		}
	}
}
void aistepsoundsrcv(string s, double vl = stepsoundvolume, double sstepsoundpitch = stepsoundpitch) {
	speak("step sound options. Press or hold space to play/pause the track. Press or hold up and down arrows to change the sound stepsoundvolume. Press or hold left and right arrows to change it's stepsoundpitch. Press or hold r to reset the stepsoundvolume and stepsoundpitch. Press or hold q to seek backward. Press or hold e to seek forward. Press or hold w to go to the beginning of the track. Press escape to cancel. Press enter to submit");
	sound tst;
	tst.load(s);
	tst.volume = stepsoundvolume;
	tst.pitch = stepsoundpitch;
	tst.play_looped();
	while (true) {
		wait(5);
		mainloop();
		if (key_pressed(KEY_DOWN) == false and kdown.pressing() and stepsoundvolume > -60) {
			stepsoundvolume += -1;
			tst.volume = stepsoundvolume;
			speak(stepsoundvolume);
		}
		if (key_pressed(KEY_UP) == false and kup.pressing() and stepsoundvolume < 0) {
			stepsoundvolume += 1;
			tst.volume = stepsoundvolume;
			speak(stepsoundvolume);
		}
		if (key_pressed(KEY_LEFT) == false and kleft.pressing() and stepsoundpitch > 0) {
			stepsoundpitch += -1;
			tst.pitch = stepsoundpitch;
			speak(stepsoundpitch);
		}
		if (key_pressed(KEY_RIGHT) == false and kright.pressing() and stepsoundpitch < 200) {
			stepsoundpitch += 1;
			tst.pitch = stepsoundpitch;
			speak(stepsoundpitch);
		}
		if (key_pressed(KEY_Q) == false and kq.pressing())
			tst.seek(tst.position - 1000);
		if (key_pressed(KEY_W) == false and kw.pressing())
			tst.seek(0);
		if (key_pressed(KEY_E) == false and ke.pressing())
			tst.seek(tst.position + 1000);
		if (key_pressed(KEY_R) == false and kr.pressing()) {
			stepsoundvolume = 0;
			stepsoundpitch = 100;
			tst.volume = stepsoundvolume;
			tst.pitch = stepsoundpitch;
			speak("the stepsoundvolume and stepsoundpitch has been reset. stepsoundvolume: 0. stepsoundpitch: 100");
		}
		if (key_pressed(KEY_SPACE) == false and kspace.pressing()) {
			if (tst.playing == true)
				tst.pause();
			else
				tst.play();
		}
		if (key_pressed(KEY_ESCAPE)) {
			speak("canceled");
			tst.stop();
			tst.close();
			return;
		}
		if (key_pressed(KEY_RETURN)) {
			tst.stop();
			tst.close();
			return;
		}
	}
}
void aipainsoundsrcv(string s, double vl = painsoundvolume, double spainsoundpitch = painsoundpitch) {
	speak("pain sound options. Press or hold space to play/pause the track. Press or hold up and down arrows to change the sound painsoundvolume. Press or hold left and right arrows to change it's painsoundpitch. Press or hold r to reset the painsoundvolume and painsoundpitch. Press or hold q to seek backward. Press or hold e to seek forward. Press or hold w to go to the beginning of the track. Press escape to cancel. Press enter to submit");
	sound tst;
	tst.load(s);
	tst.volume = painsoundvolume;
	tst.pitch = painsoundpitch;
	tst.play_looped();
	while (true) {
		wait(5);
		mainloop();
		if (key_pressed(KEY_DOWN) == false and kdown.pressing() and painsoundvolume > -60) {
			painsoundvolume += -1;
			tst.volume = painsoundvolume;
			speak(painsoundvolume);
		}
		if (key_pressed(KEY_UP) == false and kup.pressing() and painsoundvolume < 0) {
			painsoundvolume += 1;
			tst.volume = painsoundvolume;
			speak(painsoundvolume);
		}
		if (key_pressed(KEY_LEFT) == false and kleft.pressing() and painsoundpitch > 0) {
			painsoundpitch += -1;
			tst.pitch = painsoundpitch;
			speak(painsoundpitch);
		}
		if (key_pressed(KEY_RIGHT) == false and kright.pressing() and painsoundpitch < 200) {
			painsoundpitch += 1;
			tst.pitch = painsoundpitch;
			speak(painsoundpitch);
		}
		if (key_pressed(KEY_Q) == false and kq.pressing())
			tst.seek(tst.position - 1000);
		if (key_pressed(KEY_W) == false and kw.pressing())
			tst.seek(0);
		if (key_pressed(KEY_E) == false and ke.pressing())
			tst.seek(tst.position + 1000);
		if (key_pressed(KEY_R) == false and kr.pressing()) {
			painsoundvolume = 0;
			painsoundpitch = 100;
			tst.volume = painsoundvolume;
			tst.pitch = painsoundpitch;
			speak("the painsoundvolume and painsoundpitch has been reset. painsoundvolume: 0. painsoundpitch: 100");
		}
		if (key_pressed(KEY_SPACE) == false and kspace.pressing()) {
			if (tst.playing == true)
				tst.pause();
			else
				tst.play();
		}
		if (key_pressed(KEY_ESCAPE)) {
			speak("canceled");
			tst.stop();
			tst.close();
			return;
		}
		if (key_pressed(KEY_RETURN)) {
			tst.stop();
			tst.close();
			return;
		}
	}
}
void aikillsoundsrcv(string s, double vl = killsoundvolume, double skillsoundpitch = killsoundpitch) {
	speak("kill sound options. Press or hold space to play/pause the track. Press or hold up and down arrows to change the sound killsoundvolume. Press or hold left and right arrows to change it's killsoundpitch. Press or hold r to reset the killsoundvolume and killsoundpitch. Press or hold q to seek backward. Press or hold e to seek forward. Press or hold w to go to the beginning of the track. Press escape to cancel. Press enter to submit");
	sound tst;
	tst.load(s);
	tst.volume = killsoundvolume;
	tst.pitch = killsoundpitch;
	tst.play_looped();
	while (true) {
		wait(5);
		mainloop();
		if (key_pressed(KEY_DOWN) == false and kdown.pressing() and killsoundvolume > -60) {
			killsoundvolume += -1;
			tst.volume = killsoundvolume;
			speak(killsoundvolume);
		}
		if (key_pressed(KEY_UP) == false and kup.pressing() and killsoundvolume < 0) {
			killsoundvolume += 1;
			tst.volume = killsoundvolume;
			speak(killsoundvolume);
		}
		if (key_pressed(KEY_LEFT) == false and kleft.pressing() and killsoundpitch > 0) {
			killsoundpitch += -1;
			tst.pitch = killsoundpitch;
			speak(killsoundpitch);
		}
		if (key_pressed(KEY_RIGHT) == false and kright.pressing() and killsoundpitch < 200) {
			killsoundpitch += 1;
			tst.pitch = killsoundpitch;
			speak(killsoundpitch);
		}
		if (key_pressed(KEY_Q) == false and kq.pressing())
			tst.seek(tst.position - 1000);
		if (key_pressed(KEY_W) == false and kw.pressing())
			tst.seek(0);
		if (key_pressed(KEY_E) == false and ke.pressing())
			tst.seek(tst.position + 1000);
		if (key_pressed(KEY_R) == false and kr.pressing()) {
			killsoundvolume = 0;
			killsoundpitch = 100;
			tst.volume = killsoundvolume;
			tst.pitch = killsoundpitch;
			speak("the killsoundvolume and killsoundpitch has been reset. killsoundvolume: 0. killsoundpitch: 100");
		}
		if (key_pressed(KEY_SPACE) == false and kspace.pressing()) {
			if (tst.playing == true)
				tst.pause();
			else
				tst.play();
		}
		if (key_pressed(KEY_ESCAPE)) {
			speak("canceled");
			tst.stop();
			tst.close();
			return;
		}
		if (key_pressed(KEY_RETURN)) {
			tst.stop();
			tst.close();
			return;
		}
	}
}
void aishootsoundsrcv(string s, double vl = shootsoundvolume, double sshootsoundpitch = shootsoundpitch) {
	speak("shoot sound options. Press or hold space to play/pause the track. Press or hold up and down arrows to change the sound shootsoundvolume. Press or hold left and right arrows to change it's shootsoundpitch. Press or hold r to reset the shootsoundvolume and shootsoundpitch. Press or hold q to seek backward. Press or hold e to seek forward. Press or hold w to go to the beginning of the track. Press escape to cancel. Press enter to submit");
	sound tst;
	tst.load(s);
	tst.volume = shootsoundvolume;
	tst.pitch = shootsoundpitch;
	tst.play_looped();
	while (true) {
		wait(5);
		mainloop();
		if (key_pressed(KEY_DOWN) == false and kdown.pressing() and shootsoundvolume > -60) {
			shootsoundvolume += -1;
			tst.volume = shootsoundvolume;
			speak(shootsoundvolume);
		}
		if (key_pressed(KEY_UP) == false and kup.pressing() and shootsoundvolume < 0) {
			shootsoundvolume += 1;
			tst.volume = shootsoundvolume;
			speak(shootsoundvolume);
		}
		if (key_pressed(KEY_LEFT) == false and kleft.pressing() and shootsoundpitch > 0) {
			shootsoundpitch += -1;
			tst.pitch = shootsoundpitch;
			speak(shootsoundpitch);
		}
		if (key_pressed(KEY_RIGHT) == false and kright.pressing() and shootsoundpitch < 200) {
			shootsoundpitch += 1;
			tst.pitch = shootsoundpitch;
			speak(shootsoundpitch);
		}
		if (key_pressed(KEY_Q) == false and kq.pressing())
			tst.seek(tst.position - 1000);
		if (key_pressed(KEY_W) == false and kw.pressing())
			tst.seek(0);
		if (key_pressed(KEY_E) == false and ke.pressing())
			tst.seek(tst.position + 1000);
		if (key_pressed(KEY_R) == false and kr.pressing()) {
			shootsoundvolume = 0;
			shootsoundpitch = 100;
			tst.volume = shootsoundvolume;
			tst.pitch = shootsoundpitch;
			speak("the shootsoundvolume and shootsoundpitch has been reset. shootsoundvolume: 0. shootsoundpitch: 100");
		}
		if (key_pressed(KEY_SPACE) == false and kspace.pressing()) {
			if (tst.playing == true)
				tst.pause();
			else
				tst.play();
		}
		if (key_pressed(KEY_ESCAPE)) {
			speak("canceled");
			tst.stop();
			tst.close();
			return;
		}
		if (key_pressed(KEY_RETURN)) {
			tst.stop();
			tst.close();
			return;
		}
	}
}
void aihitsoundsrcv(string s, double vl = hitsoundvolume, double shitsoundpitch = hitsoundpitch) {
	speak("hit sound options. Press or hold space to play/pause the track. Press or hold up and down arrows to change the sound hitsoundvolume. Press or hold left and right arrows to change it's hitsoundpitch. Press or hold r to reset the hitsoundvolume and hitsoundpitch. Press or hold q to seek backward. Press or hold e to seek forward. Press or hold w to go to the beginning of the track. Press escape to cancel. Press enter to submit");
	sound tst;
	tst.load(s);
	tst.volume = hitsoundvolume;
	tst.pitch = hitsoundpitch;
	tst.play_looped();
	while (true) {
		wait(5);
		mainloop();
		if (key_pressed(KEY_DOWN) == false and kdown.pressing() and hitsoundvolume > -60) {
			hitsoundvolume += -1;
			tst.volume = hitsoundvolume;
			speak(hitsoundvolume);
		}
		if (key_pressed(KEY_UP) == false and kup.pressing() and hitsoundvolume < 0) {
			hitsoundvolume += 1;
			tst.volume = hitsoundvolume;
			speak(hitsoundvolume);
		}
		if (key_pressed(KEY_LEFT) == false and kleft.pressing() and hitsoundpitch > 0) {
			hitsoundpitch += -1;
			tst.pitch = hitsoundpitch;
			speak(hitsoundpitch);
		}
		if (key_pressed(KEY_RIGHT) == false and kright.pressing() and hitsoundpitch < 200) {
			hitsoundpitch += 1;
			tst.pitch = hitsoundpitch;
			speak(hitsoundpitch);
		}
		if (key_pressed(KEY_Q) == false and kq.pressing())
			tst.seek(tst.position - 1000);
		if (key_pressed(KEY_W) == false and kw.pressing())
			tst.seek(0);
		if (key_pressed(KEY_E) == false and ke.pressing())
			tst.seek(tst.position + 1000);
		if (key_pressed(KEY_R) == false and kr.pressing()) {
			hitsoundvolume = 0;
			hitsoundpitch = 100;
			tst.volume = hitsoundvolume;
			tst.pitch = hitsoundpitch;
			speak("the hitsoundvolume and hitsoundpitch has been reset. hitsoundvolume: 0. hitsoundpitch: 100");
		}
		if (key_pressed(KEY_SPACE) == false and kspace.pressing()) {
			if (tst.playing == true)
				tst.pause();
			else
				tst.play();
		}
		if (key_pressed(KEY_ESCAPE)) {
			speak("canceled");
			tst.stop();
			tst.close();
			return;
		}
		if (key_pressed(KEY_RETURN)) {
			tst.stop();
			tst.close();
			return;
		}
	}
}
void aivoicesrcv(string s, double vl = voicevolume, double svoicepitch = voicepitch) {
	speak("voice options. Press or hold space to play/pause the track. Press or hold up and down arrows to change the sound voicevolume. Press or hold left and right arrows to change it's voicepitch. Press or hold r to reset the voicevolume and voicepitch. Press or hold q to seek backward. Press or hold e to seek forward. Press or hold w to go to the beginning of the track. Press escape to cancel. Press enter to submit");
	sound tst;
	tst.load(s);
	tst.volume = voicevolume;
	tst.pitch = voicepitch;
	tst.play_looped();
	while (true) {
		wait(5);
		mainloop();
		if (key_pressed(KEY_DOWN) == false and kdown.pressing() and voicevolume > -60) {
			voicevolume += -1;
			tst.volume = voicevolume;
			speak(voicevolume);
		}
		if (key_pressed(KEY_UP) == false and kup.pressing() and voicevolume < 0) {
			voicevolume += 1;
			tst.volume = voicevolume;
			speak(voicevolume);
		}
		if (key_pressed(KEY_LEFT) == false and kleft.pressing() and voicepitch > 0) {
			voicepitch += -1;
			tst.pitch = voicepitch;
			speak(voicepitch);
		}
		if (key_pressed(KEY_RIGHT) == false and kright.pressing() and voicepitch < 200) {
			voicepitch += 1;
			tst.pitch = voicepitch;
			speak(voicepitch);
		}
		if (key_pressed(KEY_Q) == false and kq.pressing())
			tst.seek(tst.position - 1000);
		if (key_pressed(KEY_W) == false and kw.pressing())
			tst.seek(0);
		if (key_pressed(KEY_E) == false and ke.pressing())
			tst.seek(tst.position + 1000);
		if (key_pressed(KEY_R) == false and kr.pressing()) {
			voicevolume = 0;
			voicepitch = 100;
			tst.volume = voicevolume;
			tst.pitch = voicepitch;
			speak("the voicevolume and voicepitch has been reset. voicevolume: 0. voicepitch: 100");
		}
		if (key_pressed(KEY_SPACE) == false and kspace.pressing()) {
			if (tst.playing == true)
				tst.pause();
			else
				tst.play();
		}
		if (key_pressed(KEY_ESCAPE)) {
			speak("canceled");
			tst.stop();
			tst.close();
			return;
		}
		if (key_pressed(KEY_RETURN)) {
			tst.stop();
			tst.close();
			return;
		}
	}
}
void aifallsoundsrcv(string s, double vl = fallsoundvolume, double sfallsoundpitch = fallsoundpitch) {
	speak("fall sound options. Press or hold space to play/pause the track. Press or hold up and down arrows to change the sound fallsoundvolume. Press or hold left and right arrows to change it's fallsoundpitch. Press or hold r to reset the fallsoundvolume and fallsoundpitch. Press or hold q to seek backward. Press or hold e to seek forward. Press or hold w to go to the beginning of the track. Press escape to cancel. Press enter to submit");
	sound tst;
	tst.load(s);
	tst.volume = fallsoundvolume;
	tst.pitch = fallsoundpitch;
	tst.play_looped();
	while (true) {
		wait(5);
		mainloop();
		if (key_pressed(KEY_DOWN) == false and kdown.pressing() and fallsoundvolume > -60) {
			fallsoundvolume += -1;
			tst.volume = fallsoundvolume;
			speak(fallsoundvolume);
		}
		if (key_pressed(KEY_UP) == false and kup.pressing() and fallsoundvolume < 0) {
			fallsoundvolume += 1;
			tst.volume = fallsoundvolume;
			speak(fallsoundvolume);
		}
		if (key_pressed(KEY_LEFT) == false and kleft.pressing() and fallsoundpitch > 0) {
			fallsoundpitch += -1;
			tst.pitch = fallsoundpitch;
			speak(fallsoundpitch);
		}
		if (key_pressed(KEY_RIGHT) == false and kright.pressing() and fallsoundpitch < 200) {
			fallsoundpitch += 1;
			tst.pitch = fallsoundpitch;
			speak(fallsoundpitch);
		}
		if (key_pressed(KEY_Q) == false and kq.pressing())
			tst.seek(tst.position - 1000);
		if (key_pressed(KEY_W) == false and kw.pressing())
			tst.seek(0);
		if (key_pressed(KEY_E) == false and ke.pressing())
			tst.seek(tst.position + 1000);
		if (key_pressed(KEY_R) == false and kr.pressing()) {
			fallsoundvolume = 0;
			fallsoundpitch = 100;
			tst.volume = fallsoundvolume;
			tst.pitch = fallsoundpitch;
			speak("the fallsoundvolume and fallsoundpitch has been reset. fallsoundvolume: 0. fallsoundpitch: 100");
		}
		if (key_pressed(KEY_SPACE) == false and kspace.pressing()) {
			if (tst.playing == true)
				tst.pause();
			else
				tst.play();
		}
		if (key_pressed(KEY_ESCAPE)) {
			speak("canceled");
			tst.stop();
			tst.close();
			return;
		}
		if (key_pressed(KEY_RETURN)) {
			tst.stop();
			tst.close();
			return;
		}
	}
}
void add_sbuffer_item(string buffername, string item) {
	add_buffer_item(buffername, item, true);
}
int process_loops() {
	mainloop();
	return 0;
}
bool sendcommand(string what, bool reliable = true, uint id = peer_id) {
	if (stringleft(what, 1) != "/") return false;
	return send(id, what, 1, reliable);
}
void serverinput(messager@ da) {
	string title = da.get_value("title", "test");
	string packet = da.get_value("packet", "testmenu");
	string defaulttext = da.get_value("default_text", "");
	string inputn = da.get_value("inptext", "enter text");
	int length = stn(da.get_value("length", 0));
	int ml = stn(da.get_value("multiline", 0));
	int r = stn(da.get_value("readonly", 0));
	string button1 = da.get_value("button1", "");
	string button2 = da.get_value("button2", "");
	bool button1primary = int_to_bool(stn(da.get_value("button1primary", "1")));
	bool button1cancel = int_to_bool(stn(da.get_value("button1cancel", "0")));
	bool button2primary = int_to_bool(stn(da.get_value("button2primary", "0")));
	bool button2cancel = int_to_bool(stn(da.get_value("button2cancel", "1")));
	bool read = int_to_bool(r);
	bool mul = int_to_bool(ml);
	int type = stn(da.get_value("type", 0));
	string rofl;
	messager a;
	a.add("message", packet);
	rofl = input(title, inputn, defaulttext, "", length, read, mul, button1, button2, button1primary = button1primary, button1cancel = button1cancel, button2primary = button2primary, button2cancel = button2cancel);
	if (rofl == "") {
		a.add("item", "[back]");
		if (type == 0) send(peer_id, packet + " [back]", 0);
		else if (type == 1) send(peer_id, a, 0);
		return;
	}
	a.add("item", rofl);
	if (type == 0) send(peer_id, packet + " " + rofl, 0);
	else if (type == 1) send(peer_id, a, 0);
}
bool name_is_valid(string t) {
	string noa = "`+=/,\\\"~!@#$%^&*()|[]{}';:><? ";
	return !t.is_digits() && !t.is_punctuation() && t != " " && !t.empty() && !is_disallowed_char(t, noa);
}
string try_memget(string ee) {
	return string_base32_decode(ee);
}
string try_memset(string ee) {
	return string_base32_encode(ee);
}
string get_compid() property {
	return generate_system_fingerprint(app.shortname);
}
bool multicmd(string[] cmds) {
	if (cmds.length() < 1) return false;
	for (uint a = 0; a < cmds.length(); a++) {
		string c = cmds[a];
		if (c == "") continue;
		sendcommand(c);
	}
	return true;
}
bool buffercu(buffer@ b) {
	string a = b.id;
	if (a == "admintells" && !admin) return false;
	if (a == "admin chats" && !admin) return false;
	if (a == "manager chats" && !manager) return false;
	if (a == "developer chats" && !dev) return false;
	if ((a == "astc" || a == "astt") && !assistant) return false;
	if (a == "lcm chats" && !lcm && !admin) return false;
	return true;
}
